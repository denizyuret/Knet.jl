<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Softmax Classification · Knet.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Knet.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../install/">Setting up Knet</a></li><li><a class="tocitem" href="../tutorial/">Introduction to Knet</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul></li><li><span class="tocitem">Textbook</span><ul><li><a class="tocitem" href="../backprop/">Backpropagation and SGD</a></li><li class="is-active"><a class="tocitem" href>Softmax Classification</a><ul class="internal"><li><a class="tocitem" href="#Classification"><span>Classification</span></a></li><li><a class="tocitem" href="#Likelihood"><span>Likelihood</span></a></li><li><a class="tocitem" href="#Softmax"><span>Softmax</span></a></li><li><a class="tocitem" href="#One-hot-vectors"><span>One-hot vectors</span></a></li><li><a class="tocitem" href="#Gradient-of-log-likelihood"><span>Gradient of log likelihood</span></a></li><li><a class="tocitem" href="#MNIST-example"><span>MNIST example</span></a></li><li><a class="tocitem" href="#Representational-power"><span>Representational power</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../mlp/">Multilayer Perceptrons</a></li><li><a class="tocitem" href="../cnn/">Convolutional Neural Networks</a></li><li><a class="tocitem" href="../rnn/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../rl/">Reinforcement Learning</a></li><li><a class="tocitem" href="../opt/">Optimization</a></li><li><a class="tocitem" href="../gen/">Generalization</a></li><li><a class="tocitem" href="../nce/">Noise Contrastive Estimation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Textbook</a></li><li class="is-active"><a href>Softmax Classification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Softmax Classification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/softmax.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Softmax-Classification"><a class="docs-heading-anchor" href="#Softmax-Classification">Softmax Classification</a><a id="Softmax-Classification-1"></a><a class="docs-heading-anchor-permalink" href="#Softmax-Classification" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Concepts</header><div class="admonition-body"><p>classification, likelihood, softmax, one-hot vectors, zero-one loss, conditional likelihood, MLE, NLL, cross-entropy loss</p></div></div><p>We will introduce classification problems and some simple models for classification.</p><h2 id="Classification"><a class="docs-heading-anchor" href="#Classification">Classification</a><a id="Classification-1"></a><a class="docs-heading-anchor-permalink" href="#Classification" title="Permalink"></a></h2><p>Classification problems are supervised machine learning problems where the task is to predict a discrete class for a given input (unlike regression where the output was numeric). A typical example is handwritten digit recognition where the input is an image of a handwritten digit, and the output is one of the discrete categories <span>$\{0, \ldots, 9\}$</span>. As in all supervised learning problems the training data consists of a set of example input-output pairs.</p><h2 id="Likelihood"><a class="docs-heading-anchor" href="#Likelihood">Likelihood</a><a id="Likelihood-1"></a><a class="docs-heading-anchor-permalink" href="#Likelihood" title="Permalink"></a></h2><p>A natural objective in classification could be to minimize the number of misclassified examples in the training data. This number is known as the <strong>zero-one loss</strong>. However the zero-one loss has some undesirable properties for training: in particular it is discontinuous. A small change in one of the parameters either has no effect on the loss, or can turn one or more of the predictions from false to true or true to false, causing a discontinuous jump in the objective. This means the gradient of the zero-one loss with respect to the parameters is either undefined or zero, thus not helpful.</p><p>A more commonly used objective for classification is conditional likelihood: the probability of the observed data given our model <em>and the inputs</em>. Instead of predicting a single class for each instance, we let our model predict a probability distribution over all classes. Then we adjust the weights of the model to increase the probabilities for the correct classes and decrease it for others. This is also known as the <strong>maximum likelihood estimation</strong> (MLE).</p><p>Let <span>$\mathcal{X}=\{x_1,\ldots,x_N\}$</span> be the inputs in the training data, <span>$\mathcal{Y}=\{y_1,\ldots,y_N\}$</span> be the correct classes and <span>$\theta$</span> be the parameters of our model. Conditional likelihood is:</p><p class="math-container">\[L(\theta) = P(\mathcal{Y}|\mathcal{X},\theta) 
= \prod_{n=1}^N P(y_n|x_n,\theta)\]</p><p>The second equation assumes that the data instances were generated independently. </p><p>We usually work with log likelihood for mathematical convenience: log is a monotonically increasing function, so maximizing likelihood is the same as maximizing log likelihood:</p><p class="math-container">\[\ell(\theta) = \log P(\mathcal{Y}|\mathcal{X},\theta) 
= \sum_{n=1}^N \log P(y_n|x_n,\theta)\]</p><p>We will typically use the negative of <span>$\ell$</span> (machine learning people like to minimize), which is known as <strong>negative log likelihood</strong> (NLL), or <strong>cross-entropy loss</strong>.</p><h2 id="Softmax"><a class="docs-heading-anchor" href="#Softmax">Softmax</a><a id="Softmax-1"></a><a class="docs-heading-anchor-permalink" href="#Softmax" title="Permalink"></a></h2><p>A classification model for a problem with <span>$C$</span> classes typically generates <span>$y\in\mathbb{R}^C$</span>, a vector of <span>$C$</span> scores (e.g. we might use multivariate linear regression with a vector output as seen in the last chapter).  In general these scores will be arbitrary real numbers.  To go from arbitrary scores <span>$y\in\mathbb{R}^C$</span> to normalized probability estimates <span>$p\in\mathbb{R}^C$</span> for a single instance, we use exponentiation and normalization:</p><p class="math-container">\[p_i = \frac{\exp y_i}{\sum_{c=1}^C \exp y_c}\]</p><p>where <span>$i,c\in\{1,\ldots,C\}$</span> range over classes, and <span>$p_i, y_i, y_c$</span> refer to class probabilities and scores for a single instance. This is called the <strong>softmax function</strong>. A model that converts the unnormalized values at the end of a linear regression to normalized probabilities for classification is called the <strong>softmax classifier</strong>.</p><p>We need to figure out the backward pass for the softmax function. In other words if someone gives us the gradient of some objective <span>$J$</span> with respect to the class probabilities <span>$p$</span> for a single training instance, what is the gradient with respect to the input of the softmax <span>$y$</span>? First we&#39;ll find the partial derivative of one component of <span>$p$</span> with respect to one component of <span>$y$</span>:</p><p class="math-container">\[\frac{\partial p_i}{\partial y_j} 
= \frac{[i=j] \exp y_i (\sum_c \exp y_c) - \exp y_i \exp y_j}{(\sum_c \exp y_c)^2}
= \,[i=j]\, p_i - p_i p_j\]</p><p>The square brackets are the <a href="https://en.wikipedia.org/wiki/Iverson_bracket">Iverson bracket</a> notation, i.e. <span>$[A]$</span> is 1 if <span>$A$</span> is true, and 0 if <span>$A$</span> is false.</p><p>Note that a single entry in <span>$y$</span> effects <span>$J$</span> through multiple paths (<span>$y_j$</span> contributes to the denominator of every <span>$p_i$</span>), and these effects need to be added for <span>$\partial J/\partial y_j$</span>:</p><p class="math-container">\[\frac{\partial J}{\partial y_j}
= \sum_{i=1}^C \frac{\partial J}{\partial p_i}
\frac{\partial p_i}{\partial y_j}\]</p><h2 id="One-hot-vectors"><a class="docs-heading-anchor" href="#One-hot-vectors">One-hot vectors</a><a id="One-hot-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#One-hot-vectors" title="Permalink"></a></h2><p>When using a probabilistic classifier, it is convenient to represent the desired output as a <strong>one-hot vector</strong>, i.e. a vector in which all entries are &#39;0&#39; except a single &#39;1&#39;. If the correct class is <span>$c\in\{1,\ldots,C\}$</span>, we represent this with a one-hot vector <span>$p\in\mathbb{R}^C$</span> where <span>$p_c = 1$</span> and <span>$p_{i\neq c} = 0$</span>. Note that <span>$p$</span> can be viewed as a probability vector where all the probability mass is concentrated at class c. This representation also allows us to have probabilistic targets where there is not a single answer but target probabilities associated with each answer. Given a one-hot (or probabilistic) <span>$p$</span>, and the model prediction <span>$\hat{p}$</span>, we can write the log-likelihood for a single instance as:</p><p class="math-container">\[\ell = \sum_{c=1}^C p_c \log \hat{p}_c\]</p><h2 id="Gradient-of-log-likelihood"><a class="docs-heading-anchor" href="#Gradient-of-log-likelihood">Gradient of log likelihood</a><a id="Gradient-of-log-likelihood-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-of-log-likelihood" title="Permalink"></a></h2><p>To compute the gradient for log likelihood, we need to make the normalization of <span>$\hat{p}$</span> explicit:</p><p class="math-container">\[\begin{aligned}
\ell &amp;= \sum_c p_c \log \frac{\hat{p}_c}{\sum_k\hat{p}_k} \\
&amp;= (\sum_c p_c \log{\hat{p}_c}) - (\sum_c p_c \log \sum_k\hat{p}_k) \\
&amp;= (\sum_c p_c \log{\hat{p}_c}) - (\log \sum_k\hat{p}_k) \\
\frac{\partial \ell}{\partial \hat{p}_i} &amp;=
\frac{p_i}{\hat{p}_i} - \frac{1}{\sum_k\hat{p}_k}
= \frac{p_i}{\hat{p}_i} - 1
\end{aligned}\]</p><p>The gradient with respect to unnormalized y scores takes a particularly simple form:</p><p class="math-container">\[\begin{aligned}
\frac{\partial\ell}{\partial y_j}
&amp;= \sum_i \frac{\partial\ell}{\partial \hat{p}_i}
\frac{\partial \hat{p}_i}{\partial y_j} \\
&amp;= \sum_i (\frac{p_i}{\hat{p}_i} - 1)(\,[i=j]\, \hat{p}_i - \hat{p}_i \hat{p}_j) \\
&amp;= \, p_j - \hat{p}_j \\
\nabla_y \ell &amp;= \, p - \hat{p}
\end{aligned}\]</p><p>The gradient with respect to <span>$\hat{p}$</span> causes numerical overflow when some components of <span>$\hat{p}$</span> get very small. In practice we usually skip that and directly compute the gradient with respect to <span>$y$</span> which is numerically stable.</p><h2 id="MNIST-example"><a class="docs-heading-anchor" href="#MNIST-example">MNIST example</a><a id="MNIST-example-1"></a><a class="docs-heading-anchor-permalink" href="#MNIST-example" title="Permalink"></a></h2><p>Let&#39;s try our softmax classifier on the <a href="http://yann.lecun.com/exdb/mnist">MNIST</a> handwritten digit classification dataset. Here are the first 8 images from MNIST, the goal is to look at the pixels and classify each image as one of the digits 0-9:</p><p><img src="../images/firsteightimages.jpg" alt="image"/></p><p>Load and minibatch the data. <code>dtrn</code> and <code>dtst</code> consist of xy pairs <code>[ (x1,y1), (x2,y2), ... ]</code> where <code>xi,yi</code> are minibatches of 100 instances:</p><pre><code class="language-none">using Knet
include(Knet.dir(&quot;data&quot;,&quot;mnist.jl&quot;))
xtrn,ytrn,xtst,ytst = mnist()
dtst = minibatch(xtst,ytst,100)
dtrn = minibatch(xtrn,ytrn,100)</code></pre><p>Here is the softmax classifier in Knet:</p><pre><code class="language-none">predict(w,x) = w[1]*mat(x) .+ w[2]	  # mat converts x to 2D
loss(w,x,ygold) = nll(predict(w,x),ygold) # nll computes negative log likelihood
lossgradient = grad(loss)                 # grad returns gradient function
wsoft=[ 0.1*randn(10,784), zeros(10,1) ]  # initial weights and bias</code></pre><p>Here is the SGD training loop (see the full example in the <a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/knet-tutorial/tutorial.ipynb">Knet tutorial</a>):</p><pre><code class="language-none">function train!(w, data; lr=.1)
    for (x,y) in data
        dw = lossgradient(w, x, y)
        for i in 1:length(w)
            w[i] -= lr * dw[i]
        end
    end
    return w
end</code></pre><p>Here are the plots of the negative log likelihood and misclassification error vs training epochs:</p><p><img src="../images/mnist_softmax.png" alt="image"/></p><p>We can observe a few things. First the training losses are better than the test losses. This means there is some <strong>overfitting</strong>, i.e. the model is learning spurious regularities in the training data that do not generalize to test data. Second, it does not look like the training loss is going down to zero. This means there is also <strong>underfitting</strong>, i.e. the softmax model is not flexible enough to fit the training data exactly.</p><h2 id="Representational-power"><a class="docs-heading-anchor" href="#Representational-power">Representational power</a><a id="Representational-power-1"></a><a class="docs-heading-anchor-permalink" href="#Representational-power" title="Permalink"></a></h2><p>So far we have seen how to create a machine learning model as a differentiable program (linear regression, softmax classification) whose parameters can be adjusted to hopefully imitate whatever process generated our training data. A natural question to ask is whether a particular model can behave like any system we want (given the right parameters) or whether there is a limit to what it can represent.</p><p>It turns out the softmax classifier is quite limited in its representational power: it can only represent linear classification boundaries. To show this, remember the form of the softmax classifier which gives the probability of the i&#39;th class as:</p><p class="math-container">\[p_i = \frac{\exp y_i}{\sum_{c=1}^C \exp y_c}\]</p><p>where <span>$y_i$</span> is a linear function of the input <span>$x$</span>. Note that <span>$p_i$</span> is a monotonically increasing function of <span>$y_i$</span>, so for two classes <span>$i$</span> and <span>$j$</span>, <span>$p_i &gt; p_j$</span> iff <span>$y_i &gt; y_j$</span>. The boundary between two classes <span>$i$</span> and <span>$j$</span> is the set of inputs for which the probability of the two classes are equal:</p><p class="math-container">\[\begin{aligned}
p_i &amp;= p_j \\
y_i &amp;= y_j \\
w_i x + b_i &amp;= w_j x + b_j \\
(w_i - w_j) x + (b_i - b_j) &amp;= 0
\end{aligned}\]</p><p>where <span>$w_i, b_i$</span> refer to the i&#39;th row of <span>$w$</span> and <span>$b$</span>. This is a linear equation, i.e. the border between two classes will always be linear in the input space with the softmax classifier:</p><p><img src="../images/linear-boundary.png" alt="image"/></p><p>In the MNIST example, the relation between the pixels and the digit classes is unlikely to be this simple. That is why we are stuck at 6-7% training error. To get better results we need more powerful models.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li><a href="http://ufldl.stanford.edu/tutorial/supervised/SoftmaxRegression">UFLDL Tutorial, Softmax Regression</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../backprop/">« Backpropagation and SGD</a><a class="docs-footer-nextpage" href="../mlp/">Multilayer Perceptrons »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 February 2021 08:46">Thursday 25 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
