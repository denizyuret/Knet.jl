var documenterSearchIndex = {"docs":
[{"location":"rnn/#Recurrent-Neural-Networks","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"","category":"section"},{"location":"rnn/#Motivation","page":"Recurrent Neural Networks","title":"Motivation","text":"","category":"section"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Recurrent neural networks (RNNs) are typically used in sequence processing applications such as natural language processing and generation. Some specific examples include:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Sequence classification: given a sequence input, produce a fixed sized output, e.g. determine the \"sentiment\" of a product review.\nSequence generation: given a fixed sized input, produce a sequence output, e.g. automatic image captioning.\nSequence tagging: given a sequence, produce a label for each token, e.g. part-of-speech tagging.\nSequence-to-sequence mapping: given a sequence, produce another, not necessarily parallel, sequence. e.g. machine translation, speech recognition.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"All feed-forward models we have seen so far (Linear, MLP, CNN) have a common limitation: They are memoryless, i.e. they apply the same computational steps to each instance without any memory of previous instances. Each output is obtained from the current input and model parameters using a fixed number of common operations:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"haty_t = f(x_tw)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"A model with no memory is difficult to apply to variable sized inputs and outputs with nontrivial dependencies.  Let us take sequence tagging as an example problem.  To apply a feed-forward model to a sequence, one option is to treat each token of the sequence as an individual input:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"(Image: image)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Applying the same computation to each input token makes sense only if the different input-output pairs are IID (independent and identically distributed).  However the IID assumption is violated in typical sequence processing applications like language modeling and speech recognition where the output of one time step may depend on the inputs and outputs from other time steps.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"<!--\n[](TODO: Applying a fixed number of computational steps: why limiting?when a single layer is universal?  check the proofs.)  \n[](fixed size api from karpathy)\n-->","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Another option is to treat the whole sequence as a single input:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"(Image: image)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"The first problem with this approach is that the inputs are of varying length.  We could potentially address this issue using a convolutional architecture, and this is a viable alternative for sequence classification problems.  However we have a more serious problem with variable length outputs: The space of possible outputs grow exponentially with length and output tokens have possible dependencies between them.  Problems of this type are known as \"structured prediction\", see (Smith 2011) for a good introduction. It is not clear how to generate and score variable sized outputs in a single shot with a single feed-forward model.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"<!--\n[](convolutions for sequences: Potential research topic!)\n[](exponential output growth: Can we tie this to fixed number of computational steps?)\n-->","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Finally we can generate each output token separately, but take a fixed sized window around the corresponding input token to take into account more context:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"(Image: image)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"This is the approach taken by, e.g. n-gram language models, and Bengio's MLP language model.  The problem with this approach is that we don't know how large the window needs to be.  In fact different tokens may require different sized windows, e.g. long range dependencies between words in a sentence.  RNNs provide a more elegant solution.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"RNNs process the input sequence one token at a time.  However, each output is not only a function of the current input, but some internal state determined by previous time steps:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"langlehaty_th_trangle = f(x_twh_t-1)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"(Image: image)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"The state h_t can be thought of as analogous to a memory device storing variables in a computer program.  In fact, RNNs have been proven to be Turing complete machines (however see this and this for a discussion).  At each time step, the RNN processes the current input x_t using the \"program\" specified by parameters w and the internal \"variables\" specified by h_t-1.  The program stores new values in its internal variables with h_t and possibly produces an output haty_t.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"<!--\n[](turing completeness, program analogy, but first figure out universality of mlp vs turing completeness of rnn)\n[](parameter sharing perspective, goodfellow: compare with 1-D convolution.)\n[](simple examples with irnn: adding, mnist-by-pixel, lm, timit, do we have data?)\n[](other possible examples: postag, charner.)\n-->","category":"page"},{"location":"rnn/#Architectures","page":"Recurrent Neural Networks","title":"Architectures","text":"","category":"section"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Depending on the type of problem, we can deploy an RNNs with architectures other than the tagger architecture we saw above.  Some examples are:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Sequence classification","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"(Image: image)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Sequence generation","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"(Image: image)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Sequence to sequence mapping models which combine the previous two architectures. The input sequence is processed by an encoder RNN (E), and the output sequence is generated by a decoder RNN (D). Information is passed from the encoder to the decoder through the initial hidden state, or an extra input, or an attention mechanism.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"(Image: image)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"<!--\n[](Modeling sequences: hinton)\n[](input to output sequence speech, synched, unsynched, when does output start/stop if unsynched ctc)\n[](predict next token lm)\n[](sequence classification)\n[](s2s models)\n[](Karpathy's graph is more clear)\n[](Hinton's providing input and teaching signals variations)\n[](graves book chap 2 has a classification, )\n[](Goodfellow 10.5 Seq->Tok, 10.9 Tok->Seq Tok=Initial and/or Tok=>Input, 10.3,4,10,11 SeqN->SeqN, Sec 10.4 S2S.)\n[](deeplearningbook 379 fig 10.3,4,5 has example design patterns)\n[](Models: hinton)\n[](memoryless models, bengios language model)\n[](start with a regular mlp converted to rnn like Goodfellow.)\n-->","category":"page"},{"location":"rnn/#RNN-vs-MLP","page":"Recurrent Neural Networks","title":"RNN vs MLP","text":"","category":"section"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"For comparison here is the code for MLP with one hidden layer vs. the code for a comparable RNN. ","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"function mlp1(w,x)\n    h = tanh(w[1]*x .+ w[2])\n    y = w[3]*h .+ w[4]\n    return y\nend\n\nfunction rnn1(w,x,h)\n    h = tanh(w[1]*vcat(x,h) .+ w[2])\n    y = w[3]*h .+ w[4]\n    return (y,h)\nend","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Note two crucial differences: First, RNN takes h, the hidden state from the previous time step, in addition to the regular input x. Second, it returns the new value of h in addition to the regular output y.","category":"page"},{"location":"rnn/#Backpropagation-through-time","page":"Recurrent Neural Networks","title":"Backpropagation through time","text":"","category":"section"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"RNNs can be trained using the same gradient based optimization algorithms we use for feed-foward networks. This is best illustrated with a picture of an RNN unrolled in time:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"(Image: image) (image source)","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"The picture on the left depicts an RNN influencing its own hidden state A while computing its output h for a single time step.  The equivalent picture on the right shows each time step as a separate column with its own input, state and output.  We need to keep in mind that the function that goes from the input and the previous state to the output and the next state is identical at each time step.  Viewed this way, there are no cycles in the computation graph and we can treat the RNN as just a multi-layer feed-forward net which (i) has as many layers as time steps, (ii) has weights shared between different layers, and (iii) may have multiple inputs and outputs received and produced at individual layers.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Backpropagation through time (BPTT) is the SGD algorithm applied to RNNs unrolled in time.  First, the RNN is run and its outputs are collected for the whole sequence.  Then the losses for all outputs are calculated and summed.  Finally the backward pass goes over the computational graph for the whole sequence, accumulating the gradients of each parameter coming from different time steps.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"In practice, with Knet, all we have to do is to write a loss function that computes the total loss for the whole sequence and use its grad(f) for training.  Here is an example for a sequence tagger:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"function rnnloss(param,state,inputs,outputs)\n    # inputs and outputs are sequences of the same length\n    sumloss = 0\n    for t in 1:length(inputs)\n        prediction,state = rnn1(param,inputs[t],state)\n        sumloss += cross_entropy_loss(prediction,outputs[t])\n    end\n    return sumloss\nend\n\nrnngrad = grad(rnnloss)\n\n# train with our usual SGD procedure","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":" ","category":"page"},{"location":"rnn/#Vanishing-and-exploding-gradients","page":"Recurrent Neural Networks","title":"Vanishing and exploding gradients","text":"","category":"section"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"RNNs can be difficult to train because gradients passed back through many layers may vanish or explode. To see why, let us first look at the evolution of the hidden state during the forward pass of an RNN. We will ignore the input and the bias for simplicity:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"h[t+1] = tanh(W*h[t]) = tanh(W*tanh(W*h[t-1])) = ...","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"No matter how many layers we go through, the forward h values will remain in the [-1,1] range because of the squashing tanh function, no problems here.  However, look at what happens in the backward pass:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"dh[t] = W' * (dh[t+1] .* f(h[t+1]))","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"where dh[t] is the gradient of the loss with respect to h[t] and f is some elementwise function whose outputs are in the [-1,1] range (in the case of tanh, f(x)=(1+x)*(1-x)). The important thing to notice is that the dh gradients keep getting multiplied by the same matrix W' over and over again as we move backward, and the backward pass is linear, i.e. there is no squashing function.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"What happens if we keep multiplying a vector u with the same matrix over and over again?  Suppose the matrix has an eigendecomposition VLambda V^-1.  After n multiplications in effect we will have multiplied with VLambda^n V^-1 where Lambda is a diagonal matrix of eigenvalues. The components of the gradient corresponding to eigenvalues greater than 1 will grow without a bound and the components for eigenvalues less than 1 will shrink towards zero. The gradient entries that grow without a bound destabilize SGD, and the ones that shrink to zero pass no information about the error back to the parameters.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"There are several possible solutions to these problems:","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Initialize the weights to avoid eigenvalues that are too large or too small. Even initializing the weights from a model successfully trained on some other task may help start them in the right regime.\nUse gradient clipping: this is the practice of downscaling gradients if their norm is above a certain threshold to help stabilize SGD.\nUse better optimization algorithms: methods like Adam and Adagrad adjust the learning rate for each parameter based on the history of updates and may be less sensitive to vanishing and exploding gradients.\nUse RNN modules designed to preserve long range information: modules such as LSTM and GRU are designed to help information flow better across time steps and are detailed in the next section.  ","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"    ","category":"page"},{"location":"rnn/#LSTM-and-GRU","page":"Recurrent Neural Networks","title":"LSTM and GRU","text":"","category":"section"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"The Long Short Term Memory (LSTM) and the Gated Recurrent Unit (GRU) are two of the modules designed as building blocks for RNNs to address vanishing gradients and better learn long term dependencies. These units replace the simple tanh unit used in rnn1.","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"... To be continued","category":"page"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"function lstm(weight,bias,hidden,cell,input)\n    gates   = hcat(input,hidden) * weight .+ bias\n    h       = size(hidden,2)\n    forget  = sigm(gates[:,1:h])\n    ingate  = sigm(gates[:,1+h:2h])\n    outgate = sigm(gates[:,1+2h:3h])\n    change  = tanh(gates[:,1+3h:end])\n    cell    = cell .* forget + ingate .* change\n    hidden  = outgate .* tanh(cell)\n    return (hidden,cell)\nend","category":"page"},{"location":"rnn/#Practical-issues","page":"Recurrent Neural Networks","title":"Practical issues","text":"","category":"section"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"input and output (word Embedding and prediction) layers\ndecoding and generating: greedy, beam, stochastic.\nminibatching\n(Advanced topics)\n(multilayer DL 10.5)\n(bidirectional)\n(attention: http://distill.pub/2016/augmented-rnns/)\n(speech, handwriting, mt)\n(image captioning, vqa)\n(ntm, memory networks: (DL 10.12) http://distill.pub/2016/augmented-rnns/)\n(2D rnns: graves chap 8. DL end of 10.3.)\n(recursive nets? DL 10.6)\n(different length input/output sequences: graves a chapter 7 on ctc, chap 6 on hmm hybrids., olah and carter on adaptive computation time. DL 10.4 on s2s.)\n(comparison to LDS and HMM Hinton)\n(discussion of teacher forcing and its potential problems DL 10.2.1)\n(echo state networks DL 10.8 just fix the h->h weights.)\n(skip connections in time, leaky units DL 10.9)","category":"page"},{"location":"rnn/#Further-reading","page":"Recurrent Neural Networks","title":"Further reading","text":"","category":"section"},{"location":"rnn/","page":"Recurrent Neural Networks","title":"Recurrent Neural Networks","text":"Karpathy 2015. The Unreasonable Effectiveness of Recurrent Neural Networks.\nOlah 2015. Understanding LSTMs.\nHinton 2012. RNN lecture slides.\nOlah and Carter 2016. Attention and Augmented Recurrent Neural Networks.\nGoodfellow 2016. Deep Learning, Chapter 10. Sequence modeling: recurrent and recursive nets.\nGraves 2012., Supervised Sequence Labelling with Recurrent Neural Networks (textbook)\nBritz 2015. Recurrent neural networks tutorial.\nManning and Socher 2017. CS224n: Natural Language Processing with Deep Learning.\nWikipedia. Recurrent neural network.\nOrr 1999. RNN lecture notes.\nLe et al. 2015. A simple way to initialize recurrent networks of rectified linear units","category":"page"},{"location":"install/#Setting-up-Knet","page":"Setting up Knet","title":"Setting up Knet","text":"","category":"section"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"Knet.jl is a deep learning package implemented in Julia, so you should be able to run it on any machine that can run Julia. It has been extensively tested on Linux machines with NVIDIA GPUs and CUDA libraries, and it has been reported to work on OSX and Windows.  If you would like to try it on your own computer, please follow the instructions on Installation. If you would like to try working with a GPU and do not have access to one, take a look at Using Amazon AWS or Using Microsoft Azure. If you find a bug, please open a GitHub issue. If you would like to contribute to Knet, see Tips for developers. If you need help, or would like to request a feature, please use the knet-users mailing list.","category":"page"},{"location":"install/#Installation","page":"Setting up Knet","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"For best results install (1) Julia, (2) CUDA.jl, (3) Knet.jl in that order. Step (2) can be skipped if you do not need GPU support. An optional step (4) below describes how to interact with the Knet tutorial notebooks.","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"Julia: Download and install the latest version of Julia from julialang.org. As of this writing the latest version is 1.4.2 and I have tested Knet using 64-bit binaries for Generic Linux on x86, macOS, and Windows.\nCUDA.jl: If you are going to use an NVIDIA GPU, start Julia and install CUDA.jl with using Pkg; Pkg.add(\"CUDA\"). The Julia CUDA stack requires users to have a functional NVIDIA driver, see CUDA.jl installation instructions for detailed requirements. You can test your installation with using CUDA; CUDA.functional(), if CUDA is not functional, Knet will not be able to use the GPU.\nKnet: to install Knet start Julia and run using Pkg; Pkg.add(\"Knet\"). If you have problems with the installation, you can get support from knet-users.\nTutorial: The best way to learn Knet is through the included Jupyter notebooks. You need the IJulia package to run the notebooks which can be installed with: using Pkg; Pkg.add(\"IJulia\"). You can then interact with the tutorial notebooks with: using IJulia, Knet; notebook(dir=Knet.dir(\"tutorial\")). This should open a browser with a list of tutorial notebooks. If you have not used Jupyter before, please take a look at Jupyter notebook tutorials online. Note that the first time notebook() is run, there may be a long startup time for installations.","category":"page"},{"location":"install/#Tips-for-developers","page":"Setting up Knet","title":"Tips for developers","text":"","category":"section"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"Knet is an open-source project and we are always open to new contributions: bug fixes, new machine learning models and operators, inspiring examples, benchmarking results are all welcome. If you'd like to contribute to the code base, please sign up at the knet-dev mailing list and follow these tips:","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"Please get an account at github.com.\nFork the Knet   repository.\nPoint Julia to your fork with   using Pkg; pkg\"dev git@github.com:your-username/Knet.jl.git\".\nMake sure your fork is   up-to-date.\nRetrieve the latest version of the master branch using   git pull in the Knet directory.\nImplement your contribution.  This typically involves:\nCreating a git branch.\nWriting your code.\nAdding documentation under doc/src and a summary in NEWS.md.\nAdding unit tests in the test directory and using Pkg.test(\"Knet\").\nPlease submit your contribution using a pull   request.","category":"page"},{"location":"install/#Using-Amazon-AWS","page":"Setting up Knet","title":"Using Amazon AWS","text":"","category":"section"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"If you don't have access to a GPU machine, but would like to experiment with one, Amazon Web Services is a possible solution. I have prepared a machine image (AMI) with everything you need to run Knet. Here are step by step instructions for launching a GPU instance with a Knet image (the screens may have changed slightly since this writing):","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"1. First, you need to sign up and create an account following the instructions on Setting Up with Amazon EC2. Once you have an account, open the Amazon EC2 console and login. You should see the following screen:","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"(Image: image)","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"2. Make sure you select the \"Ohio\" region in the upper right corner, then click on AMIs on the lower left menu. At the search box, choose \"Public images\" and search for \"Knet\". Click on the latest Knet image (Knet-1.0.0 as of this writing). You should see the following screen with information about the Knet AMI. Click on the \"Launch\" button on the upper left.","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"(Image: image)","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"Note: Instead of \"Launch\", you may want to experiment with \"Spot Request\" under \"Actions\" to get a lower price. You may also qualify for an educational grant if you are a student or researcher.","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"3. You should see the \"Step 2: Choose an Instance Type\" page. Pick one of the GPU instances (I have tested with the g2 series and the p2 series). Click on \"Review and Launch\".","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"(Image: image)","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"4. This should take you to the \"Step 7: Review Instance Launch\" page. You can just click \"Launch\" here:","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"(Image: image)","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"5. You should see the \"key pair\" pop up menu. In order to login to your instance, you need an ssh key pair. If you have created a pair during the initial setup you can use it with \"Choose an existing key pair\". Otherwise pick \"Create a new key pair\" from the pull down menu, enter a name for it, and click \"Download Key Pair\". Make sure you keep the downloaded file, we will use it to login. After making sure you have the key file (it has a .pem extension), click \"Launch Instances\" on the lower right.","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"(Image: image)","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"6. We have completed the request. You should see the \"Launch Status\" page. Click on your instance id under \"Your instances are launching\":","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"(Image: image)","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"7. You should be taken to the \"Instances\" screen and see the address of your instance where it says something like \"Public DNS: ec2-54-153-5-184.us-west-1.compute.amazonaws.com\".","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"(Image: image)","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"8.  Open up a terminal (or Putty if you are on Windows) and type:","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"    ssh -i knetkey.pem ec2-user@ec2-54-153-5-184.us-west-1.compute.amazonaws.com","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"Replacing knetkey.pem with the path to your key file and ec2-54-153-5-184 with the address of your machine. If all goes well you should get a shell prompt on your machine instance.","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"9. There you can type julia, and at the julia prompt using Pkg, Pkg.update() and Pkg.build(\"Knet\") to get the latest versions of the packages, as the versions in the AMI may be out of date:","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"[ec2-user@ip-172-31-24-60 deps]$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.0.0 (2018-08-08)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> using Pkg\njulia> Pkg.update()\njulia> Pkg.build(\"Knet\")","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"Finally you can run Pkg.test(\"Knet\") to make sure all is good. This should take about 10-15 minutes. If all tests pass, you are ready to work with Knet:","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"julia> Pkg.test(\"Knet\")\nINFO: Testing Knet\n...\nINFO: Knet tests passed\n\njulia>","category":"page"},{"location":"install/#Using-Microsoft-Azure","page":"Setting up Knet","title":"Using Microsoft Azure","text":"","category":"section"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"Knet can be used with Azure. For GPU support, you need to create a virtual machine with GPU, for instance Standard_NC6 with Ubuntu18.04 as operating system. Then follow Using Ubuntu18.04.","category":"page"},{"location":"install/#Using-Ubuntu18.04","page":"Setting up Knet","title":"Using Ubuntu18.04","text":"","category":"section"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"The CUDA stack can be installed using the following instructions:","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"################################################################################\n##### Prerequisites\n################################################################################\n\nsudo apt install make gcc g++ wget\n\n################################################################################\n##### driver\n################################################################################\n# The appropriate driver version can be selected here:\n# http://www.nvidia.com/Download/index.aspx\n# The following code is for Azure Standard_NC6 machines (K80 GPU)\n\nwget http://us.download.nvidia.com/tesla/440.64.00/NVIDIA-Linux-x86_64-440.64.00.run\nsudo sh NVIDIA-Linux-x86_64-440.64.00.run\n\n################################################################################\n##### toolkit\n################################################################################\n# the appropriate toolkit version can be selected here:\n# https://developer.nvidia.com/cuda-downloads\n# The following code is for Azure Standard_NC6 machines (K80 GPU)\n\nwget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run\nsudo sh cuda_10.2.89_440.33.01_linux.run\n\n# add the following two lines to ~/.bashrc\nPATH=$PATH:/usr/local/cuda-10.2/bin\nLD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-10.2/lib64\n\nsudo reboot now\n\n################################################################################\n##### cudnnn\n################################################################################\n\n# download cudnn using the browser\n# https://docs.nvidia.com/deeplearning/sdk/cudnn-install/index.html\n# The following code is for Azure Standard_NC6 machines (K80 GPU)\n\ntar -xzvf cudnn-10.2-linux-x64-v7.6.5.32.tgzsudo cp cuda/include/cudnn.h /usr/local/cuda/include\nsudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64\nsudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"Afterwards Knet can be installed as usual:","category":"page"},{"location":"install/","page":"Setting up Knet","title":"Setting up Knet","text":"julia> using Pkg\njulia> Pkg.update()\njulia> Pkg.add(\"Knet\")\njulia> Pkg.build(\"Knet\")\njulia> using Knet; include(Knet.dir(\"test/gpu.jl\"))","category":"page"},{"location":"nce/#Noise-Contrastive-Estimation","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"","category":"section"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"(c) Deniz Yuret, 2015-10-09, last updated: 2019-10-01","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Noise contrastive estimation (NCE) replaces the expensive vocabulary-sized softmax operation at the final layer of language models with a cheaper sampling based operation, which results in significant speed-up during training. To motivate NCE, let us start with the basic equations for probabilistic models.","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"To model the probability distribution p(y) of a set of objects y in mathcalY, we start with a score function s_theta(y)mathcalYrightarrowmathbbR with adjustable weights theta. For example log-linear models use s_theta(y)=theta^T phi(y) where theta is a weight vector and phi(y)mathcalYrightarrowmathbbR^D is a function that maps an element of mathcalY to a vector of real valued features.  Conditional models use p(yx), s_theta(xy), and phi(xy) instead. We will stick with non-conditional notation for brevity.","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"To go from arbitrary valued scores to normalized probability estimates we use exponentiation and normalization (which, for some reason, is called the softmax function):","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"p_theta(y) = fracexp s_theta(y)sum_yin mathcalY exp s_theta(y)","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"The maximum likelihood estimate (MLE) training objective is to maximize the estimated probability of a given training set Y=y_1ldotsy_n. Assuming the instances in the training set are selected independently we have log p_theta(Y) = sum_yin Y log p_theta(y). The contribution of an individual instance to the objective is:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"L_MLE(theta) = log p_theta(y) = s_theta(y) - logsum_yinmathcalYexp s_theta(y)","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Stochastic gradient descent (SGD) uses the gradient of this quantity with respect to the weights theta to find the MLE solution:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"beginaligned\n\tnabla L_MLE(theta) = nabla s_theta(y) - nabla logsum_yinmathcalYexp s_theta(y) \n\t= nabla s_theta(y) - fracsum_yinmathcalYexp s_theta(y) nabla s_theta(y)sum_yinmathcalYexp s_theta(y) \n\t= nabla s_theta(y) - sum_yinmathcalY p_theta(y) nabla s_theta(y) \nendaligned","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Note that the second term in the final equation involves a sum over the whole mathcalY which is typically a computational nightmare. In order to avoid this sum, people have come up with all sorts of tricks.  One simple example is the perceptron approximation:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"logsum_yinmathcalYexp s_theta(y) approx max_yinmathcalY s_theta(y) \nnabla L(theta) approx nabla s_theta(y) - nabla max_yinmathcalY s_theta(y)","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Here is an example to demonstrate why this makes sense. Let's say mathcalY has three elements and their scores, s_theta(y), are 10, 20, and 30. When we exponentiate these scores we get e^10, e^20 and e^30. Note that even though 20 and 30 are not all that different, e^30approx 10^13 is significantly larger than e^20approx 5times 10^9. When we add the exponentials, e^10+e^20+e^30, the result will not be significantly different from e^30, and thus the result of the final log will not be that different from 30 (it is 30.000045401... if you are curious) (and that is why logsumexp should be called the softmax function).","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"The perceptron approximation seems to replace the expensive summation with an equally expensive looking max operation. Fortunately the max operation can be performed fast for certain classes of problems. This will be the topic of another chapter, for now let's get back to NCE.","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"NCE takes a different approach to avoid the costly summation. Instead of modeling the empirical distribution p(y) directly, it proposes solving the related binary classification problem of distinguishing samples generated by p(y) from samples generated by a \"noise\" distribution q(y). It is common practice to use a simple uniform distribution or, for language models, the unigram distribution for q(y).","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"How is the binary classification problem of deciding p vs q related to the original density estimation problem of modeling p? Assume we generate k noise samples y_1ldots ksim q(y) for each real sample and add them to our original training data. We label each real sample with d=1 and each noise sample with d=0 to train a binary classifier. The joint probability of the samples and labels in this new dataset is:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"p(d=1 y) = frac1k+1p(y) qquad p(d=0 y) = frackk+1q(y)","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"The conditional probability of the label given the sample is:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"p(d=1mid y) = fracp(y)p(y)+kq(y) qquad p(d=0mid y) = frackq(y)p(y)+kq(y)","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"This means p(d=1mid y) and p(y) are related by a simple algebraic identity. In fact, if somebody hands us a good estimate for p(d=1mid y), we can turn it into an esimate for p(y):","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"p(y) = k q(y) fracp(d=1mid y)p(d=0mid y)","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"NCE suggests training the following binary classifier model for p(d=1mid y) on the dataset with noise samples.","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"p_theta(d=1mid y) = fracexp s_theta(y)exp s_theta(y) + kq(y)","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Using this model will give us the following for p_theta(y):","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"beginaligned\n\tp_theta(y) = k q(y) fracp_theta(d=1mid y)p_theta(d=0mid y) \n\t= kq(y) fracexp s_theta(y)kq(y) \n\t= exp s_theta(y)\nendaligned","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"which amounts to assuming our costly normalization term Z=sum_yin mathcalY exp s_theta(y) is 1.","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Our new objective is to maximize the conditional probability of the NCE dataset. Consider the conditional log probability of a real sample y_0 and k noise samples y_1ldots y_k:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"beginaligned L_NCE(theta) \n\t= log p_theta(d=1mid y_0) + sum_i=1^k log p_theta(d=0mid y_i) \n\t= s_theta(y_0) - log(exp s_theta(y_0) + kq(y_0)) + sum_i=1^k log(kq(y_i)) - log(exp s_theta(y_i) + kq(y_i)) \nendaligned","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"The gradient of the new objective is:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"beginaligned nabla L_NCE(theta)\n\t= nabla s_theta(y_0) - sum_i=0^k nabla log(exp s_theta(y_i) + kq(y_i)) \n\t= nabla s_theta(y_0) - sum_i=0^k p_theta(d=1mid y_i) nabla s_theta(y_i) \nendaligned","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"In the limit krightarrowinfty we see that the NCE gradient approaches the MLE gradient:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"beginaligned nabla L_NCE(theta)\n\trightarrow nabla s_theta(y_0) - sum_yinmathcalY k q(y) p_theta(d=1mid y) nabla s_theta(y) \n\t= nabla s_theta(y_0) - sum_yinmathcalY k q(y) fracexp s_theta(y)exp s_theta(y) + kq(y) nabla s_theta(y) \n\trightarrow nabla s_theta(y_0) - sum_yinmathcalY exp s_theta(y) nabla s_theta(y) \n\t= nabla s_theta(y_0) - sum_yinmathcalY p_theta(y) nabla s_theta(y)\nendaligned","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"What does this all mean computationally? Let's compare the operations of MLE and NCE language models in their final layers. Say both models use a D-dimensional internal representation. For the MLE model, the output is a V-dimensional probability vector where V is the vocabulary size. The forward pass involves multiplication of the D-dimensional internal representation with a V times D decoding matrix and normalization of the result, an O(VD) operation.","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"The NCE model, on the other hand, only needs the scores of the correct word and K additional noise sample words during training. This involves extracting K+1 rows from the V times D decoding matrix, multiplying the D-dimensional internal representation with the resulting (K+1) times D matrix and no normalization, an O(KD) operation. Because K ll V this results in a large speed-up.","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Here is the backward pass for MLE (with subscripts dropped for brevity):","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"beginaligned\n\tp(y) = fracexp s(y)sum_yinmathcalYexp s(y) \n\tL = log p(y) = s(y) - logsum_yinmathcalYexp s(y) \n\tpartial Lpartial s(y) = 1 - p(y) \n\tpartial Lpartial s(y) = -p(y) \nendaligned","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Here is the backward pass for NCE:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"beginaligned\n\tp(d=1mid y) = fracexp s(y)exp s(y) + kq(y) qquad p(d=0mid y) = frackq(y)exp s(y) + kq(y) \n\tL = log p(d=1mid y) + sum_i=1^k log p(d=0mid y_i) \n\tL = s(y) - log(exp s(y)+kq(y)) + sum_i=1^k log(kq(y_i)) - log(exp s(y_i)+kq(y_i)) \n\tpartial Lpartial s(y) = 1 - p(d=1mid y) \n\tpartial Lpartial s(y_i) = -p(d=1mid y_i) \nendaligned","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Research Ideas:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Can we use the words in a minibatch as noise samples for each other, presumably with an importance sampling correction factor?\nCan we use other models for the binary classification problem?","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"References:","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Gutmann, M. U., & Hyvärinen, A. (2012). Noise-contrastive estimation of unnormalized statistical models, with applications to natural image statistics. The Journal of Machine Learning Research, 13(1), 307-361.","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Mnih, A., & Teh, Y. W. (2012). A fast and simple algorithm for training neural probabilistic language models. arXiv preprint arXiv:1206.6426.","category":"page"},{"location":"nce/","page":"Noise Contrastive Estimation","title":"Noise Contrastive Estimation","text":"Dyer, C. (2014). Notes on Noise Contrastive Estimation and Negative Sampling. arXiv preprint arXiv:1410.8251.","category":"page"},{"location":"backprop/#Backpropagation-and-SGD","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"note: Prerequisites\nbasic Julia, linear algebra, calculus","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"note: Concepts\nsupervised learning, training data, loss function, prediction function, squared error, gradient, backpropagation, stochastic gradient descent ","category":"page"},{"location":"backprop/#Supervised-learning","page":"Backpropagation and SGD","title":"Supervised learning","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Arthur Samuel, the author of the first self-learning checkers program, defined machine learning as a \"field of study that gives computers the ability to learn without being explicitly programmed\". This leaves the definition of learning a bit circular. Tom M. Mitchell provided a more formal definition: \"A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P if its performance at tasks in T, as measured by P, improves with experience E,\" where the task, the experience, and the performance measure are to be specified based on the problem.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"We will start with supervised learning, where the task is to predict the output of an unknown process given its input, the experience consists of training data, a set of example input-output pairs, and the performance measure is given by a loss function which tells us how far the predictions are from actual outputs.  ","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"We model the unknown process using a prediction function, a parametric function that predicts the output of the process given its input.  Here is an example:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"haty = W x + b","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Here x is the model input, haty is the model output, W is a matrix of weights, and b is a vector of biases. By adjusting the parameters of this model, i.e. the weights and the biases, we can make it compute any linear function of x.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"\"All models are wrong, but some models are useful.\" George Box famously said. We do not necessarily know that the system whose output we are trying to predict is governed by a linear relationship. All we know is a finite number of input-output examples in the training data:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"mathcalD=(x_1y_1)ldots(x_Ny_N)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"It is just that we have to start model building somewhere and the set of all linear functions is a good place to start for now.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"A commonly used loss function in problems with numeric outputs is the squared error, i.e. the average squared difference between the actual output values and the ones predicted by the model. So our goal is to find model parameters that minimize the squared error:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"argmin_Wb frac1N sum_n=1^N  haty_n - y_n ^2","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Where haty_n = W x_n + b denotes the output predicted by the model for the n th example.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"There are several methods to find the solution to the problem of minimizing squared error. Here we will present the stochastic gradient descent (SGD) method because it generalizes well to more complex models. In SGD, we take the training examples (individually or in groups), compute the gradient of the error for the current example(s) with respect to the parameters using the backpropagation algorithm, and move the parameters a small step in the direction that will decrease the error. First some notes on the math.","category":"page"},{"location":"backprop/#Partial-derivatives","page":"Backpropagation and SGD","title":"Partial derivatives","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"When we have a function with a scalar output, we can look at how its value changes in response to a small change in one of its inputs or parameters, holding the rest fixed. This is called a partial derivative. Let us consider the squared error for the n th input as an example:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"J =  W x_n + b - y_n ^2","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"So the partial derivative partial J  partial w_ij would tell us how many units J would move if we moved w_ij in W one unit (at least for small enough units). Here is a more graphical representation:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"In this figure, it is easier to see that the machinery that generates J has many \"inputs\". In particular we can talk about how J is effected by changing parameters W and b, as well as changing the input x, the model output haty, the desired output y, or intermediate values like z or r. So partial derivatives like partial J  partial x_i or partial J  partial haty_j are fair game and tell us how J would react in response to small changes in those quantities.","category":"page"},{"location":"backprop/#Chain-rule-and-backpropagation","page":"Backpropagation and SGD","title":"Chain rule and backpropagation","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"The chain rule allows us to calculate partial derivatives in terms of other partial derivatives, simplifying the overall computation. We will go over it in some detail as it forms the basis of the backpropagation algorithm. For now let us assume that each of the variables in the above example are scalars. We will start by looking at the effect of r on J and move backward from there. Basic calculus tells us that:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"beginaligned\nJ = r^2 \npartial Jpartial r = 2r\nendaligned","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Thus, if r=5 and we decrease r by a small epsilon, the squared error J will go down by 10epsilon. Now let's move back a step and look at haty:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"beginaligned\nr = haty - y \npartial rpartial haty = 1\nendaligned","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"So how much effect will a small epsilon decrease in haty have on J when r=5? Well, when haty goes down by epsilon, so will r, which means J will go down by 10epsilon again. The chain rule expresses this idea:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"fracpartial Jpartialhaty = \nfracpartial Jpartial r\nfracpartial rpartialhaty\n= 2r","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Going back further, we have:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"beginaligned\nhaty = z + b \npartial hatypartial b = 1 \npartial hatypartial z = 1\nendaligned","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Which means b and z have the same effect on J as haty and r, i.e. decreasing them by epsilon will decrease J by 2repsilon as well. Finally:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"beginaligned\nz = w x \npartial zpartial x = w \npartial zpartial w = x\nendaligned","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"This allows us to compute the effect of w on J in several steps: moving w by epsilon will move z by xepsilon, haty and r will move exactly the same amount because their partials with z are 1, and finally since r moves by xepsilon, J will move by 2rxepsilon.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"fracpartial Jpartial w =\nfracpartial Jpartial r\nfracpartial rpartial haty\nfracpartial hatypartial z\nfracpartial zpartial w\n= 2rx","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"We can represent this process of computing partial derivatives as follows:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Note that we have the same number of boxes and operations, but all the arrows are reversed. Let us call this the backward pass, and the original computation in the previous picture the forward pass. Each box in this backward-pass picture represents the partial derivative for the corresponding box in the previous forward-pass picture. Most importantly, each computation is local: each operation takes the partial derivative of its output, and multiplies it with a factor that only depends on the original input/output values to compute the partial derivative of its input(s). In fact we can implement the forward and backward passes for the linear regression model using the following local operations:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"This is basically the backpropagation algorithm in a nutshell, i.e.  backpropagation can be viewed as the application of Leibniz' chain rule from 1660s to machine learning in 1980s.","category":"page"},{"location":"backprop/#Multiple-dimensions","page":"Backpropagation and SGD","title":"Multiple dimensions","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Let's look at the case where the input and output are not scalars but vectors. In particular assume that x in mathbbR^D and y in mathbbR^C. This makes W in mathbbR^Ctimes D a matrix and zbhatyr vectors in mathbbR^C. During the forward pass, z=Wx operation is now a matrix-vector product, the additions and subtractions are elementwise operations. The squared error J=r^2=sum r_i^2 is still a scalar. For the backward pass we ask how much each element of these vectors or matrices effect J. Starting with r:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"beginaligned\nJ = sum r_i^2 \npartial Jpartial r_i = 2r_i\nendaligned","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"We see that when r is a vector, the partial derivative of each component is equal to twice that component. If we put these partial derivatives together in a vector, we obtain a gradient vector:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"nabla_r J\nequiv langle fracpartial Jpartial r_1 cdots fracpartial Jpartial r_C rangle\n= langle 2 r_1 ldots 2 r_C rangle \n= 2vecr","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"The addition, subtraction, and square norm operations work the same way as before except they act on each element. Moving back through the elementwise operations we see that:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"nabla_r J = nabla_haty J = nabla_b J = nabla_z J = 2vecr","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"For the operation z=Wx, a little algebra will show you that:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"beginaligned\nnabla_W J = nabla_z J cdot x^T \nnabla_x J = W^T cdot nabla_z J\nendaligned","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Note that the gradient of a variable has the same shape as the variable itself. In particular nabla_W J is a Ctimes D matrix. Here is the graphical representation for matrix multiplication:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/#Multiple-instances","page":"Backpropagation and SGD","title":"Multiple instances","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"We will typically process data multiple instances at a time for efficiency. Thus, the input x will be a Dtimes N matrix, and the output y will be a Ctimes N matrix, the N columns representing N different instances. Please verify to yourself that the forward and backward operations as described above handle this case without much change: the elementwise operations act on the elements of the matrices just like vectors, and the matrix multiplication and its gradient remains the same. Here is a picture of the forward and backward passes:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"The only complication is at the addition of the bias vector. In the batch setting, we are adding binmathbbR^Ctimes 1 to zinmathbbR^Ctimes N. This will be a broadcasting operation, i.e. the vector b will be added to each column of the matrix z to get haty. In the backward pass, we'll need to add the columns of nabla_haty J to get the gradient nabla_b J.","category":"page"},{"location":"backprop/#Stochastic-Gradient-Descent","page":"Backpropagation and SGD","title":"Stochastic Gradient Descent","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"The gradients calculated by backprop, nabla_w J and nabla_b J, tell us how much small changes in corresponding entries in w and b will effect the error (for the current example(s)). Small steps in the gradient direction will increase the error, steps in the opposite direction will decrease the error.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"In fact, we can show that the gradient is the direction of steepest ascent. Consider a unit vector v pointing in some arbitrary direction.  The rate of change in this direction, nabla_v J (directional derivative), is given by the projection of v onto the gradient, nabla J, i.e. their dot product nabla J cdot v:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"nabla_v J = fracpartial Jpartial x_1 v_1 + fracpartial Jpartial x_2 v_2 + cdots = nabla J cdot v","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"What direction maximizes this dot product? Recall that:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"nabla J cdot v =  nabla J   v  cos(theta)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"where theta is the angle between v and the gradient vector.  cos(theta) is maximized when the two vectors point in the same direction. So if you are going to move a fixed (small) size step, the gradient direction gives you the biggest bang for the buck.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"This suggests the following update rule:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"w leftarrow w - nabla_w J","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"This is the basic idea behind Stochastic Gradient Descent (SGD): Go over the training set instance by instance (or minibatch by minibatch). Run the backpropagation algorithm to calculate the error gradients. Update the weights and biases in the opposite direction of these gradients.  Rinse and repeat...","category":"page"},{"location":"backprop/#Housing-Example","page":"Backpropagation and SGD","title":"Housing Example","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"We will use the Boston Housing dataset from the UCI Machine Learning Repository to train a linear regression model using backprop and SGD. The dataset has housing related information for 506 neighborhoods in Boston from 1978. Each neighborhood has 14 attributes, the goal is to use the first 13, such as average number of rooms per house, or distance to employment centers, to predict the 14’th attribute: median dollar value of the houses.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"First, we download and convert the data into Julia arrays. The Knet package provides some utilities for this:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"using Knet\ninclude(Knet.dir(\"data\",\"housing.jl\"))\nx,y = housing()  # x is (13,506); y is (1,506)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Second, we implement our loss calculation in Julia. Personally I think callable objects are the most natural way to represent parametric functions. But you can use any coding style you wish as long as you can calculate a scalar loss from parameters and data.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"struct Linear; w; b; end                  # new type that can be used as a function\n(f::Linear)(x) = f.w * x .+ f.b           # prediction function if one argument\n(f::Linear)(x,y) = mean(abs2, f(x) - y)   # loss function if two arguments","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Now we can initialize a model, make some predictions, and calculate loss:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"julia> model = Linear(zeros(1,13), zeros(1))\nLinear([0.0 0.0 … 0.0 0.0], [0.0])\n\njulia> pred = model(x)          # predictions for 506 instances\n1×506 Array{Float64,2}:\n 0.0   0.0   0.0   …  0.0   0.0   0.0\n\njulia> y                        # not too close to real outputs\n1×506 Array{Float64,2}:\n 24.0  21.6  34.7  …  23.9  22.0  11.9\n\njulia> loss = model(x,y)        # average loss for 506 instances\n592.1469169960474","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"The loss gradients with respect to the model parameters can be computed manually as described above:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"julia> r = (model(x) - y) / length(y)\n1×506 Array{Float64,2}:\n -0.0474308  -0.0426877  -0.0685771  …  -0.0472332  -0.0434783  -0.0235178\n\njulia> ∇w = 2r * x'\n1×13 Array{Float64,2}:\n 7.12844  -6.617  8.88016  -3.2174  …  8.60132  9.32187  -6.12163  13.5419\n\njulia> ∇b = sum(2r)\n-45.06561264822134","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"For larger models manual gradient calculation becomes impractical.  The Knet package can calculate gradients automatically for us: (1) mark the parameters with the Param type, (2) apply the @diff macro to the loss calculation, (3) the grad function calculates the gradients:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"julia> model = Linear(Param(zeros(1,13)), Param(zeros(1)))\nLinear(P(Array{Float64,2}(1,13)), P(Array{Float64,1}(1)))\n\njulia> loss = @diff model(x,y)\nT(592.1469169960474)\n\njulia> grad(loss, model.w)\n1×13 Array{Float64,2}:\n 7.12844  -6.617  8.88016  -3.2174  …  8.60132  9.32187  -6.12163  13.5419\n\njulia> grad(loss, model.b)\n1-element Array{Float64,1}:\n -45.06561264822134","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"We can use the gradients to train our model:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"function sgdupdate(model, x, y)\n    loss = @diff model(x, y)\n    for p in params(model)\n        p .-= 0.1 * grad(loss, p)\n    end\n    return value(loss)\nend","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Here is a plot of the loss value vs the number of updates:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"julia> using Plots\njulia> plot([sgdupdate(model,x,y) for i in 1:20])","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"The new predictions are a lot closer to the actual outputs:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"julia> [ model(x); y ]\n2×506 Array{Float64,2}:\n 30.4126  24.8121  30.7946  29.2931  …  27.6193  26.1515  21.9643\n 24.0     21.6     34.7     33.4        23.9     22.0     11.9   ","category":"page"},{"location":"backprop/#Problems-with-SGD","page":"Backpropagation and SGD","title":"Problems with SGD","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Over the years, people have noted many subtle problems with the SGD algorithm and suggested improvements:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Step size: If the step sizes are too small, the SGD algorithm will take too long to converge. If they are too big it will overshoot the optimum and start to oscillate. So we scale the gradients with an adjustable parameter called the learning rate eta:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"w leftarrow w - eta nabla_w J","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Step direction: More importantly, it turns out the gradient (or its opposite) is often NOT the direction you want to go in order to minimize error. Let us illustrate with a simple picture:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"The figure on the left shows what would happen if you stood on one side of the long narrow valley and took the direction of steepest descent: this would point to the other side of the valley and you would end up moving back and forth between the two sides, instead of taking the gentle incline down as in the figure on the right. The direction across the valley has a high gradient but also a high curvature (second derivative) which means the descent will be sharp but short lived. On the other hand the direction following the bottom of the valley has a smaller gradient and low curvature, the descent will be slow but it will continue for a longer distance. Newton's method adjusts the direction taking into account the second derivative:","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"(Image: image)","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"In this figure, the two axes are w1 and w2, two parameters of our network, and the contour plot represents the error with a minimum at x.  If we start at x0, the Newton direction (in red) points almost towards the minimum, whereas the gradient (in green), perpendicular to the contours, points to the right.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Unfortunately Newton's direction is expensive to compute. However, it is also probably unnecessary for several reasons: (1) Newton gives us the ideal direction for second degree objective functions, which our objective function almost certainly is not, (2) The error function whose gradient backprop calculated is the error for the last minibatch/instance only, which at best is a very noisy approximation of the real error function, thus we shouldn't spend too much effort trying to get the direction exactly right.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"So people have come up with various approximate methods to improve the step direction. Instead of multiplying each component of the gradient with the same learning rate, these methods scale them separately using their running average (momentum, Nesterov), or RMS (Adagrad, Rmsprop).  Some even cap the gradients at an arbitrary upper limit (gradient clipping) to prevent instabilities.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"You may wonder whether these methods still give us directions that consistently increase/decrease the objective function. If we do not insist on the maximum increase, any direction whose components have the same signs as the gradient vector is guaranteed to increase the function (for short enough steps). The reason is again given by the dot product nabla J cdot v. As long as these two vectors carry the same signs in the same components, the dot product, i.e. the rate of change along v, is guaranteed to be positive.","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Minimize what? The final problem with gradient descent, other than not telling us the ideal step size or direction, is that it is not even minimizing the right objective! We want small error on never before seen test data, not just on the training data. The truth is, a sufficiently large model with a good optimization algorithm can get arbitrarily low error (down to the noise limit) on any finite training data (e.g. by just memorizing the answers). And it can typically do so in many different ways (typically many different local minima for training error in weight space exist). Some of those ways will generalize well to unseen data, some won't. And unseen data is (by definition) not seen, so how will we ever know which weight settings will do well on it?","category":"page"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"There are at least three ways people deal with this problem: (1) Bayes tells us that we should use all possible models and weigh their answers by how well they do on training data (see Radford Neal's fbm), (2) New methods like dropout that add distortions and noise to inputs, activations, or weights during training seem to help generalization, (3) Pressuring the optimization to stay in one corner of the weight space (e.g. L1, L2, maxnorm regularization) helps generalization.","category":"page"},{"location":"backprop/#References","page":"Backpropagation and SGD","title":"References","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"UFLDL Tutorial, Linear Regression\ncs231n Optimization Notes\ncs229 Convex optimization overview, Part 2\ncs229 Linear algebra review and reference\ncs229 Review of probability theory","category":"page"},{"location":"backprop/#Notes","page":"Backpropagation and SGD","title":"Notes","text":"","category":"section"},{"location":"backprop/","page":"Backpropagation and SGD","title":"Backpropagation and SGD","text":"Supervised learning is also known as regression if the outputs are numeric and classification if they are discrete. \nLinear regression is a regression model with a linear prediction function.  Linear regression with a scalar input and output is called simple linear regression, if the input is a vector we have multiple linear regression, and if the output is a vector we have multivariate linear regression.","category":"page"},{"location":"mlp/#Multilayer-Perceptrons","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"","category":"section"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"In this section we create multilayer perceptrons by stacking multiple linear layers with non-linear activation functions in between.","category":"page"},{"location":"mlp/#Stacking-linear-classifiers-is-useless","page":"Multilayer Perceptrons","title":"Stacking linear classifiers is useless","text":"","category":"section"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"We could try stacking multiple linear classifiers together. Here is a two layer model:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"function multilinear(w, x, ygold)\n    y1 = w[1] * x  .+ w[2]\n    y2 = w[3] * y1 .+ w[4]\n    return softloss(ygold, y2)\nend","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"Note that instead of using y1 as our prediction, we used it as input to another linear classifier. Intermediate arrays like y1 are known as hidden layers because their contents are not directly visible outside the model.","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"If you experiment with this model (I suggest using a smaller learning rate, e.g. 0.01), you will see that it performs similarly to the original softmax model. The reason is simple to see if we write the function computed in mathematical notation and do some algebra:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"beginaligned\nhatp = operatornamesoftmax(W_2 (W_1 x + b_1) + b_2) \n= operatornamesoftmax((W_2 W_1) x + W_2 b_1 + b_2) \n= operatornamesoftmax(W x + b)\nendaligned","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"where W=W_2 W_1 and b=W_2 b_1 + b_2. In other words, we still have a linear classifier! No matter how many linear functions you put on top of each other, what you get at the end is still a linear function. So this model has exactly the same representation power as the softmax model. Unless, we add a simple instruction...","category":"page"},{"location":"mlp/#Introducing-nonlinearities","page":"Multilayer Perceptrons","title":"Introducing nonlinearities","text":"","category":"section"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"Here is a slightly modified version of the two layer model:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"function mlp(w, x, ygold)\n    y1 = relu(w[1] * x .+ w[2])\n    y2 = w[3] * y1 .+ w[4]\n    return softloss(ygold, y2)\nend","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"MLP in mlp stands for multilayer perceptron which is one name for this type of model. The only difference with the previous example is the relu() function we introduced in the first line. This is known as the rectified linear unit (or rectifier), and is a simple function defined by relu(x)=max(x,0) applied elementwise to the input array. So mathematically what we are computing is:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"hatp = operatornamesoftmax(W_2 operatornamerelu(W_1 x + b_1) + b_2) ","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"This cannot be reduced to a linear function, which may not seem like a big difference but what a difference it makes to the model! Here are the learning curves for mlp using a hidden layer of size 64:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"(Image: image)","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"Here are the learning curves for the linear model softmax plotted at the same scale for comparison:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"(Image: image)","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"We can observe a few things: using MLP instead of a linear model brings the training error from 6.7% to 0 and the test error from 7.5% to 2.0%. There is still overfitting: the test error is not as good as the training error, but the model has no problem classifying the training data (all 60,000 examples) perfectly!","category":"page"},{"location":"mlp/#Types-of-nonlinearities-(activation-functions)","page":"Multilayer Perceptrons","title":"Types of nonlinearities (activation functions)","text":"","category":"section"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"The functions we throw between linear layers to break the linearity are called nonlinearities or activation functions. Here are some activation functions that have been used as nonlinearities:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"(Image: image)","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"The step functions were the earliest activation functions used in the perceptrons of 1950s. Unfortunately they do not give a useful derivative that can be used for training a multilayer model. Sigmoid and tanh (sigm and tanh in Knet) became popular in 1980s as smooth approximations to the step functions and allowed the application of the backpropagation algorithm. Modern activation functions like relu and maxout are piecewise linear. They are computationally inexpensive (no exponentials), and perform well in practice. We are going to use relu in most of our models. Here is the backward passes for sigmoid, tanh, and relu:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"function forward backward\nsigmoid y = frac11+e^-x nabla_x J = y(1-y) nabla_y J\ntanh y = frace^x-e^-xe^x+e^-x nabla_x J = (1+y)(1-y) nabla_y J\nrelu y = max(0x) nabla_x J =  y geq 0  nabla_y J","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"See (Karpathy, 2016, Ch 1) for more on activation functions and MLP architecture.","category":"page"},{"location":"mlp/#Representational-power","page":"Multilayer Perceptrons","title":"Representational power","text":"","category":"section"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"You might be wondering whether relu had any special properties or would any of the other nonlinearities be sufficient. Another question is whether there are functions multilayer perceptrons cannot represent and if so whether adding more layers or different types of functions would increase their representational power. The short answer is that a two layer model can approximate any function if the hidden layer is large enough, and can do so with any of the nonlinearities introduced in the last section. Multilayer perceptrons are universal function approximators!","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"We said that a two-layer MLP is a universal function approximator given enough hidden units. This brings up the questions of efficiency: how many hidden units / parameters does one need to approximate a given function and whether the number of units depends on the number of hidden layers. The efficiency is important both computationally and statistically: models with fewer parameters can be evaluated faster, and can learn from fewer examples (ref?). It turns out there are functions whose representations are exponentially more expensive in a shallow network compared to a deeper network (see (Nielsen, 2016, Ch 5) for a discussion). Recent winners of image recognition contests use networks with dozens of convolutional layers. The advantage of deeper MLPs is empirically less clear, but you should experiment with the number of units and layers using a development set when starting a new problem.","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"Please see (Nielsen, 2016, Ch 4) for an intuitive explanation of the universality result and (Bengio et al. 2016, Ch 6.4) for a more in depth discussion and references.","category":"page"},{"location":"mlp/#Matrix-vs-Neuron-Pictures","page":"Multilayer Perceptrons","title":"Matrix vs Neuron Pictures","text":"","category":"section"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"So far we have introduced multilayer perceptrons (aka artificial neural networks) using matrix operations. You may be wondering why people call them neural networks and be confused by terms like layers and units. In this section we will give the correspondence between the matrix view and the neuron view. Here is a schematic of a biological neuron (figures from (Karpathy, 2016, Ch 1)):","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"(Image: image)","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"A biological neuron is a complex organism supporting thousands of chemical reactions simultaneously under the regulation of thousands of genes, communicating with other neurons through electrical and chemical pathways involving dozens of different types of neurotransmitter molecules. We assume (do not know for sure) that the main mechanism of communication between neurons is electrical spike trains that travel from the axon of the source neuron, through connections called synapses, into dendrites of target neurons. We simplify this picture further representing the strength of the spikes and the connections with simple numbers to arrive at this cartoon model:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"(Image: )","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"This model is called an artificial neuron, a perceptron, or simply a unit in neural network literature. We know it as the softmax classifier.","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"When a number of these units are connected in layers, we get a multilayer perceptron. When counting layers, we ignore the input layer. So the softmax classifier can be considered a one layer neural network. Here is a neural network picture and the corresponding matrix picture for a two layer model:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"(Image: image)","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"(Image: image)","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"Here is a neural network picture and the corresponding matrix picture for a three layer model:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"(Image: image)","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"(Image: image)","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"We can use the following elementwise notation for the neural network picture (e.g. similar to the one used in UFLDL):","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"x_i^(l) = f(b_i^(l) + sum_j w_ij^(l) x_j^(l-1))","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"Here x_i^(l) refers to the activation of the i th unit in l th layer. We are counting the input as the 0'th layer. f is the activation function, b_i^(l) is the bias term. w_ij^(l) is the weight connecting unit j from layer l-1 to unit i from layer l. The corresponding matrix notation is:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"x^(l) = f(W^(l) x^(l-1) + b^(l))","category":"page"},{"location":"mlp/#Programming-Example","page":"Multilayer Perceptrons","title":"Programming Example","text":"","category":"section"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"In this section we introduce several Knet features that make it easier to define complex models. As our working example, we will go through several attempts to define a 3-layer MLP. Here is our first attempt:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"function mlp3a(w, x0)\n    x1 = relu(w[1] * x0 .+ w[2])\n    x2 = relu(w[3] * x1 .+ w[4])\n    return w[5] * x2 .+ w[6]\nend","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"We can identify bad software engineering practices in this definition in that it contains a lot of repetition.","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"The key to controlling complexity in computer languages is abstraction. Abstraction is the ability to name compound structures built from primitive parts, so they too can be used as primitives.","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"Defining new operators","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"We could make the definition of mlp3 more compact by defining separate functions for its layers:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"function mlp3b(w, x0)\n    x1 = relu_layer1(w, x0)\n    x2 = relu_layer2(w, x1)\n    return pred_layer3(w, x2)\nend\n\nfunction relu_layer1(w, x)\n    return relu(w[1] * x .+ w[2])\nend\n\nfunction relu_layer2(w, x)\n    return relu(w[3] * x .+ w[4])\nend\n\nfunction pred_layer3(x)\n    return w[5] * x .+ w[6]\nend","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"This may make the definition of mlp3b a bit more readable. But it does not reduce the overall length of the program. The helper functions like relu_layer1 and relu_layer2 are too similar except for the weights they use and can be reduced to a single function.","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"Increasing the number of layers","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"We can define a more general mlp model of arbitrary length. With weights of length 2n, the following model will have n layers, n-1 layers having the relu non-linearity:","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"function mlp_nlayer(w,x)\n    for i=1:2:length(w)-2\n        x = relu(w[i] * x .+ w[i+1]))\n    end\n    return w[end-1] * x .+ w[end]\nend","category":"page"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"In this example stacking the layers in a loop saved us only two lines, but the difference can be more significant in deeper models.","category":"page"},{"location":"mlp/#References","page":"Multilayer Perceptrons","title":"References","text":"","category":"section"},{"location":"mlp/","page":"Multilayer Perceptrons","title":"Multilayer Perceptrons","text":"http://neuralnetworksanddeeplearning.com/chap4.html\nhttp://www.deeplearningbook.org/contents/mlp.html\nhttp://cs231n.github.io/neural-networks-1\nhttp://ufldl.stanford.edu/tutorial/supervised/MultiLayerNeuralNetwork\nhttp://www.wildml.com/2015/09/implementing-a-neural-network-from-scratch","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Contents","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Knet","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#AutoGrad","page":"Reference","title":"AutoGrad","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoGrad","category":"page"},{"location":"reference/#Knet.AutoGrad","page":"Reference","title":"Knet.AutoGrad","text":"Usage:\n\nx = Param([1,2,3])          # user declares parameters with `Param`\nx => P([1,2,3])             # `Param` is just a struct wrapping a value\nvalue(x) => [1,2,3]         # `value` returns the thing wrapped\nsum(x .* x) => 14           # Params act like regular values\ny = @diff sum(x .* x)       # Except when we differentiate using `@diff`\ny => T(14)                  # you get another struct\nvalue(y) => 14              # which carries the same result\nparams(y) => [x]            # and the Params that it depends on \ngrad(y,x) => [2,4,6]        # and the gradients for all Params\n\nParam(x) returns a struct that acts like x but marks it as a parameter you want to compute gradients with respect to.\n\n@diff expr evaluates an expression and returns a struct that contains the result (which should be a scalar) and gradient information.\n\ngrad(y, x) returns the gradient of y (output by @diff) with respect to any parameter x::Param, or  nothing if the gradient is 0.\n\nvalue(x) returns the value associated with x if x is a Param or the output of @diff, otherwise returns x.\n\nparams(x) returns an iterator of Params found by a recursive search of object x.\n\nAlternative usage:\n\nx = [1 2 3]\nf(x) = sum(x .* x)\nf(x) => 14\ngrad(f)(x) => [2 4 6]\ngradloss(f)(x) => ([2 4 6], 14)\n\nGiven a scalar valued function f, grad(f,argnum=1) returns another function g which takes the same inputs as f and returns the gradient of the output with respect to the argnum'th argument. gradloss is similar except the resulting function also returns f's output.\n\n\n\n\n\n","category":"module"},{"location":"reference/#KnetArray","page":"Reference","title":"KnetArray","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.KnetArray","category":"page"},{"location":"reference/#Knet.KnetArrays.KnetArray","page":"Reference","title":"Knet.KnetArrays.KnetArray","text":"KnetArray{T}(undef,dims)\nKnetArray(a::AbstractArray)\nArray(k::KnetArray)\n\nContainer for GPU arrays that supports most of the AbstractArray interface.  The constructor allocates a KnetArray in the currently active device, as specified by CUDA.device(). KnetArrays and Arrays can be converted to each other as shown above, which involves copying to and from the GPU memory.  Only Float32/64 KnetArrays are fully supported.\n\nKnetArrays use the CUDA.jl package for allocation and some operations. Currently some of the custom CUDA kernels that implement elementwise, broadcasting, and reduction operations for KnetArrays work faster. Once these are improved in CUDA.jl, KnetArrays will be retired.\n\nSupported functions:\n\nIndexing: getindex, setindex! with the following index types:\n1-D: Real, Colon, OrdinalRange, AbstractArray{Real}, AbstractArray{Bool}, CartesianIndex, AbstractArray{CartesianIndex}, EmptyArray, KnetArray{Int32} (low level), KnetArray{0/1} (using float for BitArray) (1-D includes linear indexing of multidimensional arrays)\n2-D: (Colon,Union{Real,Colon,OrdinalRange,AbstractVector{Real},AbstractVector{Bool},KnetVector{Int32}}), (Union{Real,AbstractUnitRange,Colon}...) (in any order)\nN-D: (Real...)\nArray operations: ==, !=, adjoint, argmax, argmin, cat, convert, copy, copyto!, deepcopy, display, eachindex, eltype, endof, fill!, findmax, findmin, first, hcat, isapprox, isempty, length, ndims, one, ones, permutedims, pointer, rand!, randn!, reshape, similar, size, stride, strides, summary, transpose, vcat, vec, zero.  (Boolean operators generate outputs with same type as inputs; no support for KnetArray{Bool}.)\nUnary functions with broadcasting: -, abs, abs2, acos, acosh, asin, asinh, atan, atanh, cbrt, ceil, cos, cosh, cospi, digamma, erf, erfc, erfcinv, erfcx, erfinv, exp, exp10, exp2, expm1, floor, gamma, lgamma, log, log10, log1p, log2, loggamma, one, round, sign, sin, sinh, sinpi, sqrt, tan, tanh, trigamma, trunc, zero\nBinary functions with broadcasting: !=, *, +, -, /, <, <=, ==, >, >=, ^, max, min\nReduction operators: maximum, minimum, prod, sum\nStatistics: mean, std, stdm, var, varm\nLinear algebra: (*), axpy!, lmul!, norm, rmul!\nKnet extras: batchnorm, bce, bmm, cat1d, conv4, cpucopy, deconv4, dropout, elu, gpucopy, logistic, logp, logsoftmax, logsumexp, mat, nll, pool, relu, RNN, selu, sigm, softmax, unpool (Only 4D/5D, Float32/64 KnetArrays support conv4, pool, deconv4, unpool)\n\n\n\n\n\n","category":"type"},{"location":"reference/#File-I/O","page":"Reference","title":"File I/O","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.save\nKnet.load\nKnet.@save\nKnet.@load","category":"page"},{"location":"reference/#Parameter-initialization","page":"Reference","title":"Parameter initialization","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.param\nKnet.xavier\nKnet.xavier_uniform\nKnet.xavier_normal\nKnet.gaussian\nKnet.bilinear","category":"page"},{"location":"reference/#Knet.Train20.param","page":"Reference","title":"Knet.Train20.param","text":"param(array; atype)\nparam(dims...; init, atype)\nparam0(dims...; atype)\n\nThe first form returns Param(atype(array)).\n\nThe second form Returns a randomly initialized Param(atype(init(dims...))).  \n\nThe third form param0 is an alias for param(dims...; init=zeros).\n\nBy default, init is xavier_uniform and atype is Knet.atype().\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.xavier","page":"Reference","title":"Knet.Train20.xavier","text":"xavier_uniform(a...; gain=1)\nxavier(a...; gain=1)\n\nReturn uniform random weights in the range ± gain * sqrt(6 / (fanin + fanout)).  The a arguments are passed to rand to specify type and dimensions.  See (Glorot and Bengio 2010) or the PyTorch docs for a description.  The function implements equation (16) of the referenced paper. Also known as Glorot initialization. The function xavier is an alias for xavier_uniform. See also xavier_normal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.xavier_uniform","page":"Reference","title":"Knet.Train20.xavier_uniform","text":"xavier_uniform(a...; gain=1)\nxavier(a...; gain=1)\n\nReturn uniform random weights in the range ± gain * sqrt(6 / (fanin + fanout)).  The a arguments are passed to rand to specify type and dimensions.  See (Glorot and Bengio 2010) or the PyTorch docs for a description.  The function implements equation (16) of the referenced paper. Also known as Glorot initialization. The function xavier is an alias for xavier_uniform. See also xavier_normal.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.xavier_normal","page":"Reference","title":"Knet.Train20.xavier_normal","text":"xavier_normal(a...; gain=1)\n\nReturn normal distributed random weights with mean 0 and std gain * sqrt(2 / (fanin + fanout)).  The a arguments are passed to rand.  See (Glorot and Bengio 2010) and PyTorch docs for a description. Also known as Glorot initialization. See also xavier_uniform.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.gaussian","page":"Reference","title":"Knet.Train20.gaussian","text":"gaussian(a...; mean=0.0, std=0.01)\n\nReturn a Gaussian array with a given mean and standard deviation.  The a arguments are passed to randn.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.bilinear","page":"Reference","title":"Knet.Train20.bilinear","text":"Bilinear interpolation filter weights; used for initializing deconvolution layers.\n\nAdapted from https://github.com/shelhamer/fcn.berkeleyvision.org/blob/master/surgery.py#L33\n\nArguments:\n\nT : Data Type\n\nfw: Width upscale factor\n\nfh: Height upscale factor\n\nIN: Number of input filters\n\nON: Number of output filters\n\nExample usage:\n\nw = bilinear(Float32,2,2,128,128)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Activation-functions","page":"Reference","title":"Activation functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.elu\nKnet.relu\nKnet.selu\nKnet.sigm","category":"page"},{"location":"reference/#Knet.Ops20.elu","page":"Reference","title":"Knet.Ops20.elu","text":"elu(x)\n\nReturn (x > 0 ? x : exp(x)-1).\n\nReference: Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs) (https://arxiv.org/abs/1511.07289).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.relu","page":"Reference","title":"Knet.Ops20.relu","text":"relu(x)\n\nReturn max(0,x).\n\nReferences: \n\nNair and Hinton, 2010. Rectified Linear Units Improve Restricted Boltzmann Machines. ICML.\nGlorot, Bordes and Bengio, 2011. Deep Sparse Rectifier Neural Networks. AISTATS.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.selu","page":"Reference","title":"Knet.Ops20.selu","text":"selu(x)\n\nReturn λ01 * (x > 0 ? x : α01 * (exp(x)-1)) where λ01=1.0507009873554805 and α01=1.6732632423543778.\n\nReference: Self-Normalizing Neural Networks (https://arxiv.org/abs/1706.02515).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.sigm","page":"Reference","title":"Knet.Ops20.sigm","text":"sigm(x)\n\nReturn 1/(1+exp(-x)).\n\nReference: Numerically stable sigm implementation from http://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Loss-functions","page":"Reference","title":"Loss functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.accuracy\nKnet.bce\nKnet.logistic\nKnet.logp\nKnet.logsoftmax\nKnet.logsumexp\nKnet.nll\nKnet.softmax\nKnet.zeroone","category":"page"},{"location":"reference/#Knet.Ops20.accuracy","page":"Reference","title":"Knet.Ops20.accuracy","text":"accuracy(scores, labels; dims=1, average=true)\n\nGiven an unnormalized scores matrix and an Integer array of correct labels, return the ratio of instances where the correct label has the maximum score. dims=1 means instances are in columns, dims=2 means instances are in rows. Use average=false to return the pair (ncorrect,count) instead of the ratio (ncorrect/count). The valid labels should be integers in the range 1:numclasses, if labels[i] == 0, instance i is skipped.\n\n\n\n\n\naccuracy(model; data, dims=1, average=true, o...)\n\nCompute the number of correct predictions of a model over a dataset:\n\naccuracy(model(inputs; kwargs...), labels; dims) for (inputs,labels) in data\n\nand return (ncorrect/count) if average=true or (ncorrect,count) if average=false where count is the number instances not skipped (instances with label==0 are skipped) and ncorrect is the number of them correctly labeled by the model.\n\nThe model should be a function returning scores given inputs, and data should be an iterable of (inputs,labels) pairs. The valid labels should be integers in the range 1:numclasses, if labels[i] == 0, instance i is skipped.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.bce","page":"Reference","title":"Knet.Ops20.bce","text":"bce(scores, labels; average=true)\n\nComputes binary cross entropy loss given predicted unnormalized scores and answer labels for a binary prediction task. Label values should be in {0,1}. Scores are unrestricted and will be converted to probabilities using\n\nprobs = 1 ./ (1 .+ exp.(-scores))\n\nThe loss calculated is\n\n-(labels .* log.(probs) .+ (1 .- labels) .* log.(1 .- probs))\n\nThe return value is (total/count) if average=true and (total,count) if average=false where count is the number of instances and total is their total loss.\n\nSee also logistic which computes the same loss with {-1,1} labels.\n\nReference: https://towardsdatascience.com/nothing-but-numpy-understanding-creating-binary-classification-neural-networks-with-e746423c8d5c\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.logistic","page":"Reference","title":"Knet.Ops20.logistic","text":"logistic(scores, labels; average=true)\n\nComputes logistic loss given predicted unnormalized scores and answer labels for a binary prediction task.\n\nlog.(1 .+ exp.(-labels .* scores))\n\nLabel values should be {-1,1}. Scores are unrestricted.  The return value is (total/count) if average=true and (total,count) if average=false where count is the number of instances and total is their total loss.\n\nSee also bce which computes the same loss with {0,1} labels.\n\nReference: https://towardsdatascience.com/nothing-but-numpy-understanding-creating-binary-classification-neural-networks-with-e746423c8d5c\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.logp","page":"Reference","title":"Knet.Ops20.logp","text":"softmax(x; dims=:)\nlogsoftmax(x; dims=:)\n\nTreat entries in x as as unnormalized log probabilities and return normalized (log) probabilities, i.e. \n\nsoftmax(x; dims) = exp.(x) ./ sum(exp.(x); dims=dims)\nlogsoftmax(x; dims) = x .- log.(sum(exp.(x); dims=dims))\n\nFor numerical stability x = x .- maximum(x,dims=dims) is performed before exponentiation.\n\ndims is an optional argument, if not specified the normalization is over the whole x, otherwise the normalization is performed over the given dimensions.  In particular, if x is a matrix, dims=1 normalizes columns of x and dims=2 normalizes rows of x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.logsoftmax","page":"Reference","title":"Knet.Ops20.logsoftmax","text":"softmax(x; dims=:)\nlogsoftmax(x; dims=:)\n\nTreat entries in x as as unnormalized log probabilities and return normalized (log) probabilities, i.e. \n\nsoftmax(x; dims) = exp.(x) ./ sum(exp.(x); dims=dims)\nlogsoftmax(x; dims) = x .- log.(sum(exp.(x); dims=dims))\n\nFor numerical stability x = x .- maximum(x,dims=dims) is performed before exponentiation.\n\ndims is an optional argument, if not specified the normalization is over the whole x, otherwise the normalization is performed over the given dimensions.  In particular, if x is a matrix, dims=1 normalizes columns of x and dims=2 normalizes rows of x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.logsumexp","page":"Reference","title":"Knet.Ops20.logsumexp","text":"logsumexp(x;dims=:)\n\nCompute log(sum(exp(x);dims)) in a numerically stable manner.\n\ndims is an optional argument, if not specified the summation is over the whole x, otherwise the summation is performed over the given dimensions.  In particular if x is a matrix, dims=1 sums columns of x and dims=2 sums rows of x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.nll","page":"Reference","title":"Knet.Ops20.nll","text":"nll(scores, labels; dims=1, average=true)\n\nReturn the negative log likelihood for a single batch of data given an unnormalized scores matrix and an Integer array of correct labels. The scores matrix should have size (classes,instances) if dims=1 or (instances,classes) if dims=2. labels[i] should be in 1:classes to indicate the correct class for instance i, or 0 to skip instance i.\n\nThe return value is (total/count) if average=true and (total,count) if average=false where count is the number of instances not skipped (i.e. label != 0) and total is their total negative log likelihood.\n\nExample\n\nLet's assume that there are three classes (cat, dog, ostrich) and just 2 instances with the unnormalized score scores[:,1] and scores[:,2] respectively. The first instance is actually a cat and the second instance a dog:\n\nscores = [12.2    0.3;\n           2.0   21.5;\n           0.0  -21.0]\nlabels = [1, 2]\nnll(scores,labels)\n# returns 2.1657e-5\n\nThe probabilites are derived from the scores and the negative log-probabilities corresponding to the labels are averaged:\n\nprobabilites = exp.(scores) ./ sum(exp.(scores),dims=1)\n-(log(probabilites[labels[1],1]) + log(probabilites[labels[2],2]))/2\n# returns 2.1657e-5\n\n\n\n\n\nnll(model; data, dims=1, average=true, o...)\n\nCompute the negative log likelihood for a model over a dataset:\n\nnll(model(inputs; kwargs...), labels; dims) for (inputs,labels) in data\n\nand return (total/count) if average=true or (total,count) if average=false where count is the number of instances not skipped (instances with label==0 are skipped) and total is their total negative log likelihood.\n\nThe model should be a function returning scores given inputs, and data should be an iterable of (inputs,labels) pairs. The valid labels should be integers in the range 1:numclasses, if labels[i] == 0, instance i is skipped.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.softmax","page":"Reference","title":"Knet.Ops20.softmax","text":"softmax(x; dims=:)\nlogsoftmax(x; dims=:)\n\nTreat entries in x as as unnormalized log probabilities and return normalized (log) probabilities, i.e. \n\nsoftmax(x; dims) = exp.(x) ./ sum(exp.(x); dims=dims)\nlogsoftmax(x; dims) = x .- log.(sum(exp.(x); dims=dims))\n\nFor numerical stability x = x .- maximum(x,dims=dims) is performed before exponentiation.\n\ndims is an optional argument, if not specified the normalization is over the whole x, otherwise the normalization is performed over the given dimensions.  In particular, if x is a matrix, dims=1 normalizes columns of x and dims=2 normalizes rows of x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.zeroone","page":"Reference","title":"Knet.Ops20.zeroone","text":"zeroone loss is equal to 1 - accuracy\n\n\n\n\n\n","category":"function"},{"location":"reference/#Convolution-and-Pooling","page":"Reference","title":"Convolution and Pooling","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.conv4\nKnet.deconv4\nKnet.pool\nKnet.unpool","category":"page"},{"location":"reference/#Knet.Ops20.conv4","page":"Reference","title":"Knet.Ops20.conv4","text":"conv4(w, x; kwargs...)\n\nExecute convolutions or cross-correlations using filters specified with w over tensor x.\n\nIf w has dimensions (W1,W2,...,Cx,Cy) and x has dimensions (X1,X2,...,Cx,N), the result y will have dimensions (Y1,Y2,...,Cy,N) where Cx is the number of input channels, Cy is the number of output channels, N is the number of instances, and Wi,Xi,Yi are spatial dimensions with Yi determined by:\n\nYi = 1 + floor((Xi + 2*padding[i] - ((Wi-1)*dilation[i] + 1)) / stride[i])\n\npadding, stride and dilation are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.\n\nKeywords\n\npadding=0: the number of extra zeros implicitly concatenated at the start and end of each dimension.\nstride=1: the number of elements to slide to reach the next filtering window.\ndilation=1: dilation factor for each dimension.\nmode=0: 0 for convolution and 1 for cross-correlation (which flips the filter).\nalpha=1: can be used to scale the result.\ngroup=1: can be used to perform grouped convolutions.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.deconv4","page":"Reference","title":"Knet.Ops20.deconv4","text":"deconv4(w, x; kwargs...)\n\nSimulate 4-D deconvolution by using transposed convolution operation. Its forward pass is equivalent to backward pass of a convolution (gradients with respect to input tensor). Likewise, its backward pass (gradients with respect to input tensor) is equivalent to forward pass of a convolution. Since it swaps forward and backward passes of convolution operation, padding and stride options belong to output tensor. See this report for further explanation.\n\nIf w has dimensions (W1,W2,...,Cy,Cx) and x has dimensions (X1,X2,...,Cx,N), the result y=deconv4(w,x) will have dimensions (Y1,Y2,...,Cy,N) where\n\nYi = (Xi - 1)*stride[i] + ((Wi-1)*dilation[i] + 1) - 2*padding[i]\n\nHere Cx is the number of x channels, Cy is the number of y channels, N is the number of instances, and Wi,Xi,Yi are spatial dimensions. Padding and stride are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.\n\nKeywords\n\npadding=0: the number of extra zeros implicitly concatenated at the start and at the end of each dimension.\nstride=1: the number of elements to slide to reach the next filtering window.\nmode=0: 0 for convolution and 1 for cross-correlation.\nalpha=1: can be used to scale the result.\nhandle: handle to a previously created cuDNN context. Defaults to a Knet allocated handle.\ngroup=1: can be used to perform grouped convolutions.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.pool","page":"Reference","title":"Knet.Ops20.pool","text":"pool(x; kwargs...)\n\nCompute pooling of input values (i.e., the maximum or average of several adjacent values) to produce an output with smaller height and/or width.\n\nIf x has dimensions (X1,X2,...,Cx,N), the result y will have dimensions (Y1,Y2,...,Cx,N) where\n\nYi=1+floor((Xi+2*padding[i]-window[i])/stride[i])\n\nHere Cx is the number of input channels, N is the number of instances, and Xi,Yi are spatial dimensions.  window, padding and stride are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.\n\nKeywords:\n\nwindow=2: the pooling window size for each dimension.\npadding=0: the number of extra zeros implicitly concatenated at the start and at the end of each dimension.\nstride=window: the number of elements to slide to reach the next pooling window.\nmode=0: 0 for max, 1 for average including padded values, 2 for average excluding padded values, 3 for deterministic max.\nmaxpoolingNanOpt=1: Nan numbers are not propagated if 0, they are propagated if 1.\nalpha=1: can be used to scale the result.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.unpool","page":"Reference","title":"Knet.Ops20.unpool","text":"unpool(x; o...)\n\nPerform the reverse of pooling: x == pool(unpool(x;o...); o...)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Recurrent-neural-networks","page":"Reference","title":"Recurrent neural networks","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.RNN\nKnet.rnnparam\nKnet.rnnparams","category":"page"},{"location":"reference/#Knet.Ops20.RNN","page":"Reference","title":"Knet.Ops20.RNN","text":"rnn = RNN(inputSize, hiddenSize; opts...)\nrnn(x; batchSizes) => y\nrnn.h, rnn.c  # hidden and cell states\n\nRNN returns a callable RNN object rnn. Given a minibatch of sequences x, rnn(x) returns y, the hidden states of the final layer for each time step. rnn.h and rnn.c fields can be used to set the initial hidden states and read the final hidden states of all layers.  Note that the final time step of y always contains the final hidden state of the last layer, equivalent to rnn.h for a single layer network.\n\nDimensions: The input x can be 1, 2, or 3 dimensional and y will have the same number of dimensions as x. size(x)=(X,[B,T]) and size(y)=(H/2H,[B,T]) where X is inputSize, B is batchSize, T is seqLength, H is hiddenSize, 2H is for bidirectional RNNs. By default a 1-D x represents a single instance for a single time step, a 2-D x represents a single minibatch for a single time step, and a 3-D x represents a sequence of identically sized minibatches for multiple time steps. The output y gives the hidden state (of the final layer for multi-layer RNNs) for each time step. The fields rnn.h and rnn.c represent the hidden states of all layers in a single time step and have size (H,B,L/2L) where L is numLayers and 2L is for bidirectional RNNs.\n\nbatchSizes: If batchSizes=nothing (default), all sequences in a minibatch are assumed to be the same length. If batchSizes is an array of (non-increasing) integers, it gives us the batch size for each time step (allowing different sequences in the minibatch to have different lengths). In this case x will typically be 2-D with the second dimension representing variable size batches for time steps. If batchSizes is used, sum(batchSizes) should equal length(x) ÷ size(x,1). When the batch size is different in every time step, hidden states will have size (H,B,L/2L) where B is always the size of the first (largest) minibatch.\n\nHidden states: The hidden and cell states are kept in rnn.h and rnn.c fields (the cell state is only used by LSTM). They can be initialized during construction using the h and c keyword arguments, or modified later by direct assignment. Valid values are nothing (default), 0, or an array of the right type and size possibly wrapped in a Param. If the value is nothing the initial state is assumed to be zero and the final state is discarded keeping the value nothing. If the value is 0 the initial state is assumed to be zero and 0 is replaced by the final state on return. If the value is a valid state, it is used as the initial state and is replaced by the final state on return.\n\nIn a differentiation context the returned final hidden states will be wrapped in Result types. This is necessary if the same RNN object is to be called multiple times in a single iteration. Between iterations (i.e. after diff/update) the hidden states need to be unboxed with e.g. rnn.h = value(rnn.h) to prevent spurious dependencies. This happens automatically during the backward pass for GPU RNNs but needs to be done manually for CPU RNNs. See the CharLM Tutorial for an example.\n\nKeyword arguments for RNN:\n\nh=nothing: Initial hidden state.\nc=nothing: Initial cell state.\nrnnType=:lstm Type of RNN: One of :relu, :tanh, :lstm, :gru.\nnumLayers=1: Number of RNN layers.\nbidirectional=false: Create a bidirectional RNN if true.\ndropout=0: Dropout probability. Applied to input and between layers.\nskipInput=false: Do not multiply the input with a matrix if true.\nalgo=0: Algorithm to use, see CUDNN docs for details.\nseed=0: Random number seed for dropout. Uses time() if 0.\nwinit=xavier: Weight initialization method for matrices.\nbinit=zeros: Weight initialization method for bias vectors.\nfinit=ones: Weight initialization method for the bias of forget gates.\natype=Knet.atype(): array type for model weights.\n\nFormulas: RNNs compute the output h[t] for a given iteration from the recurrent input h[t-1] and the previous layer input x[t] given matrices W, R and biases bW, bR from the following equations:\n\n:relu and :tanh: Single gate RNN with activation function f:\n\nh[t] = f(W * x[t] .+ R * h[t-1] .+ bW .+ bR)\n\n:gru: Gated recurrent unit:\n\ni[t] = sigm(Wi * x[t] .+ Ri * h[t-1] .+ bWi .+ bRi) # input gate\nr[t] = sigm(Wr * x[t] .+ Rr * h[t-1] .+ bWr .+ bRr) # reset gate\nn[t] = tanh(Wn * x[t] .+ r[t] .* (Rn * h[t-1] .+ bRn) .+ bWn) # new gate\nh[t] = (1 - i[t]) .* n[t] .+ i[t] .* h[t-1]\n\n:lstm: Long short term memory unit with no peephole connections:\n\ni[t] = sigm(Wi * x[t] .+ Ri * h[t-1] .+ bWi .+ bRi) # input gate\nf[t] = sigm(Wf * x[t] .+ Rf * h[t-1] .+ bWf .+ bRf) # forget gate\no[t] = sigm(Wo * x[t] .+ Ro * h[t-1] .+ bWo .+ bRo) # output gate\nn[t] = tanh(Wn * x[t] .+ Rn * h[t-1] .+ bWn .+ bRn) # new gate\nc[t] = f[t] .* c[t-1] .+ i[t] .* n[t]               # cell output\nh[t] = o[t] .* tanh(c[t])\n\n\n\n\n\n","category":"type"},{"location":"reference/#Knet.Ops20.rnnparam","page":"Reference","title":"Knet.Ops20.rnnparam","text":"rnnparam(r::RNN, layer, id, param)\n\nReturn a single weight matrix or bias vector as a slice of RNN weights.\n\nValid layer values:\n\nFor unidirectional RNNs 1:numLayers\nFor bidirectional RNNs 1:2*numLayers, forw and back layers alternate.\n\nValid id values:\n\nFor RELU and TANH RNNs, input = 1, hidden = 2.\nFor GRU reset = 1,4; update = 2,5; newmem = 3,6; 1:3 for input, 4:6 for hidden\nFor LSTM inputgate = 1,5; forget = 2,6; newmem = 3,7; output = 4,8; 1:4 for input, 5:8 for hidden\n\nValid param values:\n\nReturn the weight matrix (transposed!) if param==1.\nReturn the bias vector if param==2.\n\nThe effect of skipInput: Let I=1 for RELU/TANH, 1:3 for GRU, 1:4 for LSTM\n\nFor skipInput=false (default), rnnparam(r,1,I,1) is a (inputSize,hiddenSize) matrix.\nFor skipInput=true, rnnparam(r,1,I,1) is nothing.\nFor bidirectional, the same applies to rnnparam(r,2,I,1): the first back layer.\nThe input biases (par=2) are returned even if skipInput=true.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.rnnparams","page":"Reference","title":"Knet.Ops20.rnnparams","text":"rnnparams(r::RNN)\n\nReturn the RNN parameters as an Array{Any}.\n\nThe order of params returned (subject to change):\n\nAll weight matrices come before all bias vectors.\nMatrices and biases are sorted lexically based on (layer,id).\nSee @doc rnnparam for valid layer and id values.\nInput multiplying matrices are nothing if r.inputMode = 1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Batch-Normalization","page":"Reference","title":"Batch Normalization","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.batchnorm\nKnet.bnmoments\nKnet.bnparams","category":"page"},{"location":"reference/#Knet.Ops20.batchnorm","page":"Reference","title":"Knet.Ops20.batchnorm","text":"batchnorm(x[, moments, params]; kwargs...)\n\nperform batch normalization on x with optional mean and variance in moments and scaling factor and bias in params. See https://arxiv.org/abs/1502.03167 for reference.\n\n2d, 4d and 5d inputs are supported. Mean and variance are computed over dimensions (2,), (1,2,4) and (1,2,3,5) for 2d, 4d and 5d arrays, respectively.\n\nmoments stores running mean and variance to be used at inference time.  It is optional in training mode, but mandatory in test mode.  Training and test modes can be controlled by the training keyword argument which defaults to Knet.training().\n\nparams stores the optional affine parameters gamma and beta.  bnparams function can be used to initialize params.\n\nExample\n\n# Inilization, C is an integer\nmoments = bnmoments()\nparams = bnparams(C)\n...\n# size(x) -> (H, W, C, N)\ny = batchnorm(x, moments, params)\n# size(y) -> (H, W, C, N)\n\nKeywords\n\neps=1e-5: The epsilon parameter added to the variance to avoid division by 0.\n\ntraining=Knet.training(): When training is true, the mean and variance of x are used  and moments argument is modified if it is provided. When training is false, mean and  variance stored in the moments argument are used.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.bnmoments","page":"Reference","title":"Knet.Ops20.bnmoments","text":"bnmoments(;momentum=0.1, mean=nothing, var=nothing, meaninit=zeros, varinit=ones)\n\nReturn a BNMoments object, a data structure used to store running mean and running variance of batch normalization with the following fields:\n\nmomentum=0.1: A real number between 0 and 1 to be used as the scale of last\n\nmean and variance. The existing running mean or variance is multiplied by (1-momentum).\n\nmean=nothing: The running mean.\nvar=nothing: The running variance.\nmeaninit=zeros: The function used for initialize the running mean. Should either be\n\nnothing or of the form ([eltype], dims...)->data. zeros is a good option.\n\nvarinit=ones: The function used for initialize the running variance. Should either be\n\nnothing or ([eltype], dims...)->data. ones is a good option.\n\nThis constructor can be used directly load moments from data. meaninit and varinit are called if mean and var are nothing. Type and size of the mean and var are determined automatically from the inputs in the batchnorm calls.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.bnparams","page":"Reference","title":"Knet.Ops20.bnparams","text":"bnparams(etype, channels::Integer)\n\nReturn a single 1d array that contains both scale and bias of batchnorm, where the first half is scale and the second half is bias.\n\nbnparams(channels) calls bnparams(Float64, channels), following Julia convention.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Model-optimization","page":"Reference","title":"Model optimization","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.minimize\nKnet.converge\nKnet.minibatch\nKnet.progress\nKnet.training","category":"page"},{"location":"reference/#Knet.Train20.minimize","page":"Reference","title":"Knet.Train20.minimize","text":"minimize(func, data, optimizer=Adam(); params)\nsgd     (func, data; lr=0.1,  gclip, params)\nmomentum(func, data; lr=0.05, gamma=0.95, gclip, params)\nnesterov(func, data; lr=0.05, gamma=0.95, gclip, params)\nadagrad (func, data; lr=0.05, eps=1e-6, gclip, params)\nrmsprop (func, data; lr=0.01, rho=0.9, eps=1e-6, gclip, params)\nadadelta(func, data; lr=1.0,  rho=0.9, eps=1e-6, gclip, params)\nadam    (func, data; lr=0.001, beta1=0.9, beta2=0.999, eps=1e-8, gclip, params)\n\nReturn an iterator which applies func to arguments in data, i.e.  (func(args...) for args in data), and updates the parameters every iteration to minimize func.  func should return a scalar value.\n\nThe common keyword argument params can be used to list the Params to be optimized.  If not specified, any Param that takes part in the computation of func(args...) will be updated.\n\nThe common keyword argument gclip can be used to implement per-parameter gradient clipping. For a parameter gradient g, if norm(g) > gclip > 0, g is scaled so that its norm is equal to gclip. If not specified no gradient clipping is performed.\n\nThese functions do not perform optimization, but return an iterator that can. Any function that produces values from an iterator can be used with such an object, e.g. progress!(sgd(f,d)) iterates the sgd optimizer and displays a progress bar. For convenience, appending ! to the name of the function iterates and returns nothing, i.e. sgd!(...) is equivalent to (for x in sgd(...) end).\n\nWe define optimizers as lazy iterators to have explicit control over them:\n\nTo report progress use progress(sgd(f,d)).\nTo run until convergence use converge(sgd(f,cycle(d))).\nTo run multiple epochs use sgd(f,repeat(d,n)).\nTo run a given number of iterations use sgd(f,take(cycle(d),n)).\nTo do a task every n iterations use (task() for (i,j) in enumerate(sgd(f,d)) if i%n == 1).\n\nThese functions apply the same algorithm with the same configuration to every parameter by default. minimize takes an explicit optimizer argument, all others call minimize with an appropriate optimizer argument (see @doc update! for a list of possible optimizers). Before calling update! on a Param, minimize sets its opt field to a copy of this default optimizer if it is not already set. The opt field is used by the update! function to determine the type of update performed on that parameter.  If you need finer grained control, you can set the optimizer of an individual Param by setting its opt field before calling one of these functions. They will not override the opt field if it is already set, e.g. sgd(model,data) will perform an Adam update for a parameter whose opt field is an Adam object. This also means you can stop and start the training without losing optimization state, the first call will set the opt fields and the subsequent calls will not override them.\n\nGiven a parameter w and its gradient g here are the updates applied by each optimizer:\n\n# sgd (http://en.wikipedia.org/wiki/Stochastic_gradient_descent)\nw .= w - lr * g\n\n# momentum (http://jlmelville.github.io/mize/nesterov.html)\nv .= gamma * v - lr * g\nw .= w + v\n\n# nesterov (http://jlmelville.github.io/mize/nesterov.html)\nw .= w - gamma * v\nv .= gamma * v - lr * g\nw .= w + (1 + gamma) * v\n\n# adagrad (http://www.jmlr.org/papers/v12/duchi11a.html)\nG .= G + g .^ 2\nw .= w - lr * g ./ sqrt(G + eps)\n\n# rmsprop (http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)\nG .= rho * G + (1-rho) * g .^ 2 \nw .= w - lr * g ./ sqrt(G + eps)\n\n# adadelta (http://arxiv.org/abs/1212.5701)\nG .= rho * G + (1-rho) * g .^ 2\nupdate = sqrt(delta + eps) .* g ./ sqrt(G + eps)\nw = w - lr * update\ndelta = rho * delta + (1-rho) * update .^ 2\n\n# adam (http://arxiv.org/abs/1412.6980)\nv = beta1 * v + (1 - beta1) * g\nG = beta2 * G + (1 - beta2) * g .^ 2\nvhat = v ./ (1 - beta1 ^ t)\nGhat = G ./ (1 - beta2 ^ t)\nw = w - (lr / (sqrt(Ghat) + eps)) * vhat\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.converge","page":"Reference","title":"Knet.Train20.converge","text":"converge(itr; alpha=0.1)\n\nReturn an iterator which acts exactly like itr, but quits when values from itr stop decreasing. itr should produce numeric values.\n\nIt can be used to train a model with the data cycled:\n\nprogress!(converge(minimize(model,cycle(data))))\n\nalpha controls the exponential average of values to detect convergence. Here is how convergence is decided:\n\np = x - avgx\navgx = c.alpha * x + (1-c.alpha) * avgx\navgp = c.alpha * p + (1-c.alpha) * avgp\navgp > 0.0 && return nothing\n\nconverge!(...) is equivalent to (for x in converge(...) end), i.e.  iterates over the object created by converge(...) and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.minibatch","page":"Reference","title":"Knet.Train20.minibatch","text":"minibatch(x, [y], batchsize; shuffle, partial, xtype, ytype, xsize, ysize)\n\nReturn an iterator of minibatches [(xi,yi)...] given data tensors x, y and batchsize.  \n\nThe last dimension of x and y give the number of instances and should be equal. y is optional, if omitted a sequence of xi will be generated rather than (xi,yi) tuples.  Use repeat(d,n) for multiple epochs, Iterators.take(d,n) for a partial epoch, and Iterators.cycle(d) to cycle through the data forever (this can be used with converge). If you need the iterator to continue from its last position when stopped early (e.g. by a break in a for loop), use Iterators.Stateful(d) (by default the iterator would restart from the beginning).\n\nKeyword arguments:\n\nshuffle=false: Shuffle the instances every epoch.\npartial=false: If true include the last partial minibatch < batchsize.\nxtype=typeof(x): Convert xi in minibatches to this type.\nytype=typeof(y): Convert yi in minibatches to this type.\nxsize=size(x): Convert xi in minibatches to this shape (with last dimension adjusted for batchsize).\nysize=size(y): Convert yi in minibatches to this shape (with last dimension adjusted for batchsize).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.progress","page":"Reference","title":"Knet.Train20.progress","text":"progress(msg, itr; steps, seconds, io)\nprogress(itr; o...) do p; [body of the msg function]; end\nprogress(itr; o...)\nprogress!(...)\n\nReturn a Progress iterator which acts exactly like itr, but prints a progressbar:\n\n┣█████████████████▎  ┫ [86.83%, 903/1040, 01:36/01:50, 9.42i/s] 3.87835\n\nHere 86.83% is the percentage completed, 903 is the number of iterations completed, 1040 is the total number of iterations. 01:36 is elapsed time, 01:50 is the estimated total time, 9.42i/s is the average number of iterations completed per second. If the speed is less than 1, the average number of seconds per iteration (s/i) is reported instead.  The bar, percent, total iterations, and estimated total time are omitted for iterators whose size is unknown.\n\nThe 3.87835 at the end is the output of the msg function applied to the Progress iterator. The message can be customized by the first two forms above, if not specified (the third form) nothing gets printed at the end of the line. The message function can use the following fields of its p::Progress argument: p.currval is the current iterator value and p.curriter is the current iteration count.\n\nThe progress bar is updated and msg is called with the Progress iterator every steps iterations or every seconds seconds in addition to the first and the last iteration. If neither steps nor seconds is specified the default is to update every second. The keyword argument io determines where the progress bar is printed, the default is stderr.\n\nThe last form, progress!(...), is equivalent to (for x in progress(...) end), i.e. iterates over the object created by progress(...) and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Hyperparameter-optimization","page":"Reference","title":"Hyperparameter optimization","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.goldensection\nKnet.hyperband","category":"page"},{"location":"reference/#Knet.Train20.goldensection","page":"Reference","title":"Knet.Train20.goldensection","text":"goldensection(f,n;kwargs) => (fmin,xmin)\n\nFind the minimum of f using concurrent golden section search in n dimensions. See Knet.goldensection_demo() for an example.\n\nf is a function from a Vector{Float64} of length n to a Number.  It can return NaN for out of range inputs.  Goldensection will always start with a zero vector as the initial input to f, and the initial step size will be 1 in each dimension.  The user should define f to scale and shift this input range into a vector meaningful for their application. For positive inputs like learning rate or hidden size, you can use a transformation such as x0*exp(x) where x is a value goldensection passes to f and x0 is your initial guess for this value. This will effectively start the search at x0, then move with multiplicative steps.\n\nI designed this algorithm combining ideas from Golden Section Search and Hill Climbing Search. It essentially runs golden section search concurrently in each dimension, picking the next step based on estimated gain.\n\nKeyword arguments\n\ndxmin=0.1: smallest step size.\naccel=φ: acceleration rate. Golden ratio φ=1.618... is best.\nverbose=false: use true to print individual steps.\nhistory=[]: cache of [(x,f(x)),...] function evaluations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.hyperband","page":"Reference","title":"Knet.Train20.hyperband","text":"hyperband(getconfig, getloss, maxresource=27, reduction=3)\n\nHyperparameter optimization using the hyperband algorithm from (Lisha et al. 2016).  You can try a simple MNIST example using Knet.hyperband_demo(). \n\nArguments\n\ngetconfig() returns random configurations with a user defined type and distribution.\ngetloss(c,n) returns loss for configuration c and number of resources (e.g. epochs) n.\nmaxresource is the maximum number of resources any one configuration should be given.\nreduction is an algorithm parameter (see paper), 3 is a good value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.bmm\nAutoGrad.cat1d\nKnet.cpucopy\nKnet.dir\nKnet.dropout\nKnet.gc\nKnet.gpu\nKnet.gpucopy\nKnet.invx\nKnet.mat\nKnet.seed!","category":"page"},{"location":"reference/#Knet.Ops20.bmm","page":"Reference","title":"Knet.Ops20.bmm","text":"bmm(A, B ; transA=false, transB=false)\n\nPerform a batch matrix-matrix product of matrices stored in A and B. size(A,2) == size(B,1) and size(A)[3:end] and size(B)[3:end] must match.  If A is a (m,n,b...) tensor, B is a (n,k,b...) tensor, and the output is a (m,k,b...)  tensor.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoGrad.cat1d","page":"Reference","title":"AutoGrad.cat1d","text":"cat1d(args...)\n\nReturn vcat(vec.(args)...) but possibly more efficiently. Can be used to concatenate the contents of arrays with different shapes and sizes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.dir","page":"Reference","title":"Knet.dir","text":"Construct a path relative to Knet root, e.g. Knet.dir(\"examples\") => \"~/.julia/dev/Knet/examples\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.dropout","page":"Reference","title":"Knet.Ops20.dropout","text":"dropout(x, p; drop, seed)\n\nGiven an array x and probability 0<=p<=1 return an array y in which each element is 0 with probability p or x[i]/(1-p) with probability 1-p. Just return x if p==0, or drop=false. By default drop=true in a @diff context, drop=false otherwise.  Specify a non-zero seed::Number to set the random number seed for reproducible results. See (Srivastava et al. 2014) for a reference.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.KnetArrays.gc","page":"Reference","title":"Knet.KnetArrays.gc","text":"Knet.gc(dev=CUDA.device().handle)\n\ncudaFree all pointers allocated on device dev that were previously allocated and garbage collected. Normally Knet holds on to all garbage collected pointers for reuse. Try this if you run out of GPU memory.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Ops20.mat","page":"Reference","title":"Knet.Ops20.mat","text":"mat(x; dims = ndims(x) - 1)\n\nReshape x into a two-dimensional matrix by joining the first dims dimensions, i.e.  reshape(x, prod(size(x,i) for i in 1:dims), :)\n\ndims=ndims(x)-1 (default) is typically used when turning the output of a 4-D convolution result into a 2-D input for a fully connected layer.\n\ndims=1 is typically used when turning the 3-D output of an RNN layer into a 2-D input for a fully connected layer.\n\ndims=0 will turn the input into a row vector, dims=ndims(x) will turn it into a column vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.KnetArrays.seed!","page":"Reference","title":"Knet.KnetArrays.seed!","text":"Call both CUDA.seed! (if available) and Random.seed!\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoGrad-(advanced)","page":"Reference","title":"AutoGrad (advanced)","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoGrad.@gcheck\nAutoGrad.@primitive\nAutoGrad.@zerograd","category":"page"},{"location":"reference/#AutoGrad.@gcheck","page":"Reference","title":"AutoGrad.@gcheck","text":"gcheck(f, x...; kw, o...)\n@gcheck f(x...; kw...) (opt1=val1,opt2=val2,...)\n\nNumerically check the gradient of f(x...; kw...) and return a boolean result.\n\nExample call: gcheck(nll,model,x,y) or @gcheck nll(model,x,y). The parameters should be marked as Param arrays in f, x, and/or kw.  Only 10 random entries in each large numeric array are checked by default.  If the output of f is not a number, we check the gradient of sum(f(x...; kw...)). Keyword arguments:\n\nkw=(): keyword arguments to be passed to f, i.e. f(x...; kw...)\nnsample=10: number of random entries from each param to check\natol=0.01,rtol=0.05: tolerance parameters.  See isapprox for their meaning.\ndelta=0.0001: step size for numerical gradient calculation.\nverbose=1: 0 prints nothing, 1 shows failing tests, 2 shows all tests.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#AutoGrad.@primitive","page":"Reference","title":"AutoGrad.@primitive","text":"@primitive  fx g1 g2...\n\nDefine a new primitive operation for AutoGrad and (optionally) specify its gradients. Non-differentiable functions such as sign, and non-numeric functions such as size should be defined using the @zerograd macro instead.\n\nExamples\n\n@primitive sin(x::Number)\n@primitive hypot(x1,x2),dy,y\n\n@primitive sin(x::Number),dy  (dy.*cos(x))\n@primitive hypot(x1,x2),dy,y  (dy.*x1./y)  (dy.*x2./y)\n\nThe first example shows that fx is a typed method declaration.  Julia supports multiple dispatch, i.e. a single function can have multiple methods with different arg types. AutoGrad takes advantage of this and supports multiple dispatch for primitives and gradients.\n\nThe second example specifies variable names for the output gradient dy and the output y after the method declaration which can be used in gradient expressions.  Untyped, ellipsis and keyword arguments are ok as in f(a::Int,b,c...;d=1).  Parametric methods such as f(x::T) where {T<:Number} cannot be used.\n\nThe method declaration can optionally be followed by gradient expressions.  The third and fourth examples show how gradients can be specified.  Note that the parameters, the return variable and the output gradient of the original function can be used in the gradient expressions.\n\nUnder the hood\n\nThe @primitive macro turns the first example into:\n\nsin(x::Value{T}) where {T<:Number} = forw(sin, x)\n\nThis will cause calls to sin with a boxed argument (Value{T<:Number}) to be recorded. The recorded operations are used by AutoGrad to construct a dynamic computational graph. With multiple arguments things are a bit more complicated.  Here is what happens with the second example:\n\nhypot(x1::Value{S}, x2::Value{T}) where {S,T} = forw(hypot, x1, x2)\nhypot(x1::S, x2::Value{T})        where {S,T} = forw(hypot, x1, x2)\nhypot(x1::Value{S}, x2::T)        where {S,T} = forw(hypot, x1, x2)\n\nWe want the forw method to be called if any one of the arguments is a boxed Value.  There is no easy way to specify this in Julia, so the macro generates all 2^N-1 boxed/unboxed argument combinations.\n\nIn AutoGrad, gradients are defined using gradient methods that have the following pattern:\n\nback(f,Arg{i},dy,y,x...) => dx[i]\n\nFor the third example here is the generated gradient method:\n\nback(::typeof(sin), ::Type{Arg{1}}, dy, y, x::Value{T}) where {T<:Number} = dy .* cos(x)\n\nFor the last example a different gradient method is generated for each argument:\n\nback(::typeof(hypot), ::Type{Arg{1}}, dy, y, x1::Value{S}, x2::Value{T}) where {S,T} = (dy .* x1) ./ y\nback(::typeof(hypot), ::Type{Arg{2}}, dy, y, x1::Value{S}, x2::Value{T}) where {S,T} = (dy .* x2) ./ y\n\nIn fact @primitive generates four more definitions for the other boxed/unboxed argument combinations.\n\nBroadcasting\n\nBroadcasting is handled by extra forw and back methods. @primitive defines the following  so that broadcasting of a primitive function with a boxed value triggers forw and back.\n\nbroadcasted(::typeof(sin), x::Value{T}) where {T<:Number} = forw(broadcasted,sin,x)\nback(::typeof(broadcasted), ::Type{Arg{2}}, dy, y, ::typeof(sin), x::Value{T}) where {T<:Number} = dy .* cos(x)\n\nIf you do not want the broadcasting methods, you can use the @primitive1 macro. If you only want the broadcasting methods use @primitive2. As a motivating example, here is how * is defined for non-scalars:\n\n@primitive1 *(x1,x2),dy  (dy*x2')  (x1'*dy)\n@primitive2 *(x1,x2),dy  unbroadcast(x1,dy.*x2)  unbroadcast(x2,x1.*dy)\n\nRegular * is matrix multiplication, broadcasted * is elementwise multiplication and the two have different gradients as defined above. unbroadcast(a,b) reduces b to the same shape as a by performing the necessary summations.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#AutoGrad.@zerograd","page":"Reference","title":"AutoGrad.@zerograd","text":"@zerograd f(args...; kwargs...)\n\nDefine f as an AutoGrad primitive operation with zero gradient.\n\nExample:\n\n@zerograd  floor(x::Float32)\n\n@zerograd allows f to handle boxed Value inputs by unboxing them like a @primitive, but unlike @primitive it does not record its actions or return a boxed Value result. Some functions, like sign(), have zero gradient.  Others, like length() have discrete or constant outputs.  These need to handle Value inputs, but do not need to record anything and can return regular values.  Their output can be treated like a constant in the program. Use the @zerograd macro for those.  Use the @zerograd1 variant if you don't want to define the broadcasting version and @zerograd2 if you only want to define the broadcasting version. Note that kwargs are NOT unboxed.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Per-parameter-optimization-(advanced)","page":"Reference","title":"Per-parameter optimization (advanced)","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The model optimization methods apply the same algorithm with the same configuration to every parameter. If you need finer grained control, you can set the optimization algorithm and configuration of an individual Param by setting its opt field to one of the optimization objects like Adam listed below. The opt field is used as an argument to update! and controls the type of update performed on that parameter. Model optimization methods like sgd will not override the opt field if it is already set, e.g. sgd(model,data) will perform an Adam update for a parameter whose opt field is an Adam object. This also means you can stop and start the training without losing optimization state, the first call will set the opt fields and the subsequent calls will not override them.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Knet.update!\nKnet.SGD\nKnet.Momentum\nKnet.Nesterov\nKnet.Adagrad\nKnet.Rmsprop\nKnet.Adadelta\nKnet.Adam","category":"page"},{"location":"reference/#Knet.Train20.update!","page":"Reference","title":"Knet.Train20.update!","text":"update!(weights::Param, gradients)\nupdate!(weights, gradients; lr=0.1, gclip=0)\nupdate!(weights, gradients, optimizers)\n\nUpdate the weights using their gradients and the optimization algorithms specified using (1) the opt field of a Param, (2) keyword arguments, (3) the third argument.\n\nweights can be an individual Param, numeric array, or a collection of arrays/Params represented by an iterator or dictionary. gradients should be a matching individual array or collection. In the first form, the optimizer should be specified in weights.opt. In the second form the optimizer defaults to SGD with learning rate lr and gradient clip gclip. In the third form optimizers should be a matching individual optimizer or collection of optimizers.  The weights and possibly gradients and optimizers are modified in-place.\n\nIndividual optimization parameters can be one of the following types. The keyword arguments for each constructor and their default values are listed as well.\n\nSGD(;lr=0.1, gclip=0)\nMomentum(;lr=0.05, gamma=0.95, gclip=0)\nNesterov(;lr=0.05, gamma=0.95, gclip=0)\nAdagrad(;lr=0.05, eps=1e-6, gclip=0)\nRmsprop(;lr=0.01, rho=0.9, eps=1e-6, gclip=0)\nAdadelta(;lr=1.0, rho=0.9, eps=1e-6, gclip=0)\nAdam(;lr=0.001, beta1=0.9, beta2=0.999, eps=1e-8, gclip=0)\n\nExample:\n\nw = Param(rand(d), Adam())  # a Param with a specified optimizer\ng = lossgradient0(w)        # gradient g has the same shape as w\nupdate!(w, g)               # update w in-place with Adam()\n\nw = rand(d)                 # an individual weight array\ng = lossgradient1(w)        # gradient g has the same shape as w\nupdate!(w, g)               # update w in-place with SGD()\nupdate!(w, g; lr=0.1)       # update w in-place with SGD(lr=0.1)\nupdate!(w, g, SGD(lr=0.1))  # update w in-place with SGD(lr=0.1)\n\nw = (rand(d1), rand(d2))    # a tuple of weight arrays\ng = lossgradient2(w)        # g will also be a tuple\np = (Adam(), SGD())         # p has optimizers for each w[i]\nupdate!(w, g, p)            # update each w[i] in-place with g[i],p[i]\n\nw = Any[rand(d1), rand(d2)] # any iterator can be used\ng = lossgradient3(w)        # g will be similar to w\np = Any[Adam(), SGD()]      # p should be an iterator of same length\nupdate!(w, g, p)            # update each w[i] in-place with g[i],p[i]\n\nw = Dict(:a => rand(d1), :b => rand(d2)) # dictionaries can be used\ng = lossgradient4(w)\np = Dict(:a => Adam(), :b => SGD())\nupdate!(w, g, p)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Knet.Train20.SGD","page":"Reference","title":"Knet.Train20.SGD","text":"SGD(;lr=0.1,gclip=0)\nupdate!(w,g,p::SGD)\nupdate!(w,g;lr=0.1)\n\nContainer for parameters of the Stochastic gradient descent (SGD) optimization algorithm used by update!.\n\nSGD is an optimization technique to minimize an objective function by updating its weights in the opposite direction of their gradient. The learning rate (lr) determines the size of the step.  SGD updates the weights with the following formula:\n\nw = w - lr * g\n\nwhere w is a weight array, g is the gradient of the loss function w.r.t w and lr is the learning rate.\n\nIf norm(g) > gclip > 0, g is scaled so that its norm is equal to gclip.  If gclip==0 no scaling takes place.\n\nSGD is used by default if no algorithm is specified in the two argument version of update![@ref].\n\n\n\n\n\n","category":"type"},{"location":"reference/#Knet.Train20.Momentum","page":"Reference","title":"Knet.Train20.Momentum","text":"Momentum(;lr=0.05, gclip=0, gamma=0.95)\nupdate!(w,g,p::Momentum)\n\nContainer for parameters of the Momentum optimization algorithm used by update!.\n\nThe Momentum method tries to accelerate SGD by adding a velocity term to the update.  This also decreases the oscillation between successive steps. It updates the weights with the following formulas:\n\nvelocity = gamma * velocity + lr * g\nw = w - velocity\n\nwhere w is a weight array, g is the gradient of the objective function w.r.t w, lr is the learning rate, gamma is the momentum parameter, velocity is an array with the same size and type of w and holds the accelerated gradients.\n\nIf norm(g) > gclip > 0, g is scaled so that its norm is equal to gclip.  If gclip==0 no scaling takes place.\n\nReference: Qian, N. (1999). On the momentum term in gradient descent learning algorithms.  Neural Networks : The Official Journal of the International Neural Network Society, 12(1), 145–151.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Knet.Train20.Nesterov","page":"Reference","title":"Knet.Train20.Nesterov","text":"Nesterov(; lr=0.05, gclip=0, gamma=0.95)\nupdate!(w,g,p::Momentum)\n\nContainer for parameters of Nesterov's momentum optimization algorithm used by update!.\n\nIt is similar to standard Momentum but with a slightly different update rule:\n\nvelocity = gamma * velocity_old - lr * g\nw = w_old - velocity_old + (1+gamma) * velocity\n\nwhere w is a weight array, g is the gradient of the objective function w.r.t w, lr is the learning rate, gamma is the momentum parameter, velocity is an array with the same size and type of w and holds the accelerated gradients.\n\nIf norm(g) > gclip > 0, g is scaled so that its norm is equal to gclip.  If gclip == 0 no scaling takes place.\n\nReference Implementation : Yoshua Bengio, Nicolas Boulanger-Lewandowski and Razvan P ascanu\n\n\n\n\n\n","category":"type"},{"location":"reference/#Knet.Train20.Adagrad","page":"Reference","title":"Knet.Train20.Adagrad","text":"Adagrad(;lr=0.05, gclip=0, eps=1e-6)\nupdate!(w,g,p::Adagrad)\n\nContainer for parameters of the Adagrad optimization algorithm used by update!.\n\nAdagrad is one of the methods that adapts the learning rate to each of the weights.  It stores the sum of the squares of the gradients to scale the learning rate.  The learning rate is adapted for each weight by the value of current gradient divided by the accumulated gradients. Hence, the learning rate is greater for the parameters where the accumulated gradients are small and the learning rate is small if the accumulated gradients are large. It updates the weights with the following formulas:\n\nG = G + g .^ 2\nw = w - g .* lr ./ sqrt(G + eps)\n\nwhere w is the weight, g is the gradient of the objective function w.r.t w, lr is the learning rate, G is an array with the same size and type of w and holds the sum of the squares of the gradients. eps is a small constant to prevent a zero value in the denominator.\n\nIf norm(g) > gclip > 0, g is scaled so that its norm is equal to gclip.  If gclip==0 no scaling takes place.\n\nReference: Duchi, J., Hazan, E., & Singer, Y. (2011). Adaptive Subgradient Methods for Online Learning and Stochastic Optimization. Journal of Machine Learning Research, 12, 2121–2159.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Knet.Train20.Rmsprop","page":"Reference","title":"Knet.Train20.Rmsprop","text":"Rmsprop(;lr=0.01, gclip=0, rho=0.9, eps=1e-6)\nupdate!(w,g,p::Rmsprop)\n\nContainer for parameters of the Rmsprop optimization algorithm used by update!.\n\nRmsprop scales the learning rates by dividing the root mean squared of the gradients. It updates the weights with the following formula:\n\nG = (1-rho) * g .^ 2 + rho * G\nw = w - lr * g ./ sqrt(G + eps)\n\nwhere w is the weight, g is the gradient of the objective function w.r.t w, lr is the learning rate, G is an array with the same size and type of w and holds the sum of the squares of the gradients. eps is a small constant to prevent a zero value in the denominator.  rho is the momentum parameter and delta is an array with the same size and type of w and holds the sum of the squared updates.\n\nIf norm(g) > gclip > 0, g is scaled so that its norm is equal to gclip.  If gclip==0 no scaling takes place.\n\nReference: Tijmen Tieleman and Geoffrey Hinton (2012). \"Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude.\"  COURSERA: Neural Networks for Machine Learning 4.2.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Knet.Train20.Adadelta","page":"Reference","title":"Knet.Train20.Adadelta","text":"Adadelta(;lr=1.0, gclip=0, rho=0.9, eps=1e-6)\nupdate!(w,g,p::Adadelta)\n\nContainer for parameters of the Adadelta optimization algorithm used by update!.\n\nAdadelta is an extension of Adagrad that tries to prevent the decrease of the learning rates to zero as training progresses. It scales the learning rate based on the accumulated gradients like Adagrad and holds the acceleration term like Momentum. It updates the weights with the following formulas:\n\nG = (1-rho) * g .^ 2 + rho * G\nupdate = g .* sqrt(delta + eps) ./ sqrt(G + eps)\nw = w - lr * update\ndelta = rho * delta + (1-rho) * update .^ 2\n\nwhere w is the weight, g is the gradient of the objective function w.r.t w, lr is the learning rate, G is an array with the same size and type of w and holds the sum of the squares of the gradients. eps is a small constant to prevent a zero value in the denominator.  rho is the momentum parameter and delta is an array with the same size and type of w and holds the sum of the squared updates.\n\nIf norm(g) > gclip > 0, g is scaled so that its norm is equal to gclip.  If gclip==0 no scaling takes place.\n\nReference: Zeiler, M. D. (2012). ADADELTA: An Adaptive Learning Rate Method.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Knet.Train20.Adam","page":"Reference","title":"Knet.Train20.Adam","text":"Adam(;lr=0.001, gclip=0, beta1=0.9, beta2=0.999, eps=1e-8)\nupdate!(w,g,p::Adam)\n\nContainer for parameters of the Adam optimization algorithm used by update!.\n\nAdam is one of the methods that compute the adaptive learning rate. It stores accumulated gradients (first moment) and the sum of the squared of gradients (second).  It scales the first and second moment as a function of time. Here is the update formulas:\n\nm = beta1 * m + (1 - beta1) * g\nv = beta2 * v + (1 - beta2) * g .* g\nmhat = m ./ (1 - beta1 ^ t)\nvhat = v ./ (1 - beta2 ^ t)\nw = w - (lr / (sqrt(vhat) + eps)) * mhat\n\nwhere w is the weight, g is the gradient of the objective function w.r.t w, lr is the learning rate, m is an array with the same size and type of w and holds the accumulated gradients. v is an array with the same size and type of w and holds the sum of the squares of the gradients. eps is a small constant to prevent a zero denominator. beta1 and beta2 are the parameters to calculate bias corrected first and second moments. t is the update count.\n\nIf norm(g) > gclip > 0, g is scaled so that its norm is equal to gclip.  If gclip==0 no scaling takes place.\n\nReference: Kingma, D. P., & Ba, J. L. (2015). Adam: a Method for Stochastic Optimization. International Conference on Learning Representations, 1–13.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Function-Index","page":"Reference","title":"Function Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"opt/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"opt/#References","page":"Optimization","title":"References","text":"","category":"section"},{"location":"opt/","page":"Optimization","title":"Optimization","text":"http://videolectures.net/deeplearning2015_goodfellow_network_optimization/   (Ian Goodfellow's tutorial on neural network optimization at Deep   Learning Summer School 2015).\nhttp://int8.io/comparison-of-optimization-techniques-stochastic-gradient-descent-momentum-adagrad-and-adadelta   (implementation and comparison of popular methods)\nhttp://www.deeplearningbook.org/contents/numerical.html (basic   intro in 4.3)\nhttp://www.deeplearningbook.org/contents/optimization.html (8.1   generalization, 8.2 problems, 8.3 algorithms, 8.4 init, 8.5 adaptive   lr, 8.6 approx 2nd order, 8.7 meta)\nhttps://arxiv.org/abs/1412.6544\nhttp://andrew.gibiansky.com/blog/machine-learning/gauss-newton-matrix/   (great posts on optimization)\nhttps://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf   (excellent tutorial on cg, gd, eigens etc)\nhttp://arxiv.org/abs/1412.6544 (Goodfellow paper)\nhttps://d396qusza40orc.cloudfront.net/neuralnets/lecture_slides/lec6.pdf   (hinton slides)\nhttps://d396qusza40orc.cloudfront.net/neuralnets/lecture_slides/lec8.pdf   (hinton slides)\nhttp://www.denizyuret.com/2015/03/alec-radfords-animations-for.html\nhttp://machinelearning.wustl.edu/mlpapers/paper_files/icml2010_Martens10.pdf\nhttp://arxiv.org/abs/1503.05671\nhttp://arxiv.org/abs/1412.1193\nhttp://www.springer.com/us/book/9780387303031 (nocedal and wright)\nhttp://www.nrbook.com (numerical recipes)\nhttps://maths-people.anu.edu.au/~brent/pub/pub011.html (without   derivatives)\nhttp://stanford.edu/~boyd/cvxbook/ (only convex optimization)","category":"page"},{"location":"softmax/#Softmax-Classification","page":"Softmax Classification","title":"Softmax Classification","text":"","category":"section"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"note: Concepts\nclassification, likelihood, softmax, one-hot vectors, zero-one loss, conditional likelihood, MLE, NLL, cross-entropy loss","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"We will introduce classification problems and some simple models for classification.","category":"page"},{"location":"softmax/#Classification","page":"Softmax Classification","title":"Classification","text":"","category":"section"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"Classification problems are supervised machine learning problems where the task is to predict a discrete class for a given input (unlike regression where the output was numeric). A typical example is handwritten digit recognition where the input is an image of a handwritten digit, and the output is one of the discrete categories 0 ldots 9. As in all supervised learning problems the training data consists of a set of example input-output pairs.","category":"page"},{"location":"softmax/#Likelihood","page":"Softmax Classification","title":"Likelihood","text":"","category":"section"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"A natural objective in classification could be to minimize the number of misclassified examples in the training data. This number is known as the zero-one loss. However the zero-one loss has some undesirable properties for training: in particular it is discontinuous. A small change in one of the parameters either has no effect on the loss, or can turn one or more of the predictions from false to true or true to false, causing a discontinuous jump in the objective. This means the gradient of the zero-one loss with respect to the parameters is either undefined or zero, thus not helpful.","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"A more commonly used objective for classification is conditional likelihood: the probability of the observed data given our model and the inputs. Instead of predicting a single class for each instance, we let our model predict a probability distribution over all classes. Then we adjust the weights of the model to increase the probabilities for the correct classes and decrease it for others. This is also known as the maximum likelihood estimation (MLE).","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"Let mathcalX=x_1ldotsx_N be the inputs in the training data, mathcalY=y_1ldotsy_N be the correct classes and theta be the parameters of our model. Conditional likelihood is:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"L(theta) = P(mathcalYmathcalXtheta) \n= prod_n=1^N P(y_nx_ntheta)","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"The second equation assumes that the data instances were generated independently. ","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"We usually work with log likelihood for mathematical convenience: log is a monotonically increasing function, so maximizing likelihood is the same as maximizing log likelihood:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"ell(theta) = log P(mathcalYmathcalXtheta) \n= sum_n=1^N log P(y_nx_ntheta)","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"We will typically use the negative of ell (machine learning people like to minimize), which is known as negative log likelihood (NLL), or cross-entropy loss.","category":"page"},{"location":"softmax/#Softmax","page":"Softmax Classification","title":"Softmax","text":"","category":"section"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"A classification model for a problem with C classes typically generates yinmathbbR^C, a vector of C scores (e.g. we might use multivariate linear regression with a vector output as seen in the last chapter).  In general these scores will be arbitrary real numbers.  To go from arbitrary scores yinmathbbR^C to normalized probability estimates pinmathbbR^C for a single instance, we use exponentiation and normalization:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"p_i = fracexp y_isum_c=1^C exp y_c","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"where icin1ldotsC range over classes, and p_i y_i y_c refer to class probabilities and scores for a single instance. This is called the softmax function. A model that converts the unnormalized values at the end of a linear regression to normalized probabilities for classification is called the softmax classifier.","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"We need to figure out the backward pass for the softmax function. In other words if someone gives us the gradient of some objective J with respect to the class probabilities p for a single training instance, what is the gradient with respect to the input of the softmax y? First we'll find the partial derivative of one component of p with respect to one component of y:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"fracpartial p_ipartial y_j \n= fraci=j exp y_i (sum_c exp y_c) - exp y_i exp y_j(sum_c exp y_c)^2\n= i=j p_i - p_i p_j","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"The square brackets are the Iverson bracket notation, i.e. A is 1 if A is true, and 0 if A is false.","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"Note that a single entry in y effects J through multiple paths (y_j contributes to the denominator of every p_i), and these effects need to be added for partial Jpartial y_j:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"fracpartial Jpartial y_j\n= sum_i=1^C fracpartial Jpartial p_i\nfracpartial p_ipartial y_j","category":"page"},{"location":"softmax/#One-hot-vectors","page":"Softmax Classification","title":"One-hot vectors","text":"","category":"section"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"When using a probabilistic classifier, it is convenient to represent the desired output as a one-hot vector, i.e. a vector in which all entries are '0' except a single '1'. If the correct class is cin1ldotsC, we represent this with a one-hot vector pinmathbbR^C where p_c = 1 and p_ineq c = 0. Note that p can be viewed as a probability vector where all the probability mass is concentrated at class c. This representation also allows us to have probabilistic targets where there is not a single answer but target probabilities associated with each answer. Given a one-hot (or probabilistic) p, and the model prediction hatp, we can write the log-likelihood for a single instance as:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"ell = sum_c=1^C p_c log hatp_c","category":"page"},{"location":"softmax/#Gradient-of-log-likelihood","page":"Softmax Classification","title":"Gradient of log likelihood","text":"","category":"section"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"To compute the gradient for log likelihood, we need to make the normalization of hatp explicit:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"beginaligned\nell = sum_c p_c log frachatp_csum_khatp_k \n= (sum_c p_c loghatp_c) - (sum_c p_c log sum_khatp_k) \n= (sum_c p_c loghatp_c) - (log sum_khatp_k) \nfracpartial ellpartial hatp_i =\nfracp_ihatp_i - frac1sum_khatp_k\n= fracp_ihatp_i - 1\nendaligned","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"The gradient with respect to unnormalized y scores takes a particularly simple form:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"beginaligned\nfracpartialellpartial y_j\n= sum_i fracpartialellpartial hatp_i\nfracpartial hatp_ipartial y_j \n= sum_i (fracp_ihatp_i - 1)(i=j hatp_i - hatp_i hatp_j) \n=  p_j - hatp_j \nnabla_y ell =  p - hatp\nendaligned","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"The gradient with respect to hatp causes numerical overflow when some components of hatp get very small. In practice we usually skip that and directly compute the gradient with respect to y which is numerically stable.","category":"page"},{"location":"softmax/#MNIST-example","page":"Softmax Classification","title":"MNIST example","text":"","category":"section"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"Let's try our softmax classifier on the MNIST handwritten digit classification dataset. Here are the first 8 images from MNIST, the goal is to look at the pixels and classify each image as one of the digits 0-9:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"(Image: image)","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"Load and minibatch the data. dtrn and dtst consist of xy pairs [ (x1,y1), (x2,y2), ... ] where xi,yi are minibatches of 100 instances:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"using Knet\ninclude(Knet.dir(\"data\",\"mnist.jl\"))\nxtrn,ytrn,xtst,ytst = mnist()\ndtst = minibatch(xtst,ytst,100)\ndtrn = minibatch(xtrn,ytrn,100)","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"Here is the softmax classifier in Knet:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"predict(w,x) = w[1]*mat(x) .+ w[2]\t  # mat converts x to 2D\nloss(w,x,ygold) = nll(predict(w,x),ygold) # nll computes negative log likelihood\nlossgradient = grad(loss)                 # grad returns gradient function\nwsoft=[ 0.1*randn(10,784), zeros(10,1) ]  # initial weights and bias","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"Here is the SGD training loop (see the full example in the Knet tutorial):","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"function train!(w, data; lr=.1)\n    for (x,y) in data\n        dw = lossgradient(w, x, y)\n        for i in 1:length(w)\n            w[i] -= lr * dw[i]\n        end\n    end\n    return w\nend","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"Here are the plots of the negative log likelihood and misclassification error vs training epochs:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"(Image: image)","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"We can observe a few things. First the training losses are better than the test losses. This means there is some overfitting, i.e. the model is learning spurious regularities in the training data that do not generalize to test data. Second, it does not look like the training loss is going down to zero. This means there is also underfitting, i.e. the softmax model is not flexible enough to fit the training data exactly.","category":"page"},{"location":"softmax/#Representational-power","page":"Softmax Classification","title":"Representational power","text":"","category":"section"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"So far we have seen how to create a machine learning model as a differentiable program (linear regression, softmax classification) whose parameters can be adjusted to hopefully imitate whatever process generated our training data. A natural question to ask is whether a particular model can behave like any system we want (given the right parameters) or whether there is a limit to what it can represent.","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"It turns out the softmax classifier is quite limited in its representational power: it can only represent linear classification boundaries. To show this, remember the form of the softmax classifier which gives the probability of the i'th class as:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"p_i = fracexp y_isum_c=1^C exp y_c","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"where y_i is a linear function of the input x. Note that p_i is a monotonically increasing function of y_i, so for two classes i and j, p_i  p_j iff y_i  y_j. The boundary between two classes i and j is the set of inputs for which the probability of the two classes are equal:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"beginaligned\np_i = p_j \ny_i = y_j \nw_i x + b_i = w_j x + b_j \n(w_i - w_j) x + (b_i - b_j) = 0\nendaligned","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"where w_i b_i refer to the i'th row of w and b. This is a linear equation, i.e. the border between two classes will always be linear in the input space with the softmax classifier:","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"(Image: image)","category":"page"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"In the MNIST example, the relation between the pixels and the digit classes is unlikely to be this simple. That is why we are stuck at 6-7% training error. To get better results we need more powerful models.","category":"page"},{"location":"softmax/#References","page":"Softmax Classification","title":"References","text":"","category":"section"},{"location":"softmax/","page":"Softmax Classification","title":"Softmax Classification","text":"UFLDL Tutorial, Softmax Regression","category":"page"},{"location":"rl/#Reinforcement-Learning","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"","category":"section"},{"location":"rl/#References","page":"Reinforcement Learning","title":"References","text":"","category":"section"},{"location":"rl/","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html\nhttps://www.youtube.com/watch?v=2pWv7GOvuf0&list=PL7-jPKtc4r78-wCZcQn5IqyuWhBZ8fOxT\nhttp://videolectures.net/rldm2015_silver_reinforcement_learning/?q=david%20silver\nhttps://webdocs.cs.ualberta.ca/~sutton/book/the-book.html\nhttp://web.mit.edu/dimitrib/www/RLbook.html\nhttps://sites.ualberta.ca/~szepesva/RLBook.html\nhttp://banditalgs.com/print/\nhttp://karpathy.github.io/2016/05/31/rl/\nhttp://cs229.stanford.edu/notes/cs229-notes12.pdf\nhttp://cs.stanford.edu/people/karpathy/reinforcejs/index.html\nhttps://www.udacity.com/course/machine-learning-reinforcement-learning–ud820\nhttp://www.nature.com/nature/journal/v518/n7540/full/nature14236.html\nhttp://people.csail.mit.edu/regina/my_papers/TG15.pdf\nIn http://karpathy.github.io/2015/05/21/rnn-effectiveness: For   more about REINFORCE and more generally Reinforcement Learning and   policy gradient methods (which REINFORCE is a special case of) David   Silver's class, or one of Pieter Abbeel's classes. This is very much   ongoing work but these hard attention models have been explored, for   example, in Inferring Algorithmic Patterns with Stack-Augmented   Recurrent Nets, Reinforcement Learning Neural Turing Machines, and   Show Attend and Tell.\nIn http://www.deeplearningbook.org/contents/ml.html: Please see   Sutton and Barto (1998) or Bertsekasand Tsitsiklis (1996) for   information about reinforcement learning, and Mnih et al.(2013) for   the deep learning approach to reinforcement learning.","category":"page"},{"location":"cnn/#Convolutional-Neural-Networks","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"","category":"section"},{"location":"cnn/#Motivation","page":"Convolutional Neural Networks","title":"Motivation","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Let's say we are trying to build a model that will detect cats in photographs. The average resolution of images in ILSVRC is 482x415, with three channels (RGB) this makes the typical input size 482x415x3=600,090. Each hidden unit connected to the input in a multilayer perceptron would have 600K parameters, a single hidden layer of size 1000 would have 600 million parameters. Too many parameters cause three types of problems: (1) runtime: large models are computationally costly to train and run. (2) memory: today's GPUs have limited amount of memory (4G-12G) and large networks fill them up quickly. (3) sample complexity: models with a large number of parameters are difficult to train without overfitting: we need a lot of data, strong regularization, and/or a good initialization to learn with large models.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"One problem with the MLP is that it is fully connected: every hidden unit is connected to every other in adjacent layers. The model does not assume any spatial relationships between pixels, in fact we can permute all the pixels in an image and the performance of the MLP would be the same!  We could instead have an architecture where each hidden unit is connected to a small patch of the image, say 40x40. Each such locally connected hidden unit would have 40x40x3=4800 parameters instead of 600K. For the price (in memory) of one fully connected hidden unit (600K), we could have 125 of these locally connected mini-hidden-units (4800 each) with receptive fields spread around the image.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The second problem with the MLP is that it does not take advantage of the symmetry in the problem: a cat in the lower right corner of the image may be similar to a cat in the upper left corner. This means the local hidden units looking at these two patches can share the same weights. We can take one 40x40 cat filter and apply it to each 40x40 patch in the image taking up only 4800 parameters.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"A convolutional neural network (aka CNN or ConvNet) combines these two ideas and uses operations that are local and that share weights. CNNs commonly use three types of operations: convolution, pooling, and normalization which we describe next.","category":"page"},{"location":"cnn/#Convolution","page":"Convolutional Neural Networks","title":"Convolution","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Convolution is the main operation that provides sparse connectivity and weight sharing.  For simplicity we start describing convolution in 1-D using the conv4 primitive from Knet. We next look at three keyword options that provide variations on the convolution operation: padding, stride, and mode.  We then describe how conv4 handles multiple dimensions, filters, and instances in parallel.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The relationship between convolution and matrix multiplication allows the use of efficient algorithms developed for matrix multiplication in convolution implementations.  The fact that convolution and matrix multiplication can be implemented in terms of each other clarifies the distinction between CNNs and MLPs as one of efficiency, not representative power.  We end this section by describing backpropagation for convolution.","category":"page"},{"location":"cnn/#conv_1d","page":"Convolutional Neural Networks","title":"Convolution in 1-D","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Let w x be two 1-D vectors with W X elements respectively. In our examples, we will assume x is the input (consider it a 1-D image) and w is a filter (aka kernel) with WX. The 1-D convolution operation y=wast x results in a vector with Y=X-W+1 elements defined as:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"y_k equiv sum_i+j=k+W x_i w_j","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"or equivalently","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"y_k equiv sum_i=k^k+W-1 x_i w_k+W-i","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"where iin1X jin1W kin1Y. We get each entry in y by multiplying pairs of matching entries in x and w and summing the results. Matching entries in x and w are the ones whose indices add up to a constant. This can be visualized as flipping w, sliding it over x, and at each step writing their dot product into a single entry in y. Here is an example in Julia you should be able to calculate by hand:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> using Knet\njulia> w = reshape([1.0,2.0,3.0], (3,1,1,1))\n3×1×1×1 Array{Float64,4}: [1,2,3]\njulia> x = reshape([1.0:7.0...], (7,1,1,1))\n7×1×1×1 Array{Float64,4}: [1,2,3,4,5,6,7]\njulia> y = conv4(w, x)\n5×1×1×1 Array{Float64,4}: [10,16,22,28,34]","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"conv4 is the convolution operation in Knet (based on the CUDNN implementation). For reasons that will become clear it works with 4-D and 5-D arrays, so we reshape our 1-D input vectors by adding extra singleton dimensions at the end.  The convolution of w=[1,2,3] and x=[1,2,3,4,5,6,7] gives y=[10,16,22,28,34]. For example, the third element of y, 22, can be obtained by reversing w to [3,2,1] and taking its dot product starting with the third element of x, [3,4,5].","category":"page"},{"location":"cnn/#conv_padding","page":"Convolutional Neural Networks","title":"Padding","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"In the last example, the input x had 7 dimensions, the output y had 5. In image processing applications we typically want to keep x and y the same size. For this purpose we can provide a padding keyword argument to the conv4 operator. If padding=k, x will be assumed padded with k zeros on the left and right before the convolution, e.g. padding=1 means treat x as [0 1 2 3 4 5 6 7 0]. The default padding is 0. For inputs in D-dimensions we can specify padding with a D-tuple, e.g. padding=(1,2) for 2D, or a single number, e.g. padding=1 which is shorthand for padding=(1,1). The result will have Y=X+2P-W+1 elements where P is the padding size. Therefore to preserve the size of x when W=3 we should use padding=1.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> y = conv4(w, x; padding=(1,0))\n7×1×1×1 Array{Float64,4}: [4,10,16,22,28,34,32]","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"For example, to calculate the first entry of y, take the dot product of the inverted w, [3,2,1] with the first three elements of the padded x, [0 1 2]. You can see that in order to preserve the input size, Y=X, given a filter size W, the padding should be set to P=(W-1)2. This will work if W is odd.","category":"page"},{"location":"cnn/#conv_stride","page":"Convolutional Neural Networks","title":"Stride","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"In the preceding examples we shift the inverted w by one position after each dot product. In some cases you may want to skip two or more positions. This will effectively reduce the size of the output.  The amount of skip is set by the stride keyword argument of the conv4 operation (the default stride is 1). In the following example we set stride to W such that the consecutive filter applications are non-overlapping:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> y = conv4(w, x; padding=(1,0), stride=3)\n3×1×1×1 Array{Float64,4}: [4,22,32]","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Note that the output has the first, middle, and last values of the previous example, i.e. every third value is kept and the rest are skipped. In general if stride=S and padding=P, the size of the output will be:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Y = 1 + leftlfloorfracX+2P-WSrightrfloor","category":"page"},{"location":"cnn/#conv_mode","page":"Convolutional Neural Networks","title":"Mode","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The convolution operation we have used so far flips the convolution kernel before multiplying it with the input. To take our first 1-D convolution example with","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"y_1 = x_1 w_W + x_2 w_W-1 + x_3 w_W-2 + ldots \ny_2 = x_2 w_W + x_3 w_W-1 + x_4 w_W-2 + ldots \nldots","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"We could also perform a similar operation without kernel flipping:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"y_1 = x_1 w_1 + x_2 w_2 + x_3 w_3 + ldots \ny_2 = x_2 w_1 + x_3 w_2 + x_4 w_3 + ldots \nldots","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"This variation is called cross-correlation. The two modes are specified in Knet by choosing one of the following as the value of the mode keyword:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"0 for convolution\n1 for cross-correlation","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"This option would be important if we were hand designing our filters. However the mode does not matter for CNNs where the filters are learnt from data, the CNN will simply learn an inverted version of the filter if necessary.","category":"page"},{"location":"cnn/#conv_dims","page":"Convolutional Neural Networks","title":"More Dimensions","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"When the input x has multiple dimensions convolution is defined similarly. In particular the filter w has the same number of dimensions but typically smaller size. The convolution operation flips w in each dimension and slides it over x, calculating the sum of elementwise products at every step. The formulas we have given above relating the output size to the input and filter sizes, padding and stride parameters apply independently for each dimension.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Knet supports 2D and 3D convolutions. The inputs and the filters have two extra dimensions at the end which means we use 4D and 5D arrays for 2D and 3D convolutions. Here is a 2D convolution example:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> w = reshape([1.0:4.0...], (2,2,1,1))\n2×2×1×1 Array{Float64,4}:\n[:, :, 1, 1] =\n 1.0  3.0\n 2.0  4.0\njulia> x = reshape([1.0:9.0...], (3,3,1,1))\n3×3×1×1 Array{Float64,4}:\n[:, :, 1, 1] =\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0\njulia> y = conv4(w, x)\n2×2×1×1 Array{Float64,4}:\n[:, :, 1, 1] =\n 23.0  53.0\n 33.0  63.0","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"To see how this result comes about, note that when you flip w in both dimensions you get:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"4 2\n3 1","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Multiplying this elementwise with the upper left corner of x:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"1 4\n2 5","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"and adding the results gives you the first entry 23.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The padding and stride options work similarly in multiple dimensions and can be specified as tuples: padding=(1,2) means a padding width of 1 along the first dimension and 2 along the second dimension for a 2D convolution. You can use padding=1 as a shorthand for padding=(1,1).","category":"page"},{"location":"cnn/#conv_filters","page":"Convolutional Neural Networks","title":"Multiple filters","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"So far we have been ignoring the extra dimensions at the end of our convolution arrays. Now we are ready to put them to use. A D-dimensional input image is typically represented as a D+1 dimensional array with dimensions:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":" X_1 ldots X_D C_x ","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The first D dimensions X_1ldots X_D determine the spatial extent of the image. The last dimension C_x is the number of channels (aka slices, frames, maps, filters). The definition and number of channels is application dependent. We use C_x=3 for RGB images representing the intensity in three colors: red, green, and blue. For grayscale images we have a single channel, C_x=1. If you were developing a model for chess, we could have C_x=12, each channel representing the locations of a different piece type.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"In an actual CNN we do not typically hand-code the filters. Instead we tell the network: \"here are 1000 randomly initialized filters, you go ahead and turn them into patterns useful for my task.\" This means we usually work with banks of multiple filters simultaneously and GPUs have optimized operations for such filter banks. The dimensions of a typical filter bank are:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":" W_1 ldots W_D C_x C_y ","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The first D dimensions W_1ldots W_D determine the spatial extent of the filters. The next dimension C_x is the number of input channels, i.e. the number of filters from the previous layer, or the number of color channels of the input image. The last dimension C_y is the number of output channels, i.e. the number of filters in this layer.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"If we take an input of size X_1ldots X_DC_x and apply a filter bank of size W_1ldotsW_DC_xC_y using padding P_1ldotsP_D and stride S_1ldotsS_D the resulting array will have dimensions:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":" W_1 ldots W_D C_x C_y  ast  X_1 ldots X_D C_x  \nRightarrow  Y_1 ldots Y_D C_y  \nmathrmwhere  Y_i = 1 + leftlfloorfracX_i+2P_i-W_iS_irightrfloor","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"As an example let's start with an input image of 256x256 pixels and 3 RGB channels. We'll first apply 25 filters of size 5x5 and padding=2, then 50 filters of size 3x3 and padding=1, and finally 75 filters of size 3x3 and padding=1. Here are the dimensions we will get:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":" 256 256 3  ast  5 5 3 25  Rightarrow  256 256 25  \n 256 256 25 ast  3 3 2550  Rightarrow  256 256 50  \n 256 256 50 ast  3 3 5075  Rightarrow  256 256 75 ","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Note that the number of input channels of the input data and the filter bank always match. In other words, a filter covers only a small part of the spatial extent of the input but all of its channel depth.","category":"page"},{"location":"cnn/#conv_instances","page":"Convolutional Neural Networks","title":"Multiple instances","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"In addition to processing multiple filters in parallel, we implement CNNs with minibatching, i.e. process multiple inputs in parallel to fully utilize GPUs. A minibatch of D-dimensional images is represented as a D+2 dimensional array:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":" X_1 ldots X_D C_x N ","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"where C_x is the number of channels as before, and N is the number of images in a minibatch. The convolution implementation in Knet/CUDNN use D+2 dimensional arrays for both images and filters. We used 1 for the extra dimensions in our first examples, in effect using a single channel and a single image minibatch.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"If we apply a filter bank of size W_1 ldots W_D C_x C_y to the minibatch given above the output size would be:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":" W_1 ldots W_D C_x C_y  ast  X_1 ldots X_D C_x N  \nRightarrow  Y_1 ldots Y_D C_y N  \nmathrmwhere  Y_i = 1 + leftlfloorfracX_i+2P_i-W_iS_irightrfloor","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"If we used a minibatch size of 128 in the previous example with 256x256 images, the sizes would be:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":" 256 256 3 128  ast  5 5 3 25  Rightarrow  256 256 25 128  \n 256 256 25 128 ast  3 3 2550  Rightarrow  256 256 50 128  \n 256 256 50 128 ast  3 3 5075  Rightarrow  256 256 75 128 ","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"basically adding an extra dimension of 128 at the end of each data array.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"By the way, the arrays in this particular example already exceed 5GB of storage, so you would want to use a smaller minibatch size if you had a K20 GPU with 4GB of RAM.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Note: All the dimensions given above are for column-major languages like Julia. CUDNN uses row-major notation, so all the dimensions would be reversed, e.g. NC_xX_DldotsX_1.","category":"page"},{"location":"cnn/#conv_matmul","page":"Convolutional Neural Networks","title":"Convolution vs matrix multiplication","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Convolution can be turned into a matrix multiplication, where certain entries in the matrix are constrained to be the same. The motivation is to be able to use efficient algorithms for matrix multiplication in order to perform convolution. The drawback is the large amount of memory needed due to repeated entries or sparse representations.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Here is a matrix implementation for our first convolution example w=1ldots 3x=1ldots 7wast x = 1016222834:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"(Image: image)","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"In this example we repeated the entries of the filter on multiple rows of a sparse matrix with shifted positions. Alternatively we can repeat the entries of the input to place each local patch on a separate column of an input matrix:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"(Image: image)","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The first approach turns w into a Ytimes X sparse matrix, wheras the second turns x into a Wtimes Y dense matrix.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"For 2-D images, typically the second approach is used: the local patches of the image used by convolution are stretched out to columns of an input matrix, an operation commonly called im2col. Each convolutional filter is stretched out to rows of a filter matrix. After the matrix multiplication the resulting array is reshaped into the proper output dimensions. The following figure illustrates these operations on a small example:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"(Image: image)","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"It is also possible to go in the other direction, i.e. implement matrix multiplication (i.e. a fully connected layer) in terms of convolution. This conversion is useful when we want to build a network that can be applied to inputs of different sizes: the matrix multiplication would fail, but the convolution will give us outputs of matching sizes. Consider a fully connected layer with a weight matrix W of size Ktimes D mapping a D-dimensional input vector x to a K-dimensional output vector y. We can consider each of the K rows of the W matrix a convolution filter. The following example shows how we can reshape the arrays and use convolution for matrix multiplication:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> using Knet\njulia> x = reshape([1.0:3.0...], (3,1))\n3×1 Array{Float64,2}:\n 1.0\n 2.0\n 3.0\njulia> w = reshape([1.0:6.0...], (2,3))\n2×3 Array{Float64,2}:\n 1.0  3.0  5.0\n 2.0  4.0  6.0\njulia> y = w * x\n2×1 Array{Float64,2}:\n 22.0\n 28.0\njulia> x2 = reshape(x, (3,1,1,1))\n3×1×1×1 Array{Float64,4}:\n[:, :, 1, 1] =\n 1.0\n 2.0\n 3.0\njulia> w2 = reshape(Array(w)', (3,1,1,2))\n3×1×1×2 Array{Float64,4}:\n[:, :, 1, 1] =\n 1.0\n 3.0\n 5.0\n[:, :, 1, 2] =\n 2.0\n 4.0\n 6.0\njulia> y2 = conv4(w2, x2; mode=1)\n1×1×2×1 Array{Float64,4}:\n[:, :, 1, 1] =\n 22.0\n[:, :, 2, 1] =\n 28.0","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"In addition to computational concerns, these examples also show that a fully connected layer can emulate a convolutional layer given the right weights and vice versa, i.e. convolution does not get us any extra representational power. However it does get us representational and statistical efficiency, i.e. the functions we would like to approximate are often expressed with significantly fewer parameters using convolutional layers and thus require fewer examples to train.","category":"page"},{"location":"cnn/#conv_backprop","page":"Convolutional Neural Networks","title":"Backpropagation","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Convolution is a linear operation consisting of additions and multiplications, so its backward pass is not very complicated except for the indexing. Just like the backward pass for matrix multiplication can be expressed as another matrix multiplication, the backward pass for convolution (at least if we use stride=1) can be expressed as another convolution. We will derive the backward pass for a 1-D example using the cross-correlation mode (no kernel flipping) to keep things simple. We will denote the cross-correlation operation with star to distinguish it from convolution denoted with ast. Here are the individual entries of y=wstar x:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"y_1 = x_1 w_1 + x_2 w_2 + x_3 w_3 + ldots \ny_2 = x_2 w_1 + x_3 w_2 + x_4 w_3 + ldots \ny_3 = x_3 w_1 + x_4 w_2 + x_5 w_3 + ldots \nldots","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"As you can see, because of weight sharing the same w entry is used in computing multiple y entries. This means a single w entry effects the objective function through multiple paths and these effects need to be added. Denoting partial Jpartial y_i as y_i for brevity we have:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"w_1 = x_1 y_1 + x_2 y_2 + ldots \nw_2 = x_2 y_1 + x_3 y_2 + ldots \nw_3 = x_3 y_1 + x_4 y_2 + ldots \nldots ","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"which can be recognized as another cross-correlation operation, this time between x and y. This allows us to write w=ystar x.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Alternatively, we can use the equivalent matrix multiplication operation from the last section to derive the backward pass:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"(Image: image)","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"If r is the matrix with repeated x entries in this picture, we have y=wr. Remember that the backward pass for matrix multiplication y=wr is w=yr^T:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"(Image: image)","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"which can be recognized as the matrix multiplication equivalent of the cross correlation operation w=ystar x.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Here is the gradient for the input:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"beginaligned\n x_1 = w_1 y_1 \n x_2 = w_2 y_1 + w_1 y_2 \n x_3 = w_3 y_1 + w_2 y_2 + w_1 y_3 \n ldots\nendaligned","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"You can recognize this as a regular convolution between w and y with some zero padding.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The following resources provide more detailed derivations of the backward pass for convolution:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Goodfellow, I.   (2010).   Technical report: Multidimensional, downsampled convolution for   autoencoders. Technical report, Université de Montréal. 312.\nBouvrie, J.   (2006).   Notes on convolutional neural networks.\nUFLDL   tutorial   and   exercise   on CNNs.","category":"page"},{"location":"cnn/#Pooling","page":"Convolutional Neural Networks","title":"Pooling","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"It is common practice to use pooling (aka subsampling) layers in between convolution operations in CNNs. Pooling looks at small windows of the input, and computes a single summary statistic, e.g. maximum or average, for each window. A pooling layer basically says: tell me whether this feature exists in a certain region of the image, I don't care exactly where. This makes the output of the layer invariant to small translations of the input. Pooling layers use large strides, typically as large as the window size, which reduces the size of their output.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Like convolution, pooling slides a small window of a given size over the input optionally padded with zeros skipping stride pixels every step. In Knet by default there is no padding, the window size is 2, stride is equal to the window size and the pooling operation is max. These default settings reduce each dimension of the input to half the size.","category":"page"},{"location":"cnn/#pool_1d","page":"Convolutional Neural Networks","title":"Pooling in 1-D","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Here is a 1-D example:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> x = reshape([1.0:6.0...], (6,1,1,1))\n6×1×1×1 Array{Float64,4}: [1,2,3,4,5,6]\njulia> pool(x)\n3×1×1×1 Array{Float64,4}: [2,4,6]","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"With window size and stride equal to 2, pooling considers the input windows 12 34 56 and picks the maximum in each window.","category":"page"},{"location":"cnn/#pool_window","page":"Convolutional Neural Networks","title":"Window","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The default and most commonly used window size is 2, however other window sizes can be specified using the window keyword. For D-dimensional inputs the size can be specified using a D-tuple, e.g. window=(2,3) for 2-D, or a single number, e.g. window=3 which is shorthand for window=(3,3) in 2-D. Here is an example using a window size of 3 instead of the default 2:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> x = reshape([1.0:6.0...], (6,1,1,1))\n6×1×1×1 Array{Float64,4}: [1,2,3,4,5,6]\njulia> pool(x; window=3)\n2×1×1×1 Array{Float64,4}: [3, 6]","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"With a window and stride of 3 (the stride is equal to window size by default), pooling considers the input windows 123456, and writes the maximum of each window to the output. If the input size is X, and stride is equal to the window size W, the output will have Y=lfloor XWrfloor elements.","category":"page"},{"location":"cnn/#pool_padding","page":"Convolutional Neural Networks","title":"Padding","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The amount of zero padding is specified using the padding keyword argument just like convolution. Padding is 0 by default. For D-dimensional inputs padding can be specified as a tuple such as padding=(1,2), or a single number padding=1 which is shorthand for padding=(1,1) in 2-D. Here is a 1-D example:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> x = reshape([1.0:6.0...], (6,1,1,1))\n6×1×1×1 Array{Float64,4}: [1,2,3,4,5,6]\n\njulia> pool(x; padding=(1,0))\n4×1×1×1 Array{Float64,4}: [1,3,5,6]","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"In this example, window=stride=2 by default and the padding size is 1, so the input is treated as 01234560 and split into windows of 01234560 and the maximum of each window is written to the output.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"With padding size P, if the input size is X, and stride is equal to the window size W, the output will have Y=lfloor (X+2P)Wrfloor elements.","category":"page"},{"location":"cnn/#pool_stride","page":"Convolutional Neural Networks","title":"Stride","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The pooling stride is equal to the window size by default (as opposed to the convolution case, where it is 1 by default). This is most common in practice but other strides can be specified using tuples e.g. stride=(1,2) or numbers e.g. stride=1. Here is a 1-D example with a stride of 4 instead of the default 2:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> x = reshape([1.0:10.0...], (10,1,1,1))\n10×1×1×1 Array{Float64,4}: [1,2,3,4,5,6,7,8,9,10]\n\njulia> pool(x; stride=4)\n4×1×1×1 Array{Float64,4}: [2, 6, 10]","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"In general, when we have an input of size X and pool with window size W, padding P, and stride S, the size of the output will be:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Y = 1 + leftlfloorfracX+2P-WSrightrfloor","category":"page"},{"location":"cnn/#pool_mode","page":"Convolutional Neural Networks","title":"Mode","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"There are three pooling operations defined by CUDNN used for summarizing each window:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"CUDNN_POOLING_MAX\nCUDNN_POOLING_AVERAGE_COUNT_INCLUDE_PADDING\nCUDNN_POOLING_AVERAGE_COUNT_EXCLUDE_PADDING","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"These options can be specified as the value of the mode keyword argument to the pool operation. The default is 0 (max pooling) which we have been using so far. The last two compute averages, and differ in whether to include or exclude the padding zeros in these averages. mode should be 1 for averaging including padding, and 2 for averaging excluding padding. For example, with input x=123456, window=stride=2, and padding=1 we have the following outputs with the three options:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"mode=0 => [1,3,5,6]\nmode=1 => [0.5, 2.5, 4.5, 3.0]\nmode=2 => [1.0, 2.5, 4.5, 6.0]","category":"page"},{"location":"cnn/#pool_dims","page":"Convolutional Neural Networks","title":"More Dimensions","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"D-dimensional inputs are pooled with D-dimensional windows, the size of each output dimension given by the 1-D formulas above. Here is a 2-D example with default options, i.e. window=stride=(2,2), padding=(0,0), mode=max:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> x = reshape([1.0:16.0...], (4,4,1,1))\n4×4×1×1 Array{Float64,4}:\n[:, :, 1, 1] =\n 1.0  5.0   9.0  13.0\n 2.0  6.0  10.0  14.0\n 3.0  7.0  11.0  15.0\n 4.0  8.0  12.0  16.0\n\njulia> pool(x)\n2×2×1×1 Array{Float64,4}:\n[:, :, 1, 1] =\n 6.0  14.0\n 8.0  16.0","category":"page"},{"location":"cnn/#pool_instances","page":"Convolutional Neural Networks","title":"Multiple channels and instances","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"As we saw in convolution, each data array has two extra dimensions in addition to the spatial dimensions:  X_1 ldots X_D C_x N  where C_x is the number of channels and N is the number of instances in a minibatch.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"When the number of channels is greater than 1, the pooling operation is performed independently on each channel, e.g. for each patch, the maximum/average in each channel is computed independently and copied to the output. Here is an example with two channels:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> x = rand(4,4,2,1)\n4×4×2×1 Array{Float64,4}:\n[:, :, 1, 1] =\n 0.880221  0.738729  0.317231   0.990521\n 0.626842  0.562692  0.339969   0.92469\n 0.416676  0.403625  0.352799   0.46624\n 0.566254  0.634703  0.0632812  0.0857779\n\n[:, :, 2, 1] =\n 0.300799  0.407623   0.26275   0.767884\n 0.217025  0.0055375  0.623168  0.957374\n 0.154975  0.246693   0.769524  0.628197\n 0.259161  0.648074   0.333324  0.46305\n\njulia> pool(x)\n2×2×2×1 Array{Float64,4}:\n[:, :, 1, 1] =\n 0.880221  0.990521\n 0.634703  0.46624\n\n[:, :, 2, 1] =\n 0.407623  0.957374\n 0.648074  0.769524","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"When the number of instances is greater than 1, i.e. we are using minibatches, the pooling operation similarly runs in parallel on all the instances:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"julia> x = rand(4,4,1,2)\n4×4×1×2 Array{Float64,4}:\n[:, :, 1, 1] =\n 0.155228  0.848345  0.629651  0.262436\n 0.729994  0.320431  0.466628  0.0293943\n 0.374592  0.662795  0.819015  0.974298\n 0.421283  0.83866   0.385306  0.36081\n\n[:, :, 1, 2] =\n 0.0562608  0.598084  0.0231604  0.232413\n 0.71073    0.411324  0.28688    0.287947\n 0.997445   0.618981  0.471971   0.684064\n 0.902232   0.570232  0.190876   0.339076\n\njulia> pool(x)\n2×2×1×2 Array{Float64,4}:\n[:, :, 1, 1] =\n 0.848345  0.629651\n 0.83866   0.974298\n\n[:, :, 1, 2] =\n 0.71073   0.287947\n 0.997445  0.684064","category":"page"},{"location":"cnn/#Normalization","page":"Convolutional Neural Networks","title":"Normalization","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Draft...","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Karpathy says: \"Many types of normalization layers have been proposed for use in ConvNet architectures, sometimes with the intentions of implementing inhibition schemes observed in the biological brain. However, these layers have recently fallen out of favor because in practice their contribution has been shown to be minimal, if any.\" (http://cs231n.github.io/convolutional-networks/#norm) Batch normalization may be an exception, as it is used in modern architectures.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Here are some references for normalization operations:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Implementations:","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Alex Krizhevsky's cuda-convnet library API.   (https://code.google.com/archive/p/cuda-convnet/wikis/LayerParams.wiki#Localresponsenormalizationlayer(same_map))\nhttp://caffe.berkeleyvision.org/tutorial/layers.html\nhttp://lasagne.readthedocs.org/en/latest/modules/layers/normalization.html","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Divisive normalisation (DivN):","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"S. Lyu and E. Simoncelli. Nonlinear image representation using   divisive normalization. In CVPR, pages 1–8, 2008.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Local contrast normalization (LCN):","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"N. Pinto, D. D. Cox, and J. J. DiCarlo. Why is real-world visual   object recognition hard? PLoS Computational Biology, 4(1), 2008.\nJarrett, Kevin, et al. \"What is the best multi-stage architecture   for object recognition?.\" Computer Vision, 2009 IEEE 12th   International Conference on. IEEE, 2009.   (http://yann.lecun.com/exdb/publis/pdf/jarrett-iccv-09.pdf)","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Local response normalization (LRN):","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E. Hinton. \"Imagenet   classification with deep convolutional neural networks.\" Advances in   neural information processing systems. 2012.   (http://machinelearning.wustl.edu/mlpapers/paperfiles/NIPS20120534.pdf)","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Batch Normalization: This is more of an optimization topic.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Ioffe, Sergey, and Christian Szegedy. \"Batch normalization:   Accelerating deep network training by reducing internal covariate   shift.\" arXiv preprint arXiv:1502.03167 (2015).   (http://arxiv.org/abs/1502.03167/)","category":"page"},{"location":"cnn/#Architectures","page":"Convolutional Neural Networks","title":"Architectures","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"We have seen a number of new operations: convolution, pooling, filters etc. How to best put these together to form a CNN is still an active area of research. In this section we summarize common patterns of usage in recent work based on (Karpathy, 2016).","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"The operations in convolutional networks are usually ordered into   several layers of convolution-bias-activation-pooling sequences.   Note that the convolution-bias-activation sequence is an efficient   way to implement the common neural net function f(wx+b) for a   locally connected and weight sharing hidden layer.\nThe convolutional layers are typically followed by a number of fully   connected layers that end with a softmax layer for prediction (if we   are training for a classification problem).\nIt is preferrable to have multiple convolution layers with small   filter sizes rather than a single layer with a large filter size.   Consider three convolutional layers with a filter size of   3x3. The units in the top layer have receptive fields of   size 7x7. Compare this with a single layer with a filter   size of 7x7. The three layer architecture has two   advantages: The units in the single layer network is restricted to   linear decision boundaries, whereas the three layer network can be   more expressive. Second, if we assume C channels, the parameter   tensor for the single layer network has size 77CC whereas the   three layer network has three tensors of size 33CC i.e. a   smaller number of parameters. The one disadvantage of the three   layer network is the extra storage required to store the   intermediate results for backpropagation.\nThus common settings for convolution use 3x3 filters with   stride = padding = 1 (which incidentally preserves the input   size). The one exception may be a larger filter size used in the   first layer which is applied to the image pixels. This will save   memory when the input is at its largest, and linear functions may be   sufficient to express the low level features at this stage.\nThe pooling operation may not be present in every layer. Keep in   mind that pooling destroys information and having several   convolutional layers without pooling may allow more complex features   to be learnt. When pooling is present it is best to keep the window   size small to minimize information loss. The common settings for   pooling are window = stride = 2, padding = 0, which halves the   input size in each dimension.","category":"page"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Beyond these general guidelines, you should look at the architectures used by successful models in the literature. Some examples are LeNet (LeCun et al. 1998), AlexNet (Krizhevsky et al. 2012), ZFNet (Zeiler and Fergus, 2013), GoogLeNet (Szegedy et al. 2014), VGGNet (Simonyan and Zisserman, 2014), and ResNet (He et al. 2015).","category":"page"},{"location":"cnn/#Exercises","page":"Convolutional Neural Networks","title":"Exercises","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Design a filter that shifts a given image one pixel to right.\nDesign an image filter that has 0 output in regions of uniform   color, but nonzero output at edges where the color changes.\nIf your input consisted of two consecutive frames of video, how   would you detect motion using convolution?\nCan you implement matrix-vector multiplication in terms of   convolution? How about matrix-matrix multiplication? Do you need   reshape operations?\nCan you implement convolution in terms of matrix multiplication?\nCan you implement elementwise broadcasting multiplication in terms   of convolution?","category":"page"},{"location":"cnn/#References","page":"Convolutional Neural Networks","title":"References","text":"","category":"section"},{"location":"cnn/","page":"Convolutional Neural Networks","title":"Convolutional Neural Networks","text":"Some of this chapter was based on the excellent lecture notes from:   http://cs231n.github.io/convolutional-networks\nChristopher Olah's blog has very good visual explanations (thanks to   Melike Softa for the reference):   http://colah.github.io/posts/2014-07-Conv-Nets-Modular\nhttp://yosinski.com/deepvis\nhttps://distill.pub/2017/feature-visualization/\nhttps://distill.pub/2018/building-blocks/\nUFLDL (or its old   version)   is an online tutorial with programming examples and explicit   gradient derivations covering   convolution,   pooling,   and   CNNs.\nHinton's video lecture and presentation at Coursera (Lec 5):   https://d396qusza40orc.cloudfront.net/neuralnets/lecture_slides/lec5.pdf\nFor a derivation of gradients see:   http://people.csail.mit.edu/jvb/papers/cnn_tutorial.pdf or   http://www.iro.umontreal.ca/~lisa/pointeurs/convolution.pdf\nThe CUDNN manual has more details about the convolution API:   https://developer.nvidia.com/cudnn\nhttp://deeplearning.net/tutorial/lenet.html\nhttp://www.denizyuret.com/2014/04/on-emergence-of-visual-cortex-receptive.html\nhttp://neuralnetworksanddeeplearning.com/chap6.html\nhttp://www.deeplearningbook.org/contents/convnets.html\nhttp://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp\nhttp://scs.ryerson.ca/~aharley/vis/conv/ has a nice visualization   of an MNIST CNN. (Thanks to Fatih Ozhamaratli for the reference).\nhttp://josephpcohen.com/w/visualizing-cnn-architectures-side-by-side-with-mxnet   visualizing popular CNN architectures side by side with mxnet.\nhttp://cs231n.github.io/understanding-cnn visualizing what   convnets learn.\nhttps://arxiv.org/abs/1603.07285 A guide to convolution arithmetic   for deep learning\nReading (architectures): cs231n Architecture Slides\nReading (visualization): cs231n Visualization Slides, cs231n Visualization Notes, Distillpub visualization article, Yosinski blog, video, paper, repo\nA Simple Guide to the Versions of the Inception Network","category":"page"},{"location":"gen/#Generalization","page":"Generalization","title":"Generalization","text":"","category":"section"},{"location":"gen/#References","page":"Generalization","title":"References","text":"","category":"section"},{"location":"gen/","page":"Generalization","title":"Generalization","text":"http://www.deeplearningbook.org/contents/regularization.html\nhttps://d396qusza40orc.cloudfront.net/neuralnets/lecture_slides/lec9.pdf\nhttps://d396qusza40orc.cloudfront.net/neuralnets/lecture_slides/lec10.pdf\nhttp://blog.cambridgecoding.com/2016/03/24/misleading-modelling-overfitting-cross-validation-and-the-bias-variance-trade-off/","category":"page"},{"location":"#Welcome-to-Knet.jl's-documentation!","page":"Home","title":"Welcome to Knet.jl's documentation!","text":"","category":"section"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n \"install.md\",\n \"tutorial.md\",\n \"examples.md\",\n \"reference.md\",\n]","category":"page"},{"location":"#Textbook","page":"Home","title":"Textbook","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n \"backprop.md\",\n \"softmax.md\",\n \"mlp.md\",\n \"cnn.md\",\n \"rnn.md\",\n \"rl.md\",\n \"opt.md\",\n \"gen.md\",\n]\nDepth = 1","category":"page"},{"location":"tutorial/#Introduction-to-Knet","page":"Introduction to Knet","title":"Introduction to Knet","text":"","category":"section"},{"location":"tutorial/#Summary","page":"Introduction to Knet","title":"Summary","text":"","category":"section"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Knet (pronounced \"kay-net\") is the Koç University deep learning framework implemented in Julia by Deniz Yuret and collaborators.  It supports GPU operation and automatic differentiation using dynamic computational graphs for models defined in plain Julia. You can install Knet with the following at the julia prompt: using Pkg; Pkg.add(\"Knet\"). Some useful links:","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Tutorial:  introduces Julia and Knet via examples.\nDocumentation: installation, introduction, design, implementation, full reference and deep learning chapters.\nExamples: more tutorials and example models.\nBenchmarks: comparison of Knet's speed with TensorFlow, PyTorch, DyNet etc.\nPaper: Yuret, D. \"Knet: beginning deep learning with 100 lines of julia.\" In Machine Learning Systems Workshop at NIPS 2016.\nKnetML: github organization with Knet repos of models, tutorials, layer collections and other resources.\nImages: Knet machine images are available for AWS, Singularity and Docker.\nIssues: if you find a bug, please open a github issue.\nknet-users: if you need help or would like to request a feature, please join this mailing list.\nknet-dev: if you would like to contribute to Knet development, please join this mailing list and check out these tips.\nknet-slack: Slack channel for Knet.\nRelated work: Please check out Flux, Mocha, JuliaML, JuliaDiff, JuliaGPU, JuliaOpt for related packages.","category":"page"},{"location":"tutorial/#Philosophy","page":"Introduction to Knet","title":"Philosophy","text":"","category":"section"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Knet uses dynamic computational graphs generated at runtime for automatic differentiation of (almost) any Julia code.  This allows machine learning models to be implemented by defining just the forward calculation (i.e. the computation from parameters and data to loss) using the full power and expressivity of Julia. The implementation can use helper functions, loops, conditionals, recursion, closures, tuples and dictionaries, array indexing, concatenation and other high level language features, some of which are often missing in the restricted modeling languages of static computational graph systems like Theano, Torch, Caffe and Tensorflow.  GPU operation is supported by simply using the KnetArray type instead of regular Array for parameters and data.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Knet builds a dynamic computational graph by recording primitive operations during forward calculation.  Only pointers to inputs and outputs are recorded for efficiency.  Therefore array overwriting is not supported during forward and backward passes.  This encourages a clean functional programming style.  High performance is achieved using custom memory management and efficient GPU kernels.  See Under the hood for more details.","category":"page"},{"location":"tutorial/#Tutorial","page":"Introduction to Knet","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"The Knet tutorial consists of Jupyter notebooks that introduce the programming language Julia and the Knet deep learning framework. By the end, the reader should be able to define, train, evaluate, and visualize basic MLP, CNN, and RNN models.  Each notebook is written to work stand-alone but they rely on concepts introduced in earlier notebooks, so I recommend reading them in order. Every Knet function outside of the standard Julia library is defined or explained before use. You can view the notebooks using the following links, or interact with them using a Jupyter server. Instructions for running a server locally or in the cloud can be found in the tutorial README.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Julia is fast: comparison of Julia's speed to C, Python and numpy.\nGetting to know Julia: basic Julia tutorial from JuliaBox.\nQuick start: if you are familiar with other deep learning frameworks and want to see a quick Julia example.\nThe MNIST dataset: introduction to the MNIST handwritten digit recognition dataset.\nJulia iterators: iterators are useful for generating and training with data.\nCreating a model: define, train, visualize simple linear models, introduce gradients, SGD, using the GPU.\nMultilayer perceptrons: multi layer perceptrons, nonlinearities, model capacity, overfitting, regularization, dropout.\nConvolutional networks: convolutional neural networks, sparse and shared weights using conv4 and pool operations.\nRecurrent networks: introduction to recurrent neural networks.\nIMDB sentiment analysis: a simple RNN sequence classification model for sentiment analysis of IMDB movie reviews.\nLanguage modeling: a character based RNN language model that can write Shakespeare sonnets and Julia programs.\nSequence to sequence: a sequence to sequence RNN model typically used for machine translation.","category":"page"},{"location":"tutorial/#Benchmarks","page":"Introduction to Knet","title":"Benchmarks","text":"","category":"section"},{"location":"tutorial/#Knet-Benchmarks-(Sep-30,-2016)","page":"Introduction to Knet","title":"Knet Benchmarks (Sep 30, 2016)","text":"","category":"section"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Each of the examples above was used as a benchmark to compare Knet with other frameworks. The table below shows the number of seconds it takes to train a given model for a particular dataset, number of epochs and minibatch size for Knet, Theano, Torch, Caffe and TensorFlow. Knet had comparable performance to other commonly used frameworks.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"model dataset epochs batch Knet Theano Torch Caffe TFlow\nLinReg Housing 10K 506 2.84 1.88 2.66 2.35 5.92\nSoftmax MNIST 10 100 2.35 1.40 2.88 2.45 5.57\nMLP MNIST 10 100 3.68 2.31 4.03 3.69 6.94\nLeNet MNIST 1 100 3.59 3.03 1.69 3.54 8.77\nCharLM Hiawatha 1 128 2.25 2.42 2.23 1.43 2.86","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"The benchmarking was done on g2.2xlarge GPU instances on Amazon AWS. The code is available at github and as machine image deep_AMI_v6 at AWS N.California. See the section on Using Amazon AWS for more information. The datasets are available online using the following links: Housing, MNIST, Hiawatha. The MLP uses a single hidden layer of 64 units. CharLM uses a single layer LSTM language model with embedding and hidden layer sizes set to 256 and trained using BPTT with a sequence length of 100. Each dataset was minibatched and transferred to GPU prior to benchmarking when possible.","category":"page"},{"location":"tutorial/#DyNet-Benchmarks-(Dec-15,-2017)","page":"Introduction to Knet","title":"DyNet Benchmarks (Dec 15, 2017)","text":"","category":"section"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"We implemented dynamic neural network examples from the dynet-benchmark repo to compare Knet with DyNet and Chainer. See DyNet technical report for the architectural details of the implemented examples and the github repo for the source code.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"rnnlm-batch: A recurrent neural network language model on PTB corpus.\nbilstm-tagger: A bidirectional LSTM network that predicts a tag for each word. It is trained on WikiNER dataset.\nbilstm-tagger-withchar: Similar to bilstm-tagger, but uses characer-based embeddings for unknown words.\ntreenn: A tree-structured LSTM sentiment classifier trained on Stanford Sentiment Treebank dataset.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Benchmarks were run on a server with Intel(R) Xeon(R) CPU E5-2695 v4 @ 2.10GHz and Tesla K80.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Model Metric Knet DyNet Chainer\nrnnlm-batch words/sec 28.5k 18.7k 16k\nbilstm-tagger words/sec 6800 1200 157\nbilstm-tagger-withchar words/sec 1300 900 128\ntreenn sents/sec 43 68 10","category":"page"},{"location":"tutorial/#DeepLearningFrameworks-(Nov-24,-2017)","page":"Introduction to Knet","title":"DeepLearningFrameworks (Nov 24, 2017)","text":"","category":"section"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"More recently, @ilkarman has published CNN and RNN benchmarks on Nvidia K80 GPUs, using the Microsoft Azure Data Science Virtual Machine for Linux (Ubuntu). The results are copied below.  You can find versions of the Knet notebooks used for these benchmarks in the Knet/examples/DeepLearningFrameworks directory.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Training CNN (VGG-style) on CIFAR-10 - Image Recognition","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"DL Library Test Accuracy (%) Training Time (s)\nMXNet 77 145\nCaffe2 79 148\nGluon 76 152\nKnet(Julia) 78 159\nChainer 79 162\nCNTK 78 163\nPyTorch 78 169\nTensorflow 78 173\nKeras(CNTK) 77 194\nKeras(TF) 77 241\nLasagne(Theano) 77 253\nKeras(Theano) 78 269","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Training RNN (GRU) on IMDB - Natural Language Processing (Sentiment Analysis)","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"DL Library Test Accuracy (%) Training Time (s) Using CuDNN?\nMXNet 86 29 Yes\nKnet(Julia) 85 29 Yes\nTensorflow 86 30 Yes\nPytorch 86 31 Yes\nCNTK 85 32 Yes\nKeras(TF) 86 35 Yes\nKeras(CNTK) 86 86 N/A","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Inference ResNet-50 (Feature Extraction)","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"DL Library Images/s GPU Images/s CPU\nKnet(Julia) 160 2\nTensorflow 155 11\nPyTorch 130 6\nMXNet 130 8\nMXNet(w/mkl) 129 25\nCNTK 117 8\nChainer 107 3\nKeras(TF) 98 5\nCaffe2 71 6\nKeras(CNTK) 46 4","category":"page"},{"location":"tutorial/#Under-the-hood","page":"Introduction to Knet","title":"Under the hood","text":"","category":"section"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Knet relies on the AutoGrad package and the KnetArray data type for its functionality and performance. AutoGrad computes the gradient of Julia functions and KnetArray implements high performance GPU arrays with custom memory management. This section briefly describes them.","category":"page"},{"location":"tutorial/#KnetArrays","page":"Introduction to Knet","title":"KnetArrays","text":"","category":"section"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"GPUs have become indispensable for training large deep learning models.  Even the small examples implemented here run up to 17x faster on the GPU compared to the 8 core CPU architecture we use for benchmarking. However GPU implementations have a few potential pitfalls: (i) GPU memory allocation is slow, (ii) GPU-RAM memory transfer is slow, (iii) reduction operations (like sum) can be very slow unless implemented properly (See Optimizing Parallel Reduction in CUDA).","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Knet implements KnetArray as a Julia data type that wraps GPU array pointers. KnetArray is based on the more standard CudaArray with a few important differences: (i) KnetArrays have a custom memory manager, similar to ArrayFire, which reuse pointers garbage collected by Julia to reduce the number of GPU memory allocations, (ii) contiguous array ranges (e.g. a[:,3:5]) are handled as views with shared pointers instead of copies when possible, and (iii) a number of custom CUDA kernels written for KnetArrays implement element-wise, broadcasting, and scalar and vector reduction operations efficiently. As a result Knet allows users to implement their models using high-level code, yet be competitive in performance with other frameworks as demonstrated in the benchmarks section. Other GPU related Julia packages can be found in JuliaGPU.","category":"page"},{"location":"tutorial/#AutoGrad","page":"Introduction to Knet","title":"AutoGrad","text":"","category":"section"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"As we have seen, many common machine learning models can be expressed as differentiable programs that input parameters and data and output a scalar loss value. The loss value measures how close the model predictions are to desired values with the given parameters. Training a model can then be seen as an optimization problem: find the parameters that minimize the loss. Typically, a gradient based optimization algorithm is used for computational efficiency: the direction in the parameter space in which the loss reduction is maximum is given by the negative gradient of the loss with respect to the parameters. Thus gradient computations take a central stage in software frameworks for machine learning. In this section I will briefly outline existing gradient computation techniques and motivate the particular approach taken by Knet.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Computation of gradients in computer models is performed by four main methods (Baydin et al. 2015):","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"manual differentiation (programming the derivatives)\nnumerical differentiation (using finite difference approximations)\nsymbolic differentiation (using expression manipulation)\nautomatic differentiation (detailed below)","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Manually taking derivatives and coding the result is labor intensive, error-prone, and all but impossible with complex deep learning models.  Numerical differentiation is simple: f(x)=(f(x+epsilon)-f(x-epsilon))(2epsilon) but impractical: the finite difference equation needs to be evaluated for each individual parameter, of which there are typically many. Pure symbolic differentiation using expression manipulation, as implemented in software such as Maxima, Maple, and Mathematica is impractical for different reasons: (i) it may not be feasible to express a machine learning model as a closed form mathematical expression, and (ii) the symbolic derivative can be exponentially larger than the model itself leading to inefficient run-time calculation. This leaves us with automatic differentiation.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"Automatic differentiation is the idea of using symbolic derivatives only at the level of elementary operations, and computing the gradient of a compound function by applying the chain rule to intermediate numerical results. For example, pure symbolic differentiation of sin^2(x) could give us 2sin(x)cos(x) directly. Automatic differentiation would use the intermediate numerical values x_1=sin(x), x_2=x_1^2 and the elementary derivatives dx_2dx_1=2x_1, dx_1dx=cos(x) to compute the same answer without ever building a full gradient expression.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"To implement automatic differentiation the target function needs to be decomposed into its elementary operations, a process similar to compilation. Most older machine learning frameworks (such as Theano, Torch, Caffe, Tensorflow and older versions of Knet prior to v0.8) compile models expressed in a restricted mini-language into a static computational graph of elementary operations that have pre-defined derivatives. There are two drawbacks with this approach: (i) the restricted mini-languages tend to have limited support for high-level language features such as conditionals, loops, helper functions, array indexing, etc. (e.g. the infamous scan operation in Theano) (ii) the sequence of elementary operations that unfold at run-time needs to be known in advance, and they are difficult to handle when the sequence is data dependent.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"There is an alternative: high-level languages, like Julia and Python, already know how to decompose functions into their elementary operations. If we let the users define their models directly in a high-level language, then record the elementary operations during loss calculation at run-time, a dynamic computational graph can be constructed from the recorded operations. The cost of recording is not prohibitive: The table below gives cumulative times for elementary operations of an MLP with quadratic loss. Recording only adds 15% to the raw cost of the forward computation. Backpropagation roughly doubles the total time as expected.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"op secs\na1=w1*x 0.67\na2=w2.+a1 0.71\na3=max.(0,a2) 0.75\na4=w3*a3 0.81\na5=w4.+a4 0.85\na6=a5-y 0.89\na7=sum(abs2,a6) 1.18\n+recording 1.33\n+backprop 2.79","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"This is the approach taken by the popular autograd Python package and its Julia port AutoGrad.jl used by Knet. Recently, other machine learning frameworks have been adapting dynamic computational graphs: Chainer, DyNet, PyTorch, TensorFlow Fold. Related Julia projects include Flux and JuliaDiff.","category":"page"},{"location":"tutorial/","page":"Introduction to Knet","title":"Introduction to Knet","text":"In AutoGrad, parameters of interest are boxed by the Param type. y = @diff f(x) returns a struct such that value(y) gives f(x) (which should be a scalar), params(y) gives the list of parameters that took place in the computation of f(x), and grad(y,p) gives the gradient of f(x) with respect to parameter p.  In a @diff context, the elementary operations in f are overloaded to record their actions and output boxed answers when their inputs are boxed. The sequence of recorded operations is then used to compute gradients. Derivatives can be defined independently for each method of a function (determined by argument types) making full use of Julia's multiple dispatch. New elementary operations and derivatives can be defined concisely using Julia's macro and meta-programming facilities. See AutoGrad.jl for details.","category":"page"}]
}
