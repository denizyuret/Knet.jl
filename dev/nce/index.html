<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Noise Contrastive Estimation · Knet.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Knet.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../install/">Setting up Knet</a></li><li><a class="tocitem" href="../tutorial/">Introduction to Knet</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul></li><li><span class="tocitem">Textbook</span><ul><li><a class="tocitem" href="../backprop/">Backpropagation and SGD</a></li><li><a class="tocitem" href="../softmax/">Softmax Classification</a></li><li><a class="tocitem" href="../mlp/">Multilayer Perceptrons</a></li><li><a class="tocitem" href="../cnn/">Convolutional Neural Networks</a></li><li><a class="tocitem" href="../rnn/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../rl/">Reinforcement Learning</a></li><li><a class="tocitem" href="../opt/">Optimization</a></li><li><a class="tocitem" href="../gen/">Generalization</a></li><li class="is-active"><a class="tocitem" href>Noise Contrastive Estimation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Textbook</a></li><li class="is-active"><a href>Noise Contrastive Estimation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Noise Contrastive Estimation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/nce.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Noise-Contrastive-Estimation"><a class="docs-heading-anchor" href="#Noise-Contrastive-Estimation">Noise Contrastive Estimation</a><a id="Noise-Contrastive-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Noise-Contrastive-Estimation" title="Permalink"></a></h1><p>(c) Deniz Yuret, 2015-10-09, last updated: 2019-10-01</p><p>Noise contrastive estimation (NCE) replaces the expensive vocabulary-sized softmax operation at the final layer of language models with a cheaper sampling based operation, which results in significant speed-up during training. To motivate NCE, let us start with the basic equations for probabilistic models.</p><p>To model the probability distribution <span>$p(y)$</span> of a set of objects <span>$y \in \mathcal{Y}$</span>, we start with a score function <span>$s_{\theta}(y):\mathcal{Y}\rightarrow\mathbb{R}$</span> with adjustable weights <span>$\theta$</span>. For example log-linear models use <span>$s_{\theta}(y)=\theta^T \phi(y)$</span> where <span>$\theta$</span> is a weight vector and <span>$\phi(y):\mathcal{Y}\rightarrow\mathbb{R}^D$</span> is a function that maps an element of <span>$\mathcal{Y}$</span> to a vector of real valued features.  Conditional models use <span>$p(y|x)$</span>, <span>$s_{\theta}(x,y)$</span>, and <span>$\phi(x,y)$</span> instead. We will stick with non-conditional notation for brevity.</p><p>To go from arbitrary valued scores to normalized probability estimates we use exponentiation and normalization (which, for some reason, is called the softmax function):</p><p class="math-container">\[p_{\theta}(y) = \frac{\exp s_{\theta}(y)}{\sum_{y&#39;\in \mathcal{Y}} \exp s_{\theta}(y&#39;)}\]</p><p>The maximum likelihood estimate (MLE) training objective is to maximize the estimated probability of a given training set <span>$Y=\{y_1,\ldots,y_n\}$</span>. Assuming the instances in the training set are selected independently we have <span>$\log p_{\theta}(Y) = \sum_{y\in Y} \log p_{\theta}(y)$</span>. The contribution of an individual instance to the objective is:</p><p class="math-container">\[L_{MLE}(\theta) = \log p_{\theta}(y) = s_{\theta}(y) - \log\sum_{y&#39;\in\mathcal{Y}}\exp s_{\theta}(y&#39;)\]</p><p>Stochastic gradient descent (SGD) uses the gradient of this quantity with respect to the weights <span>$\theta$</span> to find the MLE solution:</p><p class="math-container">\[\begin{aligned}
	\nabla L_{MLE}(\theta) &amp;= \nabla s_{\theta}(y) - \nabla \log\sum_{y&#39;\in\mathcal{Y}}\exp s_{\theta}(y&#39;) \\
	&amp;= \nabla s_{\theta}(y) - \frac{\sum_{y&#39;\in\mathcal{Y}}\exp s_{\theta}(y&#39;) \nabla s_{\theta}(y&#39;)}{\sum_{y&#39;\in\mathcal{Y}}\exp s_{\theta}(y&#39;)} \\
	&amp;= \nabla s_{\theta}(y) - \sum_{y&#39;\in\mathcal{Y}} p_{\theta}(y&#39;) \nabla s_{\theta}(y&#39;) \\
\end{aligned}\]</p><p>Note that the second term in the final equation involves a sum over the whole <span>$\mathcal{Y}$</span> which is typically a computational nightmare. In order to avoid this sum, people have come up with all sorts of tricks.  One simple example is the <em>perceptron approximation</em>:</p><p class="math-container">\[\log\sum_{y&#39;\in\mathcal{Y}}\exp s_{\theta}(y&#39;) \approx \max_{y&#39;\in\mathcal{Y}} s_{\theta}(y&#39;) \\
\nabla L(\theta) \approx \nabla s_{\theta}(y) - \nabla \max_{y&#39;\in\mathcal{Y}} s_{\theta}(y&#39;)\]</p><p>Here is an example to demonstrate why this makes sense. Let&#39;s say <span>$\mathcal{Y}$</span> has three elements and their scores, <span>$s_{\theta}(y&#39;)$</span>, are 10, 20, and 30. When we exponentiate these scores we get <span>$e^{10}$</span>, <span>$e^{20}$</span> and <span>$e^{30}$</span>. Note that even though 20 and 30 are not all that different, <span>$e^{30}\approx 10^{13}$</span> is significantly larger than <span>$e^{20}\approx 5\times 10^9$</span>. When we add the exponentials, <span>$e^{10}+e^{20}+e^{30}$</span>, the result will not be significantly different from <span>$e^{30}$</span>, and thus the result of the final <span>$\log$</span> will not be that different from 30 (it is 30.000045401... if you are curious) (and that is why <span>$\log\sum\exp$</span> <em>should</em> be called the softmax function).</p><p>The perceptron approximation seems to replace the expensive summation with an equally expensive looking max operation. Fortunately the max operation can be performed fast for certain classes of problems. This will be the topic of another chapter, for now let&#39;s get back to NCE.</p><p>NCE takes a different approach to avoid the costly summation. Instead of modeling the empirical distribution <span>$p(y)$</span> directly, it proposes solving the related binary classification problem of distinguishing samples generated by <span>$p(y)$</span> from samples generated by a &quot;noise&quot; distribution <span>$q(y)$</span>. It is common practice to use a simple uniform distribution or, for language models, the unigram distribution for <span>$q(y)$</span>.</p><p>How is the binary classification problem of deciding <span>$p$</span> vs <span>$q$</span> related to the original density estimation problem of modeling <span>$p$</span>? Assume we generate <span>$k$</span> noise samples <span>$y_{1\ldots k}\sim q(y)$</span> for each real sample and add them to our original training data. We label each real sample with <span>$d=1$</span> and each noise sample with <span>$d=0$</span> to train a binary classifier. The joint probability of the samples and labels in this new dataset is:</p><p class="math-container">\[p(d=1, y) = \frac{1}{k+1}\,p(y) \qquad p(d=0, y) = \frac{k}{k+1}\,q(y)\]</p><p>The conditional probability of the label given the sample is:</p><p class="math-container">\[p(d=1\mid y) = \frac{p(y)}{p(y)+k\,q(y)} \qquad p(d=0\mid y) = \frac{k\,q(y)}{p(y)+k\,q(y)}\]</p><p>This means <span>$p(d=1\mid y)$</span> and <span>$p(y)$</span> are related by a simple algebraic identity. In fact, if somebody hands us a good estimate for <span>$p(d=1\mid y)$</span>, we can turn it into an esimate for <span>$p(y)$</span>:</p><p class="math-container">\[p(y) = k\, q(y)\, \frac{p(d=1\mid y)}{p(d=0\mid y)}\]</p><p>NCE suggests training the following binary classifier model for <span>$p(d=1\mid y)$</span> on the dataset with noise samples.</p><p class="math-container">\[p_{\theta}(d=1\mid y) = \frac{\exp s_{\theta}(y)}{\exp s_{\theta}(y) + k\,q(y)}\]</p><p>Using this model will give us the following for <span>$p_{\theta}(y)$</span>:</p><p class="math-container">\[\begin{aligned}
	p_{\theta}(y) &amp;= k\, q(y)\, \frac{p_{\theta}(d=1\mid y)}{p_{\theta}(d=0\mid y)} \\
	&amp;= k\,q(y)\, \frac{\exp s_{\theta}(y)}{k\,q(y)} \\
	&amp;= \exp s_{\theta}(y)
\end{aligned}\]</p><p>which amounts to assuming our costly normalization term <span>$Z=\sum_{y&#39;\in \mathcal{Y}} \exp s_{\theta}(y&#39;)$</span> is <span>$1$</span>.</p><p>Our new objective is to maximize the conditional probability of the NCE dataset. Consider the conditional log probability of a real sample <span>$y_0$</span> and <span>$k$</span> noise samples <span>$y_1\ldots y_k$</span>:</p><p class="math-container">\[\begin{aligned} L_{NCE}(\theta) 
	&amp;= \log p_{\theta}(d=1\mid y_0) + \sum_{i=1}^k \log p_{\theta}(d=0\mid y_i) \\
	&amp;= s_{\theta}(y_0) - \log(\exp s_{\theta}(y_0) + k\,q(y_0)) + \sum_{i=1}^k \log(k\,q(y_i)) - \log(\exp s_{\theta}(y_i) + k\,q(y_i)) \\
\end{aligned}\]</p><p>The gradient of the new objective is:</p><p class="math-container">\[\begin{aligned} \nabla L_{NCE}(\theta)
	&amp;= \nabla s_{\theta}(y_0) - \sum_{i=0}^k \nabla \log(\exp s_{\theta}(y_i) + k\,q(y_i)) \\
	&amp;= \nabla s_{\theta}(y_0) - \sum_{i=0}^k p_{\theta}(d=1\mid y_i) \nabla s_{\theta}(y_i) \\
\end{aligned}\]</p><p>In the limit <span>$k\rightarrow\infty$</span> we see that the NCE gradient approaches the MLE gradient:</p><p class="math-container">\[\begin{aligned} \nabla L_{NCE}(\theta)
	&amp;\rightarrow \nabla s_{\theta}(y_0) - \sum_{y\in\mathcal{Y}} k\, q(y) p_{\theta}(d=1\mid y) \nabla s_{\theta}(y) \\
	&amp;= \nabla s_{\theta}(y_0) - \sum_{y\in\mathcal{Y}} k\, q(y) \frac{\exp s_{\theta}(y)}{\exp s_{\theta}(y) + k\,q(y)} \nabla s_{\theta}(y) \\
	&amp;\rightarrow \nabla s_{\theta}(y_0) - \sum_{y\in\mathcal{Y}} \exp s_{\theta}(y) \nabla s_{\theta}(y) \\
	&amp;= \nabla s_{\theta}(y_0) - \sum_{y\in\mathcal{Y}} p_{\theta}(y) \nabla s_{\theta}(y)
\end{aligned}\]</p><p>What does this all mean computationally? Let&#39;s compare the operations of MLE and NCE language models in their final layers. Say both models use a <span>$D$</span>-dimensional internal representation. For the MLE model, the output is a <span>$V$</span>-dimensional probability vector where <span>$V$</span> is the vocabulary size. The forward pass involves multiplication of the <span>$D$</span>-dimensional internal representation with a <span>$V \times D$</span> decoding matrix and normalization of the result, an <span>$O(VD)$</span> operation.</p><p>The NCE model, on the other hand, only needs the scores of the correct word and <span>$K$</span> additional noise sample words during training. This involves extracting <span>$K+1$</span> rows from the <span>$V \times D$</span> decoding matrix, multiplying the <span>$D$</span>-dimensional internal representation with the resulting <span>$(K+1) \times D$</span> matrix and no normalization, an <span>$O(KD)$</span> operation. Because <span>$K \ll V$</span> this results in a large speed-up.</p><p>Here is the backward pass for MLE (with subscripts dropped for brevity):</p><p class="math-container">\[\begin{aligned}
	&amp;p(y) = \frac{\exp s(y)}{\sum_{y&#39;\in\mathcal{Y}}\exp s(y&#39;)} \\
	&amp;L = \log p(y) = s(y) - \log\sum_{y&#39;\in\mathcal{Y}}\exp s(y&#39;) \\
	&amp;{\partial L}/{\partial s(y)} = 1 - p(y) \\
	&amp;{\partial L}/{\partial s(y&#39;)} = -p(y&#39;) \\
\end{aligned}\]</p><p>Here is the backward pass for NCE:</p><p class="math-container">\[\begin{aligned}
	&amp;p(d=1\mid y) = \frac{\exp s(y)}{\exp s(y) + k\,q(y)} \qquad p(d=0\mid y) = \frac{k\,q(y)}{\exp s(y) + k\,q(y)} \\
	&amp;L = \log p(d=1\mid y) + \sum_{i=1}^k \log p(d=0\mid y_i) \\
	&amp;L = s(y) - \log(\exp s(y)+k\,q(y)) + \sum_{i=1}^k \log(k\,q(y_i)) - \log(\exp s(y_i)+k\,q(y_i)) \\
	&amp;{\partial L}/{\partial s(y)} = 1 - p(d=1\mid y) \\
	&amp;{\partial L}/{\partial s(y_i)} = -p(d=1\mid y_i) \\
\end{aligned}\]</p><p><strong>Research Ideas:</strong></p><ul><li>Can we use the words in a minibatch as noise samples for each other, presumably with an importance sampling correction factor?</li><li>Can we use other models for the binary classification problem?</li></ul><p><strong>References:</strong></p><p>Gutmann, M. U., &amp; Hyvärinen, A. (2012). Noise-contrastive estimation of unnormalized statistical models, with applications to natural image statistics. The Journal of Machine Learning Research, <a href="http://www.jmlr.org/papers/v13/gutmann12a.html">13(1), 307-361</a>.</p><p>Mnih, A., &amp; Teh, Y. W. (2012). A fast and simple algorithm for training neural probabilistic language models. arXiv preprint <a href="https://arxiv.org/abs/1206.6426">arXiv:1206.6426</a>.</p><p>Dyer, C. (2014). Notes on Noise Contrastive Estimation and Negative Sampling. arXiv preprint <a href="https://arxiv.org/abs/1410.8251">arXiv:1410.8251</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gen/">« Generalization</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 26 December 2020 21:21">Saturday 26 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
