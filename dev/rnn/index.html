<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Recurrent Neural Networks · Knet.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Knet.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../install/">Setting up Knet</a></li><li><a class="tocitem" href="../tutorial/">Introduction to Knet</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul></li><li><span class="tocitem">Textbook</span><ul><li><a class="tocitem" href="../backprop/">Backpropagation and SGD</a></li><li><a class="tocitem" href="../softmax/">Softmax Classification</a></li><li><a class="tocitem" href="../mlp/">Multilayer Perceptrons</a></li><li><a class="tocitem" href="../cnn/">Convolutional Neural Networks</a></li><li class="is-active"><a class="tocitem" href>Recurrent Neural Networks</a><ul class="internal"><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#Architectures"><span>Architectures</span></a></li><li><a class="tocitem" href="#RNN-vs-MLP"><span>RNN vs MLP</span></a></li><li><a class="tocitem" href="#Backpropagation-through-time"><span>Backpropagation through time</span></a></li><li><a class="tocitem" href="#Vanishing-and-exploding-gradients"><span>Vanishing and exploding gradients</span></a></li><li><a class="tocitem" href="#LSTM-and-GRU"><span>LSTM and GRU</span></a></li><li><a class="tocitem" href="#Practical-issues"><span>Practical issues</span></a></li><li><a class="tocitem" href="#Further-reading"><span>Further reading</span></a></li></ul></li><li><a class="tocitem" href="../rl/">Reinforcement Learning</a></li><li><a class="tocitem" href="../opt/">Optimization</a></li><li><a class="tocitem" href="../gen/">Generalization</a></li><li><a class="tocitem" href="../nce/">Noise Contrastive Estimation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Textbook</a></li><li class="is-active"><a href>Recurrent Neural Networks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Recurrent Neural Networks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/rnn.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Recurrent-Neural-Networks"><a class="docs-heading-anchor" href="#Recurrent-Neural-Networks">Recurrent Neural Networks</a><a id="Recurrent-Neural-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrent-Neural-Networks" title="Permalink"></a></h1><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>Recurrent neural networks (RNNs) are typically used in sequence processing applications such as natural language processing and generation. Some specific examples include:</p><ul><li><em>Sequence classification:</em> given a sequence input, produce a fixed sized output, e.g. determine the &quot;sentiment&quot; of a product review.</li><li><em>Sequence generation:</em> given a fixed sized input, produce a sequence output, e.g. automatic image captioning.</li><li><em>Sequence tagging:</em> given a sequence, produce a label for each token, e.g. part-of-speech tagging.</li><li><em>Sequence-to-sequence mapping:</em> given a sequence, produce another, not necessarily parallel, sequence. e.g. machine translation, speech recognition.</li></ul><p>All feed-forward models we have seen so far (Linear, MLP, CNN) have a common limitation: They are memoryless, i.e. they apply the same computational steps to each instance without any memory of previous instances. Each output is obtained from the current input and model parameters using a fixed number of common operations:</p><p class="math-container">\[\hat{y}_t = f(x_t,w)\]</p><p>A model with no memory is difficult to apply to variable sized inputs and outputs with nontrivial dependencies.  Let us take sequence tagging as an example problem.  To apply a feed-forward model to a sequence, one option is to treat each token of the sequence as an individual input:</p><p><img src="../images/fnnseq1.jpg" alt="image"/></p><p>Applying the same computation to each input token makes sense only if the different input-output pairs are IID (independent and identically distributed).  However the IID assumption is violated in typical sequence processing applications like language modeling and speech recognition where the output of one time step may depend on the inputs and outputs from other time steps.</p><!--
[](TODO: Applying a fixed number of computational steps: why limiting?when a single layer is universal?  check the proofs.)  
[](fixed size api from karpathy)
--><p>Another option is to treat the whole sequence as a single input:</p><p><img src="../images/fnnseq2.jpg" alt="image"/></p><p>The first problem with this approach is that the inputs are of varying length.  We could potentially address this issue using a convolutional architecture, and this is a viable alternative for sequence classification problems.  However we have a more serious problem with variable length outputs: The space of possible outputs grow exponentially with length and output tokens have possible dependencies between them.  Problems of this type are known as &quot;structured prediction&quot;, see <a href="http://www.cs.cmu.edu/~nasmith/LSP">(Smith 2011)</a> for a good introduction. It is not clear how to generate and score variable sized outputs in a single shot with a single feed-forward model.</p><!--
[](convolutions for sequences: Potential research topic!)
[](exponential output growth: Can we tie this to fixed number of computational steps?)
--><p>Finally we can generate each output token separately, but take a fixed sized window around the corresponding input token to take into account more context:</p><p><img src="../images/fnnseq3.jpg" alt="image"/></p><p>This is the approach taken by, e.g. n-gram language models, and <a href="http://www.jmlr.org/papers/v3/bengio03a.html">Bengio&#39;s MLP language model</a>.  The problem with this approach is that we don&#39;t know how large the window needs to be.  In fact different tokens may require different sized windows, e.g. long range dependencies between words in a sentence.  RNNs provide a more elegant solution.</p><p>RNNs process the input sequence one token at a time.  However, each output is not only a function of the current input, but some internal state determined by previous time steps:</p><p class="math-container">\[\langle\hat{y}_t,h_t\rangle = f(x_t,w,h_{t-1})\]</p><p><img src="../images/rnntagger.jpg" alt="image"/></p><p>The state <span>$h_t$</span> can be thought of as analogous to a memory device storing variables in a computer program.  In fact, RNNs have been proven to be <a href="http://binds.cs.umass.edu/papers/1995_Siegelmann_Science.pdf">Turing complete machines</a> (however see <a href="https://www.reddit.com/r/MachineLearning/comments/6il5rk/d_rnns_are_not_really_turing_complete_in_any/">this</a> and <a href="http://metarecursive.com/writings/RNNs_are_probably_not_practically_Turing_Complete..htm">this</a> for a discussion).  At each time step, the RNN processes the current input <span>$x_t$</span> using the &quot;program&quot; specified by parameters <span>$w$</span> and the internal &quot;variables&quot; specified by <span>$h_{t-1}$</span>.  The program stores new values in its internal variables with <span>$h_t$</span> and possibly produces an output <span>$\hat{y}_t$</span>.</p><!--
[](turing completeness, program analogy, but first figure out universality of mlp vs turing completeness of rnn)
[](parameter sharing perspective, goodfellow: compare with 1-D convolution.)
[](simple examples with irnn: adding, mnist-by-pixel, lm, timit, do we have data?)
[](other possible examples: postag, charner.)
--><h2 id="Architectures"><a class="docs-heading-anchor" href="#Architectures">Architectures</a><a id="Architectures-1"></a><a class="docs-heading-anchor-permalink" href="#Architectures" title="Permalink"></a></h2><p>Depending on the type of problem, we can deploy an RNNs with architectures other than the tagger architecture we saw above.  Some examples are:</p><ul><li>Sequence classification</li></ul><p><img src="../images/rnnclassifier.jpg" alt="image"/></p><ul><li>Sequence generation</li></ul><p><img src="../images/rnnlm.jpg" alt="image"/></p><ul><li>Sequence to sequence mapping models which combine the previous two architectures. The input sequence is processed by an encoder RNN (E), and the output sequence is generated by a decoder RNN (D). Information is passed from the encoder to the decoder through the initial hidden state, or an extra input, or an attention mechanism.</li></ul><p><img src="../images/rnns2s.jpg" alt="image"/></p><!--
[](Modeling sequences: hinton)
[](input to output sequence speech, synched, unsynched, when does output start/stop if unsynched ctc)
[](predict next token lm)
[](sequence classification)
[](s2s models)
[](Karpathy's graph is more clear)
[](Hinton's providing input and teaching signals variations)
[](graves book chap 2 has a classification, )
[](Goodfellow 10.5 Seq->Tok, 10.9 Tok->Seq Tok=Initial and/or Tok=>Input, 10.3,4,10,11 SeqN->SeqN, Sec 10.4 S2S.)
[](deeplearningbook 379 fig 10.3,4,5 has example design patterns)
[](Models: hinton)
[](memoryless models, bengios language model)
[](start with a regular mlp converted to rnn like Goodfellow.)
--><h2 id="RNN-vs-MLP"><a class="docs-heading-anchor" href="#RNN-vs-MLP">RNN vs MLP</a><a id="RNN-vs-MLP-1"></a><a class="docs-heading-anchor-permalink" href="#RNN-vs-MLP" title="Permalink"></a></h2><p>For comparison here is the code for MLP with one hidden layer vs. the code for a comparable RNN. <a href="how about a linear rnn?"></a></p><pre><code class="language-julia">function mlp1(w,x)
    h = tanh(w[1]*x .+ w[2])
    y = w[3]*h .+ w[4]
    return y
end

function rnn1(w,x,h)
    h = tanh(w[1]*vcat(x,h) .+ w[2])
    y = w[3]*h .+ w[4]
    return (y,h)
end</code></pre><p>Note two crucial differences: First, RNN takes <code>h</code>, the hidden state from the previous time step, in addition to the regular input <code>x</code>. Second, it returns the new value of <code>h</code> in addition to the regular output <code>y</code>.</p><h2 id="Backpropagation-through-time"><a class="docs-heading-anchor" href="#Backpropagation-through-time">Backpropagation through time</a><a id="Backpropagation-through-time-1"></a><a class="docs-heading-anchor-permalink" href="#Backpropagation-through-time" title="Permalink"></a></h2><p>RNNs can be trained using the same gradient based optimization algorithms we use for feed-foward networks. This is best illustrated with a picture of an RNN unrolled in time:</p><p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png" alt="image"/> (<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs">image source</a>)</p><p>The picture on the left depicts an RNN influencing its own hidden state A while computing its output h for a single time step.  The equivalent picture on the right shows each time step as a separate column with its own input, state and output.  We need to keep in mind that the <em>function</em> that goes from the input and the previous state to the output and the next state is identical at each time step.  Viewed this way, there are no cycles in the computation graph and we can treat the RNN as just a multi-layer feed-forward net which (i) has as many layers as time steps, (ii) has weights shared between different layers, and (iii) may have multiple inputs and outputs received and produced at individual layers.</p><p>Backpropagation through time (BPTT) is the SGD algorithm applied to RNNs unrolled in time.  First, the RNN is run and its outputs are collected for the whole sequence.  Then the losses for all outputs are calculated and summed.  Finally the backward pass goes over the computational graph for the whole sequence, accumulating the gradients of each parameter coming from different time steps.</p><p>In practice, with Knet, all we have to do is to write a loss function that computes the total loss for the whole sequence and use its <code>grad(f)</code> for training.  Here is an example for a sequence tagger:</p><pre><code class="language-julia">function rnnloss(param,state,inputs,outputs)
    # inputs and outputs are sequences of the same length
    sumloss = 0
    for t in 1:length(inputs)
        prediction,state = rnn1(param,inputs[t],state)
        sumloss += cross_entropy_loss(prediction,outputs[t])
    end
    return sumloss
end

rnngrad = grad(rnnloss)

# train with our usual SGD procedure</code></pre><p><a href="Hinton 7b"></a> <a href="Unfolding picture"></a></p><h2 id="Vanishing-and-exploding-gradients"><a class="docs-heading-anchor" href="#Vanishing-and-exploding-gradients">Vanishing and exploding gradients</a><a id="Vanishing-and-exploding-gradients-1"></a><a class="docs-heading-anchor-permalink" href="#Vanishing-and-exploding-gradients" title="Permalink"></a></h2><p>RNNs can be difficult to train because gradients passed back through many layers may vanish or explode. To see why, let us first look at the evolution of the hidden state during the forward pass of an RNN. We will ignore the input and the bias for simplicity:</p><pre><code class="language-julia">h[t+1] = tanh(W*h[t]) = tanh(W*tanh(W*h[t-1])) = ...</code></pre><p>No matter how many layers we go through, the forward <code>h</code> values will remain in the <code>[-1,1]</code> range because of the squashing <code>tanh</code> function, no problems here.  However, look at what happens in the backward pass:</p><pre><code class="language-julia">dh[t] = W&#39; * (dh[t+1] .* f(h[t+1]))</code></pre><p>where <code>dh[t]</code> is the gradient of the loss with respect to <code>h[t]</code> and <code>f</code> is some elementwise function whose outputs are in the <code>[-1,1]</code> range (in the case of <code>tanh</code>, <code>f(x)=(1+x)*(1-x)</code>). The important thing to notice is that the <code>dh</code> gradients keep getting multiplied by the same matrix <code>W&#39;</code> over and over again as we move backward, and the backward pass is linear, i.e. there is no squashing function.</p><p>What happens if we keep multiplying a vector <span>$u$</span> with the same matrix over and over again?  Suppose the matrix has an eigendecomposition <span>$V\Lambda V^{-1}$</span>.  After n multiplications in effect we will have multiplied with <span>$V\Lambda^n V^{-1}$</span> where <span>$\Lambda$</span> is a diagonal matrix of eigenvalues. The components of the gradient corresponding to eigenvalues greater than 1 will grow without a bound and the components for eigenvalues less than 1 will shrink towards zero. The gradient entries that grow without a bound destabilize SGD, and the ones that shrink to zero pass no information about the error back to the parameters.</p><p>There are several possible solutions to these problems:</p><ul><li>Initialize the weights to avoid eigenvalues that are too large or too small. Even initializing the weights from a model successfully trained on some other task may help start them in the right regime.</li><li>Use gradient clipping: this is the practice of downscaling gradients if their norm is above a certain threshold to help stabilize SGD.</li><li>Use better optimization algorithms: methods like Adam and Adagrad adjust the learning rate for each parameter based on the history of updates and may be less sensitive to vanishing and exploding gradients.</li><li>Use RNN modules designed to preserve long range information: modules such as LSTM and GRU are designed to help information flow better across time steps and are detailed in the next section.  </li></ul><p><a href="motivation: why do mlp rnns have a hard time learning? vanishing gradients relevant according to DL 10.7 are vanishing gradients only important for bptt? how does lstm solve them?"></a> <a href="Hinton 7d: why bptt is difficult, back pass linear."></a> <a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/"></a> <a href="This may have a different math explanation: http:/www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/"></a> <a href="Adam and gclip DL 10.11"></a></p><h2 id="LSTM-and-GRU"><a class="docs-heading-anchor" href="#LSTM-and-GRU">LSTM and GRU</a><a id="LSTM-and-GRU-1"></a><a class="docs-heading-anchor-permalink" href="#LSTM-and-GRU" title="Permalink"></a></h2><p><a href="lstm/gru: http:/colah.github.io/posts/2015-08-Understanding-LSTMs/ DL 10.10"></a></p><p>The Long Short Term Memory (LSTM) and the Gated Recurrent Unit (GRU) are two of the modules designed as building blocks for RNNs to address vanishing gradients and better learn long term dependencies. These units replace the simple <code>tanh</code> unit used in <code>rnn1</code>.</p><p>... To be continued</p><pre><code class="language-julia">function lstm(weight,bias,hidden,cell,input)
    gates   = hcat(input,hidden) * weight .+ bias
    h       = size(hidden,2)
    forget  = sigm(gates[:,1:h])
    ingate  = sigm(gates[:,1+h:2h])
    outgate = sigm(gates[:,1+2h:3h])
    change  = tanh(gates[:,1+3h:end])
    cell    = cell .* forget + ingate .* change
    hidden  = outgate .* tanh(cell)
    return (hidden,cell)
end</code></pre><h2 id="Practical-issues"><a class="docs-heading-anchor" href="#Practical-issues">Practical issues</a><a id="Practical-issues-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-issues" title="Permalink"></a></h2><ul><li><p>input and output (word Embedding and prediction) layers</p></li><li><p>decoding and generating: greedy, beam, stochastic.</p></li><li><p>minibatching</p></li><li><p>(Advanced topics)</p></li><li><p>(multilayer DL 10.5)</p></li><li><p>(bidirectional)</p></li><li><p>(attention: http://distill.pub/2016/augmented-rnns/)</p></li><li><p>(speech, handwriting, mt)</p></li><li><p>(image captioning, vqa)</p></li><li><p>(ntm, memory networks: (DL 10.12) http://distill.pub/2016/augmented-rnns/)</p></li><li><p>(2D rnns: graves chap 8. DL end of 10.3.)</p></li><li><p>(recursive nets? DL 10.6)</p></li><li><p>(different length input/output sequences: graves a chapter 7 on ctc, chap 6 on hmm hybrids., olah and carter on adaptive computation time. DL 10.4 on s2s.)</p></li><li><p>(comparison to LDS and HMM Hinton)</p></li><li><p>(discussion of teacher forcing and its potential problems DL 10.2.1)</p></li><li><p>(echo state networks DL 10.8 just fix the h-&gt;h weights.)</p></li><li><p>(skip connections in time, leaky units DL 10.9)</p></li></ul><h2 id="Further-reading"><a class="docs-heading-anchor" href="#Further-reading">Further reading</a><a id="Further-reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-reading" title="Permalink"></a></h2><ul><li><a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">Karpathy 2015.</a> The Unreasonable Effectiveness of Recurrent Neural Networks.</li><li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs">Olah 2015.</a> Understanding LSTMs.</li><li><a href="https://d396qusza40orc.cloudfront.net/neuralnets/lecture_slides/lec7.pdf">Hinton 2012.</a> RNN lecture slides.</li><li><a href="http://distill.pub/2016/augmented-rnns">Olah and Carter 2016.</a> Attention and Augmented Recurrent Neural Networks.</li><li><a href="http://www.deeplearningbook.org/contents/rnn.html">Goodfellow 2016.</a> Deep Learning, Chapter 10. Sequence modeling: recurrent and recursive nets.</li><li><a href="https://www.cs.toronto.edu/~graves/preprint.pdf">Graves 2012.</a>, Supervised Sequence Labelling with Recurrent Neural Networks (textbook)</li><li><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns">Britz 2015.</a> Recurrent neural networks tutorial.</li><li><a href="http://cs224n.stanford.edu/">Manning and Socher 2017.</a> CS224n: Natural Language Processing with Deep Learning.</li><li><a href="https://en.wikipedia.org/wiki/Recurrent_neural_network">Wikipedia.</a> Recurrent neural network.</li><li><a href="https://www.willamette.edu/~gorr/classes/cs449/rnn1.html">Orr 1999.</a> RNN lecture notes.</li><li><a href="https://arxiv.org/abs/1504.00941">Le et al. 2015.</a> A simple way to initialize recurrent networks of rectified linear units</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cnn/">« Convolutional Neural Networks</a><a class="docs-footer-nextpage" href="../rl/">Reinforcement Learning »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 17 March 2021 08:00">Wednesday 17 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
