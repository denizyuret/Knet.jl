<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Knet · Knet.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Knet.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../install/">Setting up Knet</a></li><li class="current"><a class="toctext" href>Introduction to Knet</a><ul class="internal"><li><a class="toctext" href="#Summary-1">Summary</a></li><li><a class="toctext" href="#Philosophy-1">Philosophy</a></li><li><a class="toctext" href="#Tutorial-1">Tutorial</a></li><li><a class="toctext" href="#Benchmarks-1">Benchmarks</a></li><li><a class="toctext" href="#Under-the-hood-1">Under the hood</a></li></ul></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></li><li><span class="toctext">Textbook</span><ul><li><a class="toctext" href="../backprop/">Backpropagation</a></li><li><a class="toctext" href="../softmax/">Softmax Classification</a></li><li><a class="toctext" href="../mlp/">Multilayer Perceptrons</a></li><li><a class="toctext" href="../cnn/">Convolutional Neural Networks</a></li><li><a class="toctext" href="../rnn/">Recurrent Neural Networks</a></li><li><a class="toctext" href="../rl/">Reinforcement Learning</a></li><li><a class="toctext" href="../opt/">Optimization</a></li><li><a class="toctext" href="../gen/">Generalization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Introduction to Knet</a></li></ul><a class="edit-page" href="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction to Knet</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Introduction-to-Knet-1" href="#Introduction-to-Knet-1">Introduction to Knet</a></h1><h2><a class="nav-anchor" id="Summary-1" href="#Summary-1">Summary</a></h2><p><a href="https://denizyuret.github.io/Knet.jl/latest">Knet</a> (pronounced &quot;kay-net&quot;) is the <a href="http://www.ku.edu.tr/en">Koç University</a> deep learning framework implemented in <a href="http://docs.julialang.org">Julia</a> by <a href="http://www.denizyuret.com">Deniz Yuret</a> and collaborators.  It supports GPU operation and automatic differentiation using dynamic computational graphs for models defined in plain Julia. You can install Knet with the following at the julia prompt: <code>using Pkg; Pkg.add(&quot;Knet&quot;)</code>. Some useful links:</p><ul><li><a href="https://github.com/denizyuret/Knet.jl/tree/master/tutorial">Tutorial:</a>  introduces Julia and Knet via examples.</li><li><a href="https://denizyuret.github.io/Knet.jl/latest">Documentation:</a> installation, introduction, design, implementation, full reference and deep learning chapters.</li><li><a href="https://github.com/denizyuret/Knet.jl/tree/master/examples">Examples:</a> more tutorials and example models.</li><li><a href="http://denizyuret.github.io/Knet.jl/latest/tutorial.html#Benchmarks-1">Benchmarks:</a> comparison of Knet&#39;s speed with TensorFlow, PyTorch, DyNet etc.</li><li><a href="https://goo.gl/zeUBFr">Paper:</a> Yuret, D. &quot;Knet: beginning deep learning with 100 lines of julia.&quot; In <em>Machine Learning Systems Workshop</em> at NIPS 2016.</li><li><a href="https://github.com/KnetML">KnetML:</a> github organization with Knet repos of models, tutorials, layer collections and other resources.</li><li><a href="http://denizyuret.github.io/Knet.jl/latest/install.html#Using-Amazon-AWS-1">Images:</a> Knet machine images are available for <a href="http://denizyuret.github.io/Knet.jl/latest/install.html#Using-Amazon-AWS-1">AWS</a>, <a href="https://github.com/KnetML/singularity-images">Singularity</a> and <a href="https://github.com/JuliaGPU/docker">Docker</a>.</li><li><a href="https://github.com/denizyuret/Knet.jl/issues">Issues:</a> if you find a bug, please open a github issue.</li><li><a href="https://groups.google.com/forum/#!forum/knet-users">knet-users:</a> if you need help or would like to request a feature, please join this mailing list.</li><li><a href="https://groups.google.com/forum/#!forum/knet-dev">knet-dev:</a> if you would like to contribute to Knet development, please join this mailing list and check out these <a href="http://denizyuret.github.io/Knet.jl/latest/install.html#Tips-for-developers-1">tips</a>.</li><li><a href="https://julialang.slack.com/messages/CDLKQ92P3/details">knet-slack:</a> Slack channel for Knet.</li><li>Related work: Please check out <a href="https://github.com/FLuxML">Flux</a>, <a href="https://github.com/pluskid/Mocha.jl">Mocha</a>, <a href="https://github.com/JuliaML">JuliaML</a>, <a href="https://github.com/JuliaDiff">JuliaDiff</a>, <a href="https://github.com/JuliaGPU">JuliaGPU</a>, <a href="https://github.com/JuliaOpt">JuliaOpt</a> for related packages.</li></ul><h2><a class="nav-anchor" id="Philosophy-1" href="#Philosophy-1">Philosophy</a></h2><p>Knet uses dynamic computational graphs generated at runtime for automatic differentiation of (almost) any Julia code.  This allows machine learning models to be implemented by defining just the forward calculation (i.e. the computation from parameters and data to loss) using the full power and expressivity of Julia. The implementation can use helper functions, loops, conditionals, recursion, closures, tuples and dictionaries, array indexing, concatenation and other high level language features, some of which are often missing in the restricted modeling languages of static computational graph systems like Theano, Torch, Caffe and Tensorflow.  GPU operation is supported by simply using the KnetArray type instead of regular Array for parameters and data.</p><p>Knet builds a dynamic computational graph by recording primitive operations during forward calculation.  Only pointers to inputs and outputs are recorded for efficiency.  Therefore array overwriting is not supported during forward and backward passes.  This encourages a clean functional programming style.  High performance is achieved using custom memory management and efficient GPU kernels.  See <a href="#Under-the-hood-1">Under the hood</a> for more details.</p><h2><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h2><p>The Knet tutorial consists of Jupyter notebooks that introduce the programming language Julia and the Knet deep learning framework. By the end, the reader should be able to define, train, evaluate, and visualize basic MLP, CNN, and RNN models.  Each notebook is written to work stand-alone but they rely on concepts introduced in earlier notebooks, so I recommend reading them in order. Every Knet function outside of the standard Julia library is defined or explained before use. You can view the notebooks using the following links, or interact with them using a Jupyter server. Instructions for running a server locally or in the cloud can be found in the tutorial <a href="https://github.com/denizyuret/Knet.jl/tree/master/tutorial/README.md">README</a>.</p><ul><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/00.Julia_is_fast.ipynb">Julia is fast:</a> comparison of Julia&#39;s speed to C, Python and numpy.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/10.Getting_to_know_Julia.ipynb">Getting to know Julia:</a> basic Julia tutorial from <a href="http://juliabox.com">JuliaBox</a>.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/15.quickstart.ipynb">Quick start:</a> if you are familiar with other deep learning frameworks and want to see a quick Julia example.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/20.mnist.ipynb">The MNIST dataset:</a> introduction to the MNIST handwritten digit recognition dataset.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/25.iterators.ipynb">Julia iterators:</a> iterators are useful for generating and training with data.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/30.lin.ipynb">Creating a model:</a> define, train, visualize simple linear models, introduce gradients, SGD, using the GPU.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/40.mlp.ipynb">Multilayer perceptrons:</a> multi layer perceptrons, nonlinearities, model capacity, overfitting, regularization, dropout.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/50.cnn.ipynb">Convolutional networks:</a> convolutional neural networks, sparse and shared weights using conv4 and pool operations.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/60.rnn.ipynb">Recurrent networks:</a> introduction to recurrent neural networks.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/70.imdb.ipynb">IMDB sentiment analysis:</a> a simple RNN sequence classification model for sentiment analysis of IMDB movie reviews.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/80.charlm.ipynb">Language modeling:</a> a character based RNN language model that can write Shakespeare sonnets and Julia programs.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/90.s2s.ipynb">Sequence to sequence:</a> a sequence to sequence RNN model typically used for machine translation.</li></ul><h2><a class="nav-anchor" id="Benchmarks-1" href="#Benchmarks-1">Benchmarks</a></h2><h3><a class="nav-anchor" id="Knet-Benchmarks-(Sep-30,-2016)-1" href="#Knet-Benchmarks-(Sep-30,-2016)-1">Knet Benchmarks (Sep 30, 2016)</a></h3><p>Each of the examples above was used as a benchmark to compare Knet with other frameworks. The table below shows the number of seconds it takes to train a given model for a particular dataset, number of epochs and minibatch size for Knet, Theano, Torch, Caffe and TensorFlow. Knet had comparable performance to other commonly used frameworks.</p><table><tr><th>model</th><th>dataset</th><th>epochs</th><th>batch</th><th>Knet</th><th>Theano</th><th>Torch</th><th>Caffe</th><th>TFlow</th></tr><tr><td>LinReg</td><td>Housing</td><td>10K</td><td>506</td><td>2.84</td><td>1.88</td><td>2.66</td><td>2.35</td><td>5.92</td></tr><tr><td>Softmax</td><td>MNIST</td><td>10</td><td>100</td><td>2.35</td><td>1.40</td><td>2.88</td><td>2.45</td><td>5.57</td></tr><tr><td>MLP</td><td>MNIST</td><td>10</td><td>100</td><td>3.68</td><td>2.31</td><td>4.03</td><td>3.69</td><td>6.94</td></tr><tr><td>LeNet</td><td>MNIST</td><td>1</td><td>100</td><td>3.59</td><td>3.03</td><td>1.69</td><td>3.54</td><td>8.77</td></tr><tr><td>CharLM</td><td>Hiawatha</td><td>1</td><td>128</td><td>2.25</td><td>2.42</td><td>2.23</td><td>1.43</td><td>2.86</td></tr></table><p>The benchmarking was done on g2.2xlarge GPU instances on Amazon AWS. The code is available at <a href="https://github.com/ozanarkancan/Knet8-Benchmarks">github</a> and as machine image <code>deep_AMI_v6</code> at AWS N.California. See the section on <a href="../install/#Using-Amazon-AWS-1">Using Amazon AWS</a> for more information. The datasets are available online using the following links: <a href="https://archive.ics.uci.edu/ml/datasets/Housing">Housing</a>, <a href="http://yann.lecun.com/exdb/mnist">MNIST</a>, <a href="http://www.gutenberg.org/files/19/19.txt">Hiawatha</a>. The MLP uses a single hidden layer of 64 units. CharLM uses a single layer LSTM language model with embedding and hidden layer sizes set to 256 and trained using BPTT with a sequence length of 100. Each dataset was minibatched and transferred to GPU prior to benchmarking when possible.</p><h3><a class="nav-anchor" id="DyNet-Benchmarks-(Dec-15,-2017)-1" href="#DyNet-Benchmarks-(Dec-15,-2017)-1">DyNet Benchmarks (Dec 15, 2017)</a></h3><p>We implemented dynamic neural network examples from the <a href="https://github.com/neulab/dynet-benchmark">dynet-benchmark</a> repo to compare Knet with DyNet and Chainer. See <a href="https://arxiv.org/abs/1701.03980">DyNet technical report</a> for the architectural details of the implemented examples and the <a href="https://github.com/neulab/dynet-benchmark">github repo</a> for the source code.</p><ul><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/dynet-benchmark/rnnlm-batch.jl">rnnlm-batch</a>: A recurrent neural network language model on <a href="https://catalog.ldc.upenn.edu/ldc99t42">PTB</a> corpus.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/dynet-benchmark/bilstm-tagger.jl">bilstm-tagger</a>: A bidirectional LSTM network that predicts a tag for each word. It is trained on <a href="https://github.com/neulab/dynet-benchmark/tree/master/data/tags">WikiNER</a> dataset.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/dynet-benchmark/bilstm-tagger-withchar.jl">bilstm-tagger-withchar</a>: Similar to bilstm-tagger, but uses characer-based embeddings for unknown words.</li><li><a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/dynet-benchmark/treenn.jl">treenn</a>: A tree-structured LSTM sentiment classifier trained on <a href="https://nlp.stanford.edu/sentiment/index.html">Stanford Sentiment Treebank</a> dataset.</li></ul><p>Benchmarks were run on a server with Intel(R) Xeon(R) CPU E5-2695 v4 @ 2.10GHz and Tesla K80.</p><table><tr><th>Model</th><th>Metric</th><th>Knet</th><th>DyNet</th><th>Chainer</th></tr><tr><td><a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/dynet-benchmark/rnnlm-batch.jl">rnnlm-batch</a></td><td>words/sec</td><td>28.5k</td><td>18.7k</td><td>16k</td></tr><tr><td><a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/dynet-benchmark/bilstm-tagger.jl">bilstm-tagger</a></td><td>words/sec</td><td>6800</td><td>1200</td><td>157</td></tr><tr><td><a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/dynet-benchmark/bilstm-tagger-withchar.jl">bilstm-tagger-withchar</a></td><td>words/sec</td><td>1300</td><td>900</td><td>128</td></tr><tr><td><a href="https://github.com/denizyuret/Knet.jl/blob/master/examples/dynet-benchmark/treenn.jl">treenn</a></td><td>sents/sec</td><td>43</td><td>68</td><td>10</td></tr></table><h3><a class="nav-anchor" id="DeepLearningFrameworks-(Nov-24,-2017)-1" href="#DeepLearningFrameworks-(Nov-24,-2017)-1">DeepLearningFrameworks (Nov 24, 2017)</a></h3><p>More recently, @ilkarman has published CNN and RNN <a href="https://github.com/ilkarman/DeepLearningFrameworks">benchmarks</a> on Nvidia K80 GPUs, using the Microsoft Azure Data Science Virtual Machine for Linux (Ubuntu). The results are copied below.  You can find versions of the Knet notebooks used for these benchmarks in the Knet/examples/DeepLearningFrameworks directory.</p><p>Training CNN (VGG-style) on CIFAR-10 - Image Recognition</p><table><tr><th>DL Library</th><th>Test Accuracy (%)</th><th>Training Time (s)</th></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/MXNet_CNN.ipynb">MXNet</a></td><td>77</td><td>145</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Caffe2_CNN.ipynb">Caffe2</a></td><td>79</td><td>148</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Gluon_CNN.ipynb">Gluon</a></td><td>76</td><td>152</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Knet_CNN.ipynb">Knet(Julia)</a></td><td>78</td><td>159</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Chainer_CNN.ipynb">Chainer</a></td><td>79</td><td>162</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/CNTK_CNN.ipynb">CNTK</a></td><td>78</td><td>163</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/PyTorch_CNN.ipynb">PyTorch</a></td><td>78</td><td>169</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Tensorflow_CNN.ipynb">Tensorflow</a></td><td>78</td><td>173</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Keras_CNTK_CNN.ipynb">Keras(CNTK)</a></td><td>77</td><td>194</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Keras_TF_CNN.ipynb">Keras(TF)</a></td><td>77</td><td>241</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Theano_Lasagne_CNN.ipynb">Lasagne(Theano)</a></td><td>77</td><td>253</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Keras_Theano_CNN.ipynb">Keras(Theano)</a></td><td>78</td><td>269</td></tr></table><p>Training RNN (GRU) on IMDB - Natural Language Processing (Sentiment Analysis)</p><table><tr><th>DL Library</th><th>Test Accuracy (%)</th><th>Training Time (s)</th><th>Using CuDNN?</th></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/MXNet_RNN.ipynb">MXNet</a></td><td>86</td><td>29</td><td>Yes</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Knet_RNN.ipynb">Knet(Julia)</a></td><td>85</td><td>29</td><td>Yes</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Tensorflow_RNN.ipynb">Tensorflow</a></td><td>86</td><td>30</td><td>Yes</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/PyTorch_RNN.ipynb">Pytorch</a></td><td>86</td><td>31</td><td>Yes</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/CNTK_RNN.ipynb">CNTK</a></td><td>85</td><td>32</td><td>Yes</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Keras_TF_RNN.ipynb">Keras(TF)</a></td><td>86</td><td>35</td><td>Yes</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/Keras_CNTK_RNN.ipynb">Keras(CNTK)</a></td><td>86</td><td>86</td><td>N/A</td></tr></table><p>Inference ResNet-50 (Feature Extraction)</p><table><tr><th>DL Library</th><th>Images/s GPU</th><th>Images/s CPU</th></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-Knet.ipynb">Knet(Julia)</a></td><td>160</td><td>2</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-TF.ipynb">Tensorflow</a></td><td>155</td><td>11</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-PyTorch.ipynb">PyTorch</a></td><td>130</td><td>6</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-MXNet.ipynb">MXNet</a></td><td>130</td><td>8</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-MXNet-mkl.ipynb">MXNet(w/mkl)</a></td><td>129</td><td>25</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-CNTK.ipynb">CNTK</a></td><td>117</td><td>8</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-Chainer.ipynb">Chainer</a></td><td>107</td><td>3</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-Keras(TF).ipynb">Keras(TF)</a></td><td>98</td><td>5</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-Caffe2.ipynb">Caffe2</a></td><td>71</td><td>6</td></tr><tr><td><a href="https://github.com/ilkarman/DeepLearningFrameworks/blob/master/inference/ResNet50-Keras(CNTK).ipynb">Keras(CNTK)</a></td><td>46</td><td>4</td></tr></table><h2><a class="nav-anchor" id="Under-the-hood-1" href="#Under-the-hood-1">Under the hood</a></h2><p>Knet relies on the <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad</a> package and the <a href="../reference/#KnetArray-1">KnetArray</a> data type for its functionality and performance. AutoGrad computes the gradient of Julia functions and KnetArray implements high performance GPU arrays with custom memory management. This section briefly describes them.</p><h3><a class="nav-anchor" id="KnetArrays-1" href="#KnetArrays-1">KnetArrays</a></h3><p>GPUs have become indispensable for training large deep learning models.  Even the small examples implemented here run up to 17x faster on the GPU compared to the 8 core CPU architecture we use for benchmarking. However GPU implementations have a few potential pitfalls: (i) GPU memory allocation is slow, (ii) GPU-RAM memory transfer is slow, (iii) reduction operations (like <code>sum</code>) can be very slow unless implemented properly (See <a href="http://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf">Optimizing Parallel Reduction in CUDA</a>).</p><p>Knet implements <a href="../reference/#KnetArray-1">KnetArray</a> as a Julia data type that wraps GPU array pointers. KnetArray is based on the more standard <a href="https://github.com/JuliaGPU/CUDArt.jl">CudaArray</a> with a few important differences: (i) KnetArrays have a custom memory manager, similar to <a href="http://arrayfire.com">ArrayFire</a>, which reuse pointers garbage collected by Julia to reduce the number of GPU memory allocations, (ii) contiguous array ranges (e.g. <code>a[:,3:5]</code>) are handled as views with shared pointers instead of copies when possible, and (iii) a number of custom CUDA kernels written for KnetArrays implement element-wise, broadcasting, and scalar and vector reduction operations efficiently. As a result Knet allows users to implement their models using high-level code, yet be competitive in performance with other frameworks as demonstrated in the benchmarks section. Other GPU related Julia packages can be found in <a href="https://github.com/JuliaGPU">JuliaGPU</a>.</p><h3><a class="nav-anchor" id="AutoGrad-1" href="#AutoGrad-1">AutoGrad</a></h3><p>As we have seen, many common machine learning models can be expressed as differentiable programs that input parameters and data and output a scalar loss value. The loss value measures how close the model predictions are to desired values with the given parameters. Training a model can then be seen as an optimization problem: find the parameters that minimize the loss. Typically, a gradient based optimization algorithm is used for computational efficiency: the direction in the parameter space in which the loss reduction is maximum is given by the negative gradient of the loss with respect to the parameters. Thus gradient computations take a central stage in software frameworks for machine learning. In this section I will briefly outline existing gradient computation techniques and motivate the particular approach taken by Knet.</p><p>Computation of gradients in computer models is performed by four main methods <a href="https://arxiv.org/abs/1502.05767">(Baydin et al. 2015)</a>:</p><ul><li>manual differentiation (programming the derivatives)</li><li>numerical differentiation (using finite difference approximations)</li><li>symbolic differentiation (using expression manipulation)</li><li>automatic differentiation (detailed below)</li></ul><p>Manually taking derivatives and coding the result is labor intensive, error-prone, and all but impossible with complex deep learning models.  Numerical differentiation is simple: <span>$f&#39;(x)=(f(x+\epsilon)-f(x-\epsilon))/(2\epsilon)$</span> but impractical: the finite difference equation needs to be evaluated for each individual parameter, of which there are typically many. Pure symbolic differentiation using expression manipulation, as implemented in software such as Maxima, Maple, and Mathematica is impractical for different reasons: (i) it may not be feasible to express a machine learning model as a closed form mathematical expression, and (ii) the symbolic derivative can be exponentially larger than the model itself leading to inefficient run-time calculation. This leaves us with automatic differentiation.</p><p>Automatic differentiation is the idea of using symbolic derivatives only at the level of elementary operations, and computing the gradient of a compound function by applying the chain rule to intermediate numerical results. For example, pure symbolic differentiation of <span>$\sin^2(x)$</span> could give us <span>$2\sin(x)\cos(x)$</span> directly. Automatic differentiation would use the intermediate numerical values <span>$x_1=\sin(x)$</span>, <span>$x_2=x_1^2$</span> and the elementary derivatives <span>$dx_2/dx_1=2x_1$</span>, <span>$dx_1/dx=\cos(x)$</span> to compute the same answer without ever building a full gradient expression.</p><p>To implement automatic differentiation the target function needs to be decomposed into its elementary operations, a process similar to compilation. Most older machine learning frameworks (such as Theano, Torch, Caffe, Tensorflow and older versions of Knet prior to v0.8) compile models expressed in a restricted mini-language into a static computational graph of elementary operations that have pre-defined derivatives. There are two drawbacks with this approach: (i) the restricted mini-languages tend to have limited support for high-level language features such as conditionals, loops, helper functions, array indexing, etc. (e.g. the infamous <code>scan</code> operation in Theano) (ii) the sequence of elementary operations that unfold at run-time needs to be known in advance, and they are difficult to handle when the sequence is data dependent.</p><p>There is an alternative: high-level languages, like Julia and Python, already know how to decompose functions into their elementary operations. If we let the users define their models directly in a high-level language, then record the elementary operations during loss calculation at run-time, a dynamic computational graph can be constructed from the recorded operations. The cost of recording is not prohibitive: The table below gives cumulative times for elementary operations of an MLP with quadratic loss. Recording only adds 15% to the raw cost of the forward computation. Backpropagation roughly doubles the total time as expected.</p><table><tr><th>op</th><th>secs</th></tr><tr><td><code>a1=w1*x</code></td><td>0.67</td></tr><tr><td><code>a2=w2.+a1</code></td><td>0.71</td></tr><tr><td><code>a3=max.(0,a2)</code></td><td>0.75</td></tr><tr><td><code>a4=w3*a3</code></td><td>0.81</td></tr><tr><td><code>a5=w4.+a4</code></td><td>0.85</td></tr><tr><td><code>a6=a5-y</code></td><td>0.89</td></tr><tr><td><code>a7=sum(abs2,a6)</code></td><td>1.18</td></tr><tr><td>+recording</td><td>1.33</td></tr><tr><td>+backprop</td><td>2.79</td></tr></table><p>This is the approach taken by the popular <a href="https://github.com/HIPS/autograd">autograd</a> Python package and its Julia port <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad.jl</a> used by Knet. Recently, other machine learning frameworks have been adapting dynamic computational graphs: <a href="http://docs.chainer.org/en/stable/index.html">Chainer</a>, <a href="https://arxiv.org/abs/1701.03980">DyNet</a>, <a href="https://github.com/pytorch/pytorch">PyTorch</a>, <a href="https://research.googleblog.com/2017/02/announcing-tensorflow-fold-deep.html">TensorFlow Fold</a>. Related Julia projects include <a href="https://github.com/FLuxML">Flux</a> and <a href="https://github.com/JuliaDiff">JuliaDiff</a>.</p><p>In AutoGrad, parameters of interest are boxed by the <code>Param</code> type. <code>y = @diff f(x)</code> returns a struct such that <code>value(y)</code> gives <code>f(x)</code> (which should be a scalar), <code>params(y)</code> gives the list of parameters that took place in the computation of <code>f(x)</code>, and <code>grad(y,p)</code> gives the gradient of <code>f(x)</code> with respect to parameter <code>p</code>.  In a <code>@diff</code> context, the elementary operations in <code>f</code> are overloaded to record their actions and output boxed answers when their inputs are boxed. The sequence of recorded operations is then used to compute gradients. Derivatives can be defined independently for each method of a function (determined by argument types) making full use of Julia&#39;s multiple dispatch. New elementary operations and derivatives can be defined concisely using Julia&#39;s macro and meta-programming facilities. See <a href="https://github.com/denizyuret/AutoGrad.jl">AutoGrad.jl</a> for details.</p><footer><hr/><a class="previous" href="../install/"><span class="direction">Previous</span><span class="title">Setting up Knet</span></a><a class="next" href="../reference/"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
