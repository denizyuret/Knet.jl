<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Knet.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Knet.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../install/">Setting up Knet</a></li><li><a class="tocitem" href="../tutorial/">Introduction to Knet</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#AutoGrad"><span>AutoGrad</span></a></li><li><a class="tocitem" href="#KnetArray"><span>KnetArray</span></a></li><li><a class="tocitem" href="#File-I/O"><span>File I/O</span></a></li><li><a class="tocitem" href="#Parameter-initialization"><span>Parameter initialization</span></a></li><li><a class="tocitem" href="#Activation-functions"><span>Activation functions</span></a></li><li><a class="tocitem" href="#Loss-functions"><span>Loss functions</span></a></li><li><a class="tocitem" href="#Convolution-and-Pooling"><span>Convolution and Pooling</span></a></li><li><a class="tocitem" href="#Recurrent-neural-networks"><span>Recurrent neural networks</span></a></li><li><a class="tocitem" href="#Batch-Normalization"><span>Batch Normalization</span></a></li><li><a class="tocitem" href="#Model-optimization"><span>Model optimization</span></a></li><li><a class="tocitem" href="#Hyperparameter-optimization"><span>Hyperparameter optimization</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#AutoGrad-(advanced)"><span>AutoGrad (advanced)</span></a></li><li><a class="tocitem" href="#Per-parameter-optimization-(advanced)"><span>Per-parameter optimization (advanced)</span></a></li><li><a class="tocitem" href="#Function-Index"><span>Function Index</span></a></li></ul></li></ul></li><li><span class="tocitem">Textbook</span><ul><li><a class="tocitem" href="../backprop/">Backpropagation and SGD</a></li><li><a class="tocitem" href="../softmax/">Softmax Classification</a></li><li><a class="tocitem" href="../mlp/">Multilayer Perceptrons</a></li><li><a class="tocitem" href="../cnn/">Convolutional Neural Networks</a></li><li><a class="tocitem" href="../rnn/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../rl/">Reinforcement Learning</a></li><li><a class="tocitem" href="../opt/">Optimization</a></li><li><a class="tocitem" href="../gen/">Generalization</a></li><li><a class="tocitem" href="../nce/">Noise Contrastive Estimation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p><strong>Contents</strong></p><ul><li><a href="#Reference">Reference</a></li><ul><li><a href="#AutoGrad">AutoGrad</a></li><li><a href="#KnetArray">KnetArray</a></li><li><a href="#File-I/O">File I/O</a></li><li><a href="#Parameter-initialization">Parameter initialization</a></li><li><a href="#Activation-functions">Activation functions</a></li><li><a href="#Loss-functions">Loss functions</a></li><li><a href="#Convolution-and-Pooling">Convolution and Pooling</a></li><li><a href="#Recurrent-neural-networks">Recurrent neural networks</a></li><li><a href="#Batch-Normalization">Batch Normalization</a></li><li><a href="#Model-optimization">Model optimization</a></li><li><a href="#Hyperparameter-optimization">Hyperparameter optimization</a></li><li><a href="#Utilities">Utilities</a></li><li><a href="#AutoGrad-(advanced)">AutoGrad (advanced)</a></li><li><a href="#Per-parameter-optimization-(advanced)">Per-parameter optimization (advanced)</a></li><li><a href="#Function-Index">Function Index</a></li></ul></ul><h2 id="AutoGrad"><a class="docs-heading-anchor" href="#AutoGrad">AutoGrad</a><a id="AutoGrad-1"></a><a class="docs-heading-anchor-permalink" href="#AutoGrad" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.AutoGrad" href="#Knet.AutoGrad"><code>Knet.AutoGrad</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Usage:</p><pre><code class="language-none">x = Param([1,2,3])          # The user declares parameters with `Param`
y = @diff sum(x .* x)       # computes gradients using `@diff`
grad(y,x) =&gt; [2,4,6]        # looks up the gradient of a parameter with `grad`</code></pre><p><code>Param(x)</code> returns a struct that acts like <code>x</code> but marks it as a parameter you want to compute gradients with respect to.</p><p><code>@diff expr</code> evaluates an expression and returns a struct that contains its value (which should be a scalar) and gradients with respect to the <code>Param</code>s used in the computation.</p><p><code>grad(y, x)</code> returns the gradient of a <code>@diff</code> result <code>y</code> with respect to any parameter <code>x::Param</code>. (<code>nothing</code> may be returned if the gradient is 0).</p><p><code>value(x)</code> returns the value associated with <code>x</code> if <code>x</code> is a <code>Param</code> or the output of <code>@diff</code>, otherwise returns <code>x</code>.</p><p><code>params(x)</code> returns an iterator of <code>Param</code>s found by a recursive search of object <code>x</code>, which is typically a model or a <code>@diff</code> result.</p><p>Alternative usage:</p><pre><code class="language-none">x = [1 2 3]
f(x) = sum(x .* x)
f(x) =&gt; 14
grad(f)(x) =&gt; [2 4 6]
gradloss(f)(x) =&gt; ([2 4 6], 14)</code></pre><p>Given a scalar valued function <code>f</code>, <code>grad(f,argnum=1)</code> returns another function <code>g</code> which takes the same inputs as <code>f</code> and returns the gradient of the output with respect to the argnum&#39;th argument. <code>gradloss</code> is similar except the resulting function also returns f&#39;s output.</p></div></section></article><h2 id="KnetArray"><a class="docs-heading-anchor" href="#KnetArray">KnetArray</a><a id="KnetArray-1"></a><a class="docs-heading-anchor-permalink" href="#KnetArray" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.KnetArrays.KnetArray" href="#Knet.KnetArrays.KnetArray"><code>Knet.KnetArrays.KnetArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KnetArray{T}(undef,dims)
KnetArray(a::AbstractArray)
Array(k::KnetArray)</code></pre><p>Container for GPU arrays that supports most of the AbstractArray interface.  The constructor allocates a KnetArray in the currently active device, as specified by <code>CUDA.device()</code>. KnetArrays and Arrays can be converted to each other as shown above, which involves copying to and from the GPU memory.  Only Float32/64 KnetArrays are fully supported.</p><p>KnetArrays use the CUDA.jl package for allocation and some operations. Currently some of the custom CUDA kernels that implement elementwise, broadcasting, and reduction operations for KnetArrays work faster. Once these are improved in CUDA.jl, KnetArrays will be retired.</p><p><strong>Supported functions:</strong></p><ul><li><p>Indexing: getindex, setindex! with the following index types:</p><ul><li>1-D: Real, Colon, OrdinalRange, AbstractArray{Real}, AbstractArray{Bool}, CartesianIndex, AbstractArray{CartesianIndex}, EmptyArray, KnetArray{Int32} (low level), KnetArray{0/1} (using float for BitArray) (1-D includes linear indexing of multidimensional arrays)</li><li>2-D: (Colon,Union{Real,Colon,OrdinalRange,AbstractVector{Real},AbstractVector{Bool},KnetVector{Int32}}), (Union{Real,AbstractUnitRange,Colon}...) (in any order)</li><li>N-D: (Real...)</li></ul></li><li><p>Array operations: ==, !=, adjoint, argmax, argmin, cat, convert, copy, copyto!, deepcopy, display, eachindex, eltype, endof, fill!, findmax, findmin, first, hcat, isapprox, isempty, length, ndims, one, ones, permutedims, pointer, rand!, randn!, reshape, similar, size, stride, strides, summary, transpose, vcat, vec, zero.  (Boolean operators generate outputs with same type as inputs; no support for KnetArray{Bool}.)</p></li><li><p>Unary functions with broadcasting: -, abs, abs2, acos, acosh, asin, asinh, atan, atanh, cbrt, ceil, cos, cosh, cospi, digamma, erf, erfc, erfcinv, erfcx, erfinv, exp, exp10, exp2, expm1, floor, gamma, lgamma, log, log10, log1p, log2, loggamma, one, round, sign, sin, sinh, sinpi, sqrt, tan, tanh, trigamma, trunc, zero</p></li><li><p>Binary functions with broadcasting: !=, *, +, -, /, &lt;, &lt;=, ==, &gt;, &gt;=, ^, max, min</p></li><li><p>Reduction operators: maximum, minimum, prod, sum</p></li><li><p>Statistics: mean, std, stdm, var, varm</p></li><li><p>Linear algebra: (*), axpy!, lmul!, norm, rmul!</p></li><li><p>Knet extras: batchnorm, bce, bmm, cat1d, conv4, cpucopy, deconv4, dropout, elu, gpucopy, logistic, logp, logsoftmax, logsumexp, mat, nll, pool, relu, RNN, selu, sigm, softmax, unpool (Only 4D/5D, Float32/64 KnetArrays support conv4, pool, deconv4, unpool)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/knetarrays/karray.jl#L8-L53">source</a></section></article><h2 id="File-I/O"><a class="docs-heading-anchor" href="#File-I/O">File I/O</a><a id="File-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#File-I/O" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Knet.save</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Knet.load</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Knet.@save</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Knet.@load</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Parameter-initialization"><a class="docs-heading-anchor" href="#Parameter-initialization">Parameter initialization</a><a id="Parameter-initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-initialization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.param" href="#Knet.Train20.param"><code>Knet.Train20.param</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">param(array; atype)
param(dims...; init, atype)
param0(dims...; atype)</code></pre><p>The first form returns <code>Param(atype(array))</code>.</p><p>The second form Returns a randomly initialized <code>Param(atype(init(dims...)))</code>.  </p><p>The third form <code>param0</code> is an alias for <code>param(dims...; init=zeros)</code>.</p><p>By default, <code>init</code> is <code>xavier_uniform</code> and <code>atype</code> is <code>Knet.atype()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/param.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.xavier" href="#Knet.Train20.xavier"><code>Knet.Train20.xavier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xavier_uniform(a...; gain=1)
xavier(a...; gain=1)</code></pre><p>Return uniform random weights in the range <code>± gain * sqrt(6 / (fanin + fanout))</code>.  The <code>a</code> arguments are passed to <code>rand</code> to specify type and dimensions.  See (<a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf">Glorot and Bengio 2010</a>) or the <a href="https://pytorch.org/docs/stable/nn.init.html#torch.nn.init.xavier_uniform_">PyTorch docs</a> for a description.  The function implements equation (16) of the referenced paper. Also known as Glorot initialization. The function <code>xavier</code> is an alias for <code>xavier_uniform</code>. See also <code>xavier_normal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/distributions.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.xavier_uniform" href="#Knet.Train20.xavier_uniform"><code>Knet.Train20.xavier_uniform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xavier_uniform(a...; gain=1)
xavier(a...; gain=1)</code></pre><p>Return uniform random weights in the range <code>± gain * sqrt(6 / (fanin + fanout))</code>.  The <code>a</code> arguments are passed to <code>rand</code> to specify type and dimensions.  See (<a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf">Glorot and Bengio 2010</a>) or the <a href="https://pytorch.org/docs/stable/nn.init.html#torch.nn.init.xavier_uniform_">PyTorch docs</a> for a description.  The function implements equation (16) of the referenced paper. Also known as Glorot initialization. The function <code>xavier</code> is an alias for <code>xavier_uniform</code>. See also <code>xavier_normal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/distributions.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.xavier_normal" href="#Knet.Train20.xavier_normal"><code>Knet.Train20.xavier_normal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xavier_normal(a...; gain=1)</code></pre><p>Return normal distributed random weights with mean 0 and std <code>gain * sqrt(2 / (fanin + fanout))</code>.  The <code>a</code> arguments are passed to <code>rand</code>.  See (<a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf">Glorot and Bengio 2010</a>) and <a href="https://pytorch.org/docs/stable/nn.init.html#torch.nn.init.xavier_normal_">PyTorch docs</a> for a description. Also known as Glorot initialization. See also <code>xavier_uniform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/distributions.jl#L57-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.gaussian" href="#Knet.Train20.gaussian"><code>Knet.Train20.gaussian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gaussian(a...; mean=0.0, std=0.01)</code></pre><p>Return a Gaussian array with a given mean and standard deviation.  The <code>a</code> arguments are passed to <code>randn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/distributions.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.bilinear" href="#Knet.Train20.bilinear"><code>Knet.Train20.bilinear</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Bilinear interpolation filter weights; used for initializing deconvolution layers.</p><p>Adapted from https://github.com/shelhamer/fcn.berkeleyvision.org/blob/master/surgery.py#L33</p><p>Arguments:</p><p><code>T</code> : Data Type</p><p><code>fw</code>: Width upscale factor</p><p><code>fh</code>: Height upscale factor</p><p><code>IN</code>: Number of input filters</p><p><code>ON</code>: Number of output filters</p><p>Example usage:</p><p>w = bilinear(Float32,2,2,128,128)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/distributions.jl#L88-L111">source</a></section></article><h2 id="Activation-functions"><a class="docs-heading-anchor" href="#Activation-functions">Activation functions</a><a id="Activation-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Activation-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.elu" href="#Knet.Ops20.elu"><code>Knet.Ops20.elu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elu(x)</code></pre><p>Return <code>(x &gt; 0 ? x : exp(x)-1)</code>.</p><p>Reference: Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs) (https://arxiv.org/abs/1511.07289).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/activation.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.relu" href="#Knet.Ops20.relu"><code>Knet.Ops20.relu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relu(x)</code></pre><p>Return <code>max(0,x)</code>.</p><p>References: </p><ul><li><a href="https://icml.cc/Conferences/2010/abstracts.html#432">Nair and Hinton, 2010</a>. Rectified Linear Units Improve Restricted Boltzmann Machines. ICML.</li><li><a href="http://proceedings.mlr.press/v15/glorot11a">Glorot, Bordes and Bengio, 2011</a>. Deep Sparse Rectifier Neural Networks. AISTATS.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/activation.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.selu" href="#Knet.Ops20.selu"><code>Knet.Ops20.selu</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">selu(x)</code></pre><p>Return <code>λ01 * (x &gt; 0 ? x : α01 * (exp(x)-1))</code> where <code>λ01=1.0507009873554805</code> and <code>α01=1.6732632423543778</code>.</p><p>Reference: Self-Normalizing Neural Networks (https://arxiv.org/abs/1706.02515).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/activation.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.sigm" href="#Knet.Ops20.sigm"><code>Knet.Ops20.sigm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sigm(x)</code></pre><p>Return <code>1/(1+exp(-x))</code>.</p><p>Reference: Numerically stable sigm implementation from http://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/activation.jl#L48-L54">source</a></section></article><h2 id="Loss-functions"><a class="docs-heading-anchor" href="#Loss-functions">Loss functions</a><a id="Loss-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Loss-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.accuracy" href="#Knet.Ops20.accuracy"><code>Knet.Ops20.accuracy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accuracy(scores, labels; dims=1, average=true)</code></pre><p>Given an unnormalized <code>scores</code> matrix and an <code>Integer</code> array of correct <code>labels</code>, return the ratio of instances where the correct label has the maximum score. <code>dims=1</code> means instances are in columns, <code>dims=2</code> means instances are in rows. Use <code>average=false</code> to return the pair (ncorrect,count) instead of the ratio (ncorrect/count). The valid labels should be integers in the range <code>1:numclasses</code>, if <code>labels[i] == 0</code>, instance i is skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/loss.jl#L44-L53">source</a></section><section><div><pre><code class="language-none">accuracy(model; data, dims=1, average=true, o...)</code></pre><p>Compute the number of correct predictions of a model over a dataset:</p><pre><code class="language-none">accuracy(model(inputs; kwargs...), labels; dims) for (inputs,labels) in data</code></pre><p>and return <code>(ncorrect/count)</code> if <code>average=true</code> or <code>(ncorrect,count)</code> if <code>average=false</code> where <code>count</code> is the number instances not skipped (instances with <code>label==0</code> are skipped) and <code>ncorrect</code> is the number of them correctly labeled by the model.</p><p>The <code>model</code> should be a function returning scores given inputs, and data should be an iterable of <code>(inputs,labels)</code> pairs. The valid labels should be integers in the range <code>1:numclasses</code>, if <code>labels[i] == 0</code>, instance i is skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/loss.jl#L169-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.bce" href="#Knet.Ops20.bce"><code>Knet.Ops20.bce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bce(scores, labels; average=true)</code></pre><p>Computes binary cross entropy loss given predicted unnormalized scores and answer labels for a binary prediction task. Label values should be in {0,1}. Scores are unrestricted and will be converted to probabilities using</p><pre><code class="language-none">probs = 1 ./ (1 .+ exp.(-scores))</code></pre><p>The loss calculated is</p><pre><code class="language-none">-(labels .* log.(probs) .+ (1 .- labels) .* log.(1 .- probs))</code></pre><p>The return value is <code>(total/count)</code> if <code>average=true</code> and <code>(total,count)</code> if <code>average=false</code> where <code>count</code> is the number of instances and <code>total</code> is their total loss.</p><p>See also <code>logistic</code> which computes the same loss with {-1,1} labels.</p><p>Reference: https://towardsdatascience.com/nothing-but-numpy-understanding-creating-binary-classification-neural-networks-with-e746423c8d5c</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/loss.jl#L87-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.logistic" href="#Knet.Ops20.logistic"><code>Knet.Ops20.logistic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logistic(scores, labels; average=true)</code></pre><p>Computes logistic loss given predicted unnormalized scores and answer labels for a binary prediction task.</p><pre><code class="language-none">log.(1 .+ exp.(-labels .* scores))</code></pre><p>Label values should be {-1,1}. Scores are unrestricted.  The return value is <code>(total/count)</code> if <code>average=true</code> and <code>(total,count)</code> if <code>average=false</code> where <code>count</code> is the number of instances and <code>total</code> is their total loss.</p><p>See also <code>bce</code> which computes the same loss with {0,1} labels.</p><p>Reference: https://towardsdatascience.com/nothing-but-numpy-understanding-creating-binary-classification-neural-networks-with-e746423c8d5c</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/loss.jl#L65-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.logp" href="#Knet.Ops20.logp"><code>Knet.Ops20.logp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">softmax(x; dims=:)
logsoftmax(x; dims=:)</code></pre><p>Treat entries in <code>x</code> as as unnormalized log probabilities and return normalized (log) probabilities, i.e. </p><pre><code class="language-none">softmax(x; dims) = exp.(x) ./ sum(exp.(x); dims=dims)
logsoftmax(x; dims) = x .- log.(sum(exp.(x); dims=dims))</code></pre><p>For numerical stability <code>x = x .- maximum(x,dims=dims)</code> is performed before exponentiation.</p><p><code>dims</code> is an optional argument, if not specified the normalization is over the whole <code>x</code>, otherwise the normalization is performed over the given dimensions.  In particular, if <code>x</code> is a matrix, <code>dims=1</code> normalizes columns of <code>x</code> and <code>dims=2</code> normalizes rows of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/softmax.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.logsoftmax" href="#Knet.Ops20.logsoftmax"><code>Knet.Ops20.logsoftmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">softmax(x; dims=:)
logsoftmax(x; dims=:)</code></pre><p>Treat entries in <code>x</code> as as unnormalized log probabilities and return normalized (log) probabilities, i.e. </p><pre><code class="language-none">softmax(x; dims) = exp.(x) ./ sum(exp.(x); dims=dims)
logsoftmax(x; dims) = x .- log.(sum(exp.(x); dims=dims))</code></pre><p>For numerical stability <code>x = x .- maximum(x,dims=dims)</code> is performed before exponentiation.</p><p><code>dims</code> is an optional argument, if not specified the normalization is over the whole <code>x</code>, otherwise the normalization is performed over the given dimensions.  In particular, if <code>x</code> is a matrix, <code>dims=1</code> normalizes columns of <code>x</code> and <code>dims=2</code> normalizes rows of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/softmax.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.logsumexp" href="#Knet.Ops20.logsumexp"><code>Knet.Ops20.logsumexp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logsumexp(x;dims=:)</code></pre><p>Compute <code>log(sum(exp(x);dims))</code> in a numerically stable manner.</p><p><code>dims</code> is an optional argument, if not specified the summation is over the whole <code>x</code>, otherwise the summation is performed over the given dimensions.  In particular if <code>x</code> is a matrix, <code>dims=1</code> sums columns of <code>x</code> and <code>dims=2</code> sums rows of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/softmax.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.nll" href="#Knet.Ops20.nll"><code>Knet.Ops20.nll</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nll(scores, labels; dims=1, average=true)</code></pre><p>Return the negative log likelihood for a single batch of data given an unnormalized <code>scores</code> matrix and an <code>Integer</code> array of correct <code>labels</code>. The <code>scores</code> matrix should have size <code>(classes,instances)</code> if <code>dims=1</code> or <code>(instances,classes)</code> if <code>dims=2</code>. <code>labels[i]</code> should be in <code>1:classes</code> to indicate the correct class for instance i, or 0 to skip instance i.</p><p>The return value is <code>(total/count)</code> if <code>average=true</code> and <code>(total,count)</code> if <code>average=false</code> where <code>count</code> is the number of instances not skipped (i.e. <code>label != 0</code>) and <code>total</code> is their total negative log likelihood.</p><p><strong>Example</strong></p><p>Let&#39;s assume that there are three classes (cat, dog, ostrich) and just 2 instances with the unnormalized score <code>scores[:,1]</code> and <code>scores[:,2]</code> respectively. The first instance is actually a cat and the second instance a dog:</p><pre><code class="language-none">scores = [12.2    0.3;
           2.0   21.5;
           0.0  -21.0]
labels = [1, 2]
nll(scores,labels)
# returns 2.1657e-5</code></pre><p>The probabilites are derived from the scores and the negative log-probabilities corresponding to the labels are averaged:</p><pre><code class="language-none">probabilites = exp.(scores) ./ sum(exp.(scores),dims=1)
-(log(probabilites[labels[1],1]) + log(probabilites[labels[2],2]))/2
# returns 2.1657e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/loss.jl#L4-L36">source</a></section><section><div><pre><code class="language-none">nll(model; data, dims=1, average=true, o...)</code></pre><p>Compute the negative log likelihood for a model over a dataset:</p><pre><code class="language-none">nll(model(inputs; kwargs...), labels; dims) for (inputs,labels) in data</code></pre><p>and return <code>(total/count)</code> if <code>average=true</code> or <code>(total,count)</code> if <code>average=false</code> where <code>count</code> is the number of instances not skipped (instances with <code>label==0</code> are skipped) and <code>total</code> is their total negative log likelihood.</p><p>The <code>model</code> should be a function returning scores given inputs, and data should be an iterable of <code>(inputs,labels)</code> pairs. The valid labels should be integers in the range <code>1:numclasses</code>, if <code>labels[i] == 0</code>, instance i is skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/loss.jl#L143-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.softmax" href="#Knet.Ops20.softmax"><code>Knet.Ops20.softmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">softmax(x; dims=:)
logsoftmax(x; dims=:)</code></pre><p>Treat entries in <code>x</code> as as unnormalized log probabilities and return normalized (log) probabilities, i.e. </p><pre><code class="language-none">softmax(x; dims) = exp.(x) ./ sum(exp.(x); dims=dims)
logsoftmax(x; dims) = x .- log.(sum(exp.(x); dims=dims))</code></pre><p>For numerical stability <code>x = x .- maximum(x,dims=dims)</code> is performed before exponentiation.</p><p><code>dims</code> is an optional argument, if not specified the normalization is over the whole <code>x</code>, otherwise the normalization is performed over the given dimensions.  In particular, if <code>x</code> is a matrix, <code>dims=1</code> normalizes columns of <code>x</code> and <code>dims=2</code> normalizes rows of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/softmax.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.zeroone" href="#Knet.Ops20.zeroone"><code>Knet.Ops20.zeroone</code></a> — <span class="docstring-category">Function</span></header><section><div><p>zeroone loss is equal to 1 - accuracy</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/loss.jl#L231">source</a></section></article><h2 id="Convolution-and-Pooling"><a class="docs-heading-anchor" href="#Convolution-and-Pooling">Convolution and Pooling</a><a id="Convolution-and-Pooling-1"></a><a class="docs-heading-anchor-permalink" href="#Convolution-and-Pooling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.conv4" href="#Knet.Ops20.conv4"><code>Knet.Ops20.conv4</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">conv4(w, x; kwargs...)</code></pre><p>Execute convolutions or cross-correlations using filters specified with <code>w</code> over tensor <code>x</code>.</p><p>If <code>w</code> has dimensions <code>(W1,W2,...,Cx,Cy)</code> and <code>x</code> has dimensions <code>(X1,X2,...,Cx,N)</code>, the result <code>y</code> will have dimensions <code>(Y1,Y2,...,Cy,N)</code> where <code>Cx</code> is the number of input channels, <code>Cy</code> is the number of output channels, <code>N</code> is the number of instances, and <code>Wi,Xi,Yi</code> are spatial dimensions with <code>Yi</code> determined by:</p><pre><code class="language-none">Yi = 1 + floor((Xi + 2*padding[i] - ((Wi-1)*dilation[i] + 1)) / stride[i])</code></pre><p><code>padding</code>, <code>stride</code> and <code>dilation</code> are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.</p><p><strong>Keywords</strong></p><ul><li><code>padding=0</code>: the number of extra zeros implicitly concatenated at the start and end of each dimension.</li><li><code>stride=1</code>: the number of elements to slide to reach the next filtering window.</li><li><code>dilation=1</code>: dilation factor for each dimension.</li><li><code>mode=0</code>: 0 for convolution and 1 for cross-correlation (which flips the filter).</li><li><code>alpha=1</code>: can be used to scale the result.</li><li><code>group=1</code>: can be used to perform grouped convolutions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/conv.jl#L7-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.deconv4" href="#Knet.Ops20.deconv4"><code>Knet.Ops20.deconv4</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deconv4(w, x; kwargs...)</code></pre><p>Simulate 4-D deconvolution by using <em>transposed convolution</em> operation. Its forward pass is equivalent to backward pass of a convolution (gradients with respect to input tensor). Likewise, its backward pass (gradients with respect to input tensor) is equivalent to forward pass of a convolution. Since it swaps forward and backward passes of convolution operation, padding and stride options belong to output tensor. See <a href="https://arxiv.org/abs/1603.07285">this report</a> for further explanation.</p><p>If <code>w</code> has dimensions <code>(W1,W2,...,Cy,Cx)</code> and <code>x</code> has dimensions <code>(X1,X2,...,Cx,N)</code>, the result <code>y=deconv4(w,x)</code> will have dimensions <code>(Y1,Y2,...,Cy,N)</code> where</p><pre><code class="language-none">Yi = (Xi - 1)*stride[i] + ((Wi-1)*dilation[i] + 1) - 2*padding[i]</code></pre><p>Here Cx is the number of x channels, Cy is the number of y channels, N is the number of instances, and Wi,Xi,Yi are spatial dimensions. Padding and stride are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.</p><p><strong>Keywords</strong></p><ul><li><code>padding=0</code>: the number of extra zeros implicitly concatenated at the start and at the end of each dimension.</li><li><code>stride=1</code>: the number of elements to slide to reach the next filtering window.</li><li><code>mode=0</code>: 0 for convolution and 1 for cross-correlation.</li><li><code>alpha=1</code>: can be used to scale the result.</li><li><code>handle</code>: handle to a previously created cuDNN context. Defaults to a Knet allocated handle.</li><li><code>group=1</code>: can be used to perform grouped convolutions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/conv.jl#L71-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.pool" href="#Knet.Ops20.pool"><code>Knet.Ops20.pool</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pool(x; kwargs...)</code></pre><p>Compute pooling of input values (i.e., the maximum or average of several adjacent values) to produce an output with smaller height and/or width.</p><p>If <code>x</code> has dimensions <code>(X1,X2,...,Cx,N)</code>, the result <code>y</code> will have dimensions <code>(Y1,Y2,...,Cx,N)</code> where</p><pre><code class="language-none">Yi=1+floor((Xi+2*padding[i]-window[i])/stride[i])</code></pre><p>Here <code>Cx</code> is the number of input channels, <code>N</code> is the number of instances, and <code>Xi,Yi</code> are spatial dimensions.  <code>window</code>, <code>padding</code> and <code>stride</code> are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.</p><p><strong>Keywords:</strong></p><ul><li><code>window=2</code>: the pooling window size for each dimension.</li><li><code>padding=0</code>: the number of extra zeros implicitly concatenated at the start and at the end of each dimension.</li><li><code>stride=window</code>: the number of elements to slide to reach the next pooling window.</li><li><code>mode=0</code>: 0 for max, 1 for average including padded values, 2 for average excluding padded values, 3 for deterministic max.</li><li><code>maxpoolingNanOpt=1</code>: Nan numbers are not propagated if 0, they are propagated if 1.</li><li><code>alpha=1</code>: can be used to scale the result.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/conv.jl#L109-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.unpool" href="#Knet.Ops20.unpool"><code>Knet.Ops20.unpool</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unpool(x; o...)</code></pre><p>Perform the reverse of pooling: <code>x == pool(unpool(x;o...); o...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/conv.jl#L186-L190">source</a></section></article><h2 id="Recurrent-neural-networks"><a class="docs-heading-anchor" href="#Recurrent-neural-networks">Recurrent neural networks</a><a id="Recurrent-neural-networks-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrent-neural-networks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.RNN" href="#Knet.Ops20.RNN"><code>Knet.Ops20.RNN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">rnn = RNN(inputSize, hiddenSize; opts...)
rnn(x; batchSizes) =&gt; y
rnn.h, rnn.c  # hidden and cell states</code></pre><p><code>RNN</code> returns a callable RNN object <code>rnn</code>. Given a minibatch of sequences <code>x</code>, <code>rnn(x)</code> returns <code>y</code>, the hidden states of the final layer for each time step. <code>rnn.h</code> and <code>rnn.c</code> fields can be used to set the initial hidden states and read the final hidden states of all layers.  Note that the final time step of <code>y</code> always contains the final hidden state of the last layer, equivalent to <code>rnn.h</code> for a single layer network.</p><p><strong>Dimensions:</strong> The input <code>x</code> can be 1, 2, or 3 dimensional and <code>y</code> will have the same number of dimensions as <code>x</code>. size(x)=(X,[B,T]) and size(y)=(H/2H,[B,T]) where X is inputSize, B is batchSize, T is seqLength, H is hiddenSize, 2H is for bidirectional RNNs. By default a 1-D <code>x</code> represents a single instance for a single time step, a 2-D <code>x</code> represents a single minibatch for a single time step, and a 3-D <code>x</code> represents a sequence of identically sized minibatches for multiple time steps. The output <code>y</code> gives the hidden state (of the final layer for multi-layer RNNs) for each time step. The fields <code>rnn.h</code> and <code>rnn.c</code> represent the hidden states of all layers in a single time step and have size (H,B,L/2L) where L is numLayers and 2L is for bidirectional RNNs.</p><p><strong>batchSizes:</strong> If <code>batchSizes=nothing</code> (default), all sequences in a minibatch are assumed to be the same length. If <code>batchSizes</code> is an array of (non-increasing) integers, it gives us the batch size for each time step (allowing different sequences in the minibatch to have different lengths). In this case <code>x</code> will typically be 2-D with the second dimension representing variable size batches for time steps. If <code>batchSizes</code> is used, <code>sum(batchSizes)</code> should equal <code>length(x) ÷ size(x,1)</code>. When the batch size is different in every time step, hidden states will have size (H,B,L/2L) where B is always the size of the first (largest) minibatch.</p><p><strong>Hidden states:</strong> The hidden and cell states are kept in <code>rnn.h</code> and <code>rnn.c</code> fields (the cell state is only used by LSTM). They can be initialized during construction using the <code>h</code> and <code>c</code> keyword arguments, or modified later by direct assignment. Valid values are <code>nothing</code> (default), <code>0</code>, or an array of the right type and size possibly wrapped in a <code>Param</code>. If the value is <code>nothing</code> the initial state is assumed to be zero and the final state is discarded keeping the value <code>nothing</code>. If the value is <code>0</code> the initial state is assumed to be zero and <code>0</code> is replaced by the final state on return. If the value is a valid state, it is used as the initial state and is replaced by the final state on return.</p><p>In a differentiation context the returned final hidden states will be wrapped in <code>Result</code> types. This is necessary if the same RNN object is to be called multiple times in a single iteration. Between iterations (i.e. after diff/update) the hidden states need to be unboxed with e.g. <code>rnn.h = value(rnn.h)</code> to prevent spurious dependencies. This happens automatically during the backward pass for GPU RNNs but needs to be done manually for CPU RNNs. See the <a href="https://github.com/denizyuret/Knet.jl/blob/master/tutorial/80.charlm.ipynb">CharLM Tutorial</a> for an example.</p><p><strong>Keyword arguments for RNN:</strong></p><ul><li><code>h=nothing</code>: Initial hidden state.</li><li><code>c=nothing</code>: Initial cell state.</li><li><code>rnnType=:lstm</code> Type of RNN: One of :relu, :tanh, :lstm, :gru.</li><li><code>numLayers=1</code>: Number of RNN layers.</li><li><code>bidirectional=false</code>: Create a bidirectional RNN if <code>true</code>.</li><li><code>dropout=0</code>: Dropout probability. Applied to input and between layers.</li><li><code>skipInput=false</code>: Do not multiply the input with a matrix if <code>true</code>.</li><li><code>algo=0</code>: Algorithm to use, see CUDNN docs for details.</li><li><code>seed=0</code>: Random number seed for dropout. Uses <code>time()</code> if 0.</li><li><code>winit=xavier</code>: Weight initialization method for matrices.</li><li><code>binit=zeros</code>: Weight initialization method for bias vectors.</li><li><code>finit=ones</code>: Weight initialization method for the bias of forget gates.</li><li><code>atype=Knet.atype()</code>: array type for model weights.</li></ul><p><strong>Formulas:</strong> RNNs compute the output h[t] for a given iteration from the recurrent input h[t-1] and the previous layer input x[t] given matrices W, R and biases bW, bR from the following equations:</p><p><code>:relu</code> and <code>:tanh</code>: Single gate RNN with activation function f:</p><pre><code class="language-none">h[t] = f(W * x[t] .+ R * h[t-1] .+ bW .+ bR)</code></pre><p><code>:gru</code>: Gated recurrent unit:</p><pre><code class="language-none">i[t] = sigm(Wi * x[t] .+ Ri * h[t-1] .+ bWi .+ bRi) # input gate
r[t] = sigm(Wr * x[t] .+ Rr * h[t-1] .+ bWr .+ bRr) # reset gate
n[t] = tanh(Wn * x[t] .+ r[t] .* (Rn * h[t-1] .+ bRn) .+ bWn) # new gate
h[t] = (1 - i[t]) .* n[t] .+ i[t] .* h[t-1]</code></pre><p><code>:lstm</code>: Long short term memory unit with no peephole connections:</p><pre><code class="language-none">i[t] = sigm(Wi * x[t] .+ Ri * h[t-1] .+ bWi .+ bRi) # input gate
f[t] = sigm(Wf * x[t] .+ Rf * h[t-1] .+ bWf .+ bRf) # forget gate
o[t] = sigm(Wo * x[t] .+ Ro * h[t-1] .+ bWo .+ bRo) # output gate
n[t] = tanh(Wn * x[t] .+ Rn * h[t-1] .+ bWn .+ bRn) # new gate
c[t] = f[t] .* c[t-1] .+ i[t] .* n[t]               # cell output
h[t] = o[t] .* tanh(c[t])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/rnn.jl#L6-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.rnnparam" href="#Knet.Ops20.rnnparam"><code>Knet.Ops20.rnnparam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rnnparam(r::RNN, layer, id, param)</code></pre><p>Return a single weight matrix or bias vector as a slice of RNN weights.</p><p>Valid <code>layer</code> values:</p><ul><li>For unidirectional RNNs 1:numLayers</li><li>For bidirectional RNNs 1:2*numLayers, forw and back layers alternate.</li></ul><p>Valid <code>id</code> values:</p><ul><li>For RELU and TANH RNNs, input = 1, hidden = 2.</li><li>For GRU reset = 1,4; update = 2,5; newmem = 3,6; 1:3 for input, 4:6 for hidden</li><li>For LSTM inputgate = 1,5; forget = 2,6; newmem = 3,7; output = 4,8; 1:4 for input, 5:8 for hidden</li></ul><p>Valid <code>param</code> values:</p><ul><li>Return the weight matrix (transposed!) if <code>param==1</code>.</li><li>Return the bias vector if <code>param==2</code>.</li></ul><p>The effect of skipInput: Let I=1 for RELU/TANH, 1:3 for GRU, 1:4 for LSTM</p><ul><li>For skipInput=false (default), rnnparam(r,1,I,1) is a (inputSize,hiddenSize) matrix.</li><li>For skipInput=true, rnnparam(r,1,I,1) is <code>nothing</code>.</li><li>For bidirectional, the same applies to rnnparam(r,2,I,1): the first back layer.</li><li>The input biases (par=2) are returned even if skipInput=true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/rnn.jl#L183-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.rnnparams" href="#Knet.Ops20.rnnparams"><code>Knet.Ops20.rnnparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rnnparams(r::RNN)</code></pre><p>Return the RNN parameters as an Array{Any}.</p><p>The order of params returned (subject to change):</p><ul><li>All weight matrices come before all bias vectors.</li><li>Matrices and biases are sorted lexically based on (layer,id).</li><li>See @doc rnnparam for valid layer and id values.</li><li>Input multiplying matrices are <code>nothing</code> if r.inputMode = 1.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/rnn.jl#L281-L291">source</a></section></article><h2 id="Batch-Normalization"><a class="docs-heading-anchor" href="#Batch-Normalization">Batch Normalization</a><a id="Batch-Normalization-1"></a><a class="docs-heading-anchor-permalink" href="#Batch-Normalization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.batchnorm" href="#Knet.Ops20.batchnorm"><code>Knet.Ops20.batchnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">batchnorm(x[, moments, params]; kwargs...)</code></pre><p>perform batch normalization on <code>x</code> with optional mean and variance in <code>moments</code> and scaling factor and bias in <code>params</code>. See https://arxiv.org/abs/1502.03167 for reference.</p><p>2d, 4d and 5d inputs are supported. Mean and variance are computed over dimensions (2,), (1,2,4) and (1,2,3,5) for 2d, 4d and 5d arrays, respectively.</p><p><code>moments</code> stores running mean and variance to be used at inference time.  It is optional in training mode, but mandatory in test mode.  Training and test modes can be controlled by the <code>training</code> keyword argument which defaults to <code>Knet.training()</code>.</p><p><code>params</code> stores the optional affine parameters gamma and beta.  <code>bnparams</code> function can be used to initialize <code>params</code>.</p><p><strong>Example</strong></p><pre><code class="language-none"># Inilization, C is an integer
moments = bnmoments()
params = bnparams(C)
...
# size(x) -&gt; (H, W, C, N)
y = batchnorm(x, moments, params)
# size(y) -&gt; (H, W, C, N)</code></pre><p><strong>Keywords</strong></p><p><code>eps=1e-5</code>: The epsilon parameter added to the variance to avoid division by 0.</p><p><code>training=Knet.training()</code>: When <code>training</code> is true, the mean and variance of <code>x</code> are used  and <code>moments</code> argument is modified if it is provided. When <code>training</code> is false, mean and  variance stored in the <code>moments</code> argument are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/batchnorm.jl#L19-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.bnmoments" href="#Knet.Ops20.bnmoments"><code>Knet.Ops20.bnmoments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bnmoments(;momentum=0.1, mean=nothing, var=nothing, meaninit=zeros, varinit=ones)</code></pre><p>Return a <code>BNMoments</code> object, a data structure used to store running mean and running variance of batch normalization with the following fields:</p><ul><li><code>momentum=0.1</code>: A real number between 0 and 1 to be used as the scale of last</li></ul><p>mean and variance. The existing running mean or variance is multiplied by (1-momentum).</p><ul><li><p><code>mean=nothing</code>: The running mean.</p></li><li><p><code>var=nothing</code>: The running variance.</p></li><li><p><code>meaninit=zeros</code>: The function used for initialize the running mean. Should either be</p></li></ul><p><code>nothing</code> or of the form <code>([eltype], dims...)-&gt;data</code>. <code>zeros</code> is a good option.</p><ul><li><code>varinit=ones</code>: The function used for initialize the running variance. Should either be</li></ul><p><code>nothing</code> or <code>([eltype], dims...)-&gt;data</code>. <code>ones</code> is a good option.</p><p>This constructor can be used directly load moments from data. <code>meaninit</code> and <code>varinit</code> are called if <code>mean</code> and <code>var</code> are nothing. Type and size of the <code>mean</code> and <code>var</code> are determined automatically from the inputs in the <code>batchnorm</code> calls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/batchnorm.jl#L80-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.bnparams" href="#Knet.Ops20.bnparams"><code>Knet.Ops20.bnparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bnparams(etype, channels::Integer)</code></pre><p>Return a single 1d array that contains both scale and bias of batchnorm, where the first half is scale and the second half is bias.</p><p><code>bnparams(channels)</code> calls <code>bnparams(Float64, channels)</code>, following Julia convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/batchnorm.jl#L108-L116">source</a></section></article><h2 id="Model-optimization"><a class="docs-heading-anchor" href="#Model-optimization">Model optimization</a><a id="Model-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Model-optimization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.minimize" href="#Knet.Train20.minimize"><code>Knet.Train20.minimize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimize(func, data, optimizer=Adam(); params)
sgd     (func, data; lr=0.1,  gclip, params)
momentum(func, data; lr=0.05, gamma=0.95, gclip, params)
nesterov(func, data; lr=0.05, gamma=0.95, gclip, params)
adagrad (func, data; lr=0.05, eps=1e-6, gclip, params)
rmsprop (func, data; lr=0.01, rho=0.9, eps=1e-6, gclip, params)
adadelta(func, data; lr=1.0,  rho=0.9, eps=1e-6, gclip, params)
adam    (func, data; lr=0.001, beta1=0.9, beta2=0.999, eps=1e-8, gclip, params)</code></pre><p>Return an iterator which applies <code>func</code> to arguments in <code>data</code>, i.e.  <code>(func(args...) for args in data)</code>, and updates the parameters every iteration to minimize <code>func</code>.  <code>func</code> should return a scalar value.</p><p>The common keyword argument <code>params</code> can be used to list the <code>Param</code>s to be optimized.  If not specified, any <code>Param</code> that takes part in the computation of <code>func(args...)</code> will be updated.</p><p>The common keyword argument <code>gclip</code> can be used to implement per-parameter gradient clipping. For a parameter gradient <code>g</code>, if <code>norm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>. If not specified no gradient clipping is performed.</p><p>These functions do not perform optimization, but return an iterator that can. Any function that produces values from an iterator can be used with such an object, e.g. <code>progress!(sgd(f,d))</code> iterates the sgd optimizer and displays a progress bar. For convenience, appending <code>!</code> to the name of the function iterates and returns <code>nothing</code>, i.e. <code>sgd!(...)</code> is equivalent to <code>(for x in sgd(...) end)</code>.</p><p>We define optimizers as lazy iterators to have explicit control over them:</p><ul><li>To report progress use <code>progress(sgd(f,d))</code>.</li><li>To run until convergence use <code>converge(sgd(f,cycle(d)))</code>.</li><li>To run multiple epochs use <code>sgd(f,repeat(d,n))</code>.</li><li>To run a given number of iterations use <code>sgd(f,take(cycle(d),n))</code>.</li><li>To do a task every n iterations use <code>(task() for (i,j) in enumerate(sgd(f,d)) if i%n == 1)</code>.</li></ul><p>These functions apply the same algorithm with the same configuration to every parameter by default. <code>minimize</code> takes an explicit optimizer argument, all others call <code>minimize</code> with an appropriate optimizer argument (see <code>@doc update!</code> for a list of possible optimizers). Before calling <a href="#Knet.Train20.update!"><code>update!</code></a> on a <code>Param</code>, <code>minimize</code> sets its <code>opt</code> field to a copy of this default optimizer if it is not already set. The <code>opt</code> field is used by the <code>update!</code> function to determine the type of update performed on that parameter.  If you need finer grained control, you can set the optimizer of an individual <code>Param</code> by setting its <code>opt</code> field before calling one of these functions. They will not override the <code>opt</code> field if it is already set, e.g. <code>sgd(model,data)</code> will perform an <code>Adam</code> update for a parameter whose <code>opt</code> field is an <code>Adam</code> object. This also means you can stop and start the training without losing optimization state, the first call will set the <code>opt</code> fields and the subsequent calls will not override them.</p><p>Given a parameter <code>w</code> and its gradient <code>g</code> here are the updates applied by each optimizer:</p><pre><code class="language-none"># sgd (http://en.wikipedia.org/wiki/Stochastic_gradient_descent)
w .= w - lr * g

# momentum (http://jlmelville.github.io/mize/nesterov.html)
v .= gamma * v - lr * g
w .= w + v

# nesterov (http://jlmelville.github.io/mize/nesterov.html)
w .= w - gamma * v
v .= gamma * v - lr * g
w .= w + (1 + gamma) * v

# adagrad (http://www.jmlr.org/papers/v12/duchi11a.html)
G .= G + g .^ 2
w .= w - lr * g ./ sqrt(G + eps)

# rmsprop (http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)
G .= rho * G + (1-rho) * g .^ 2 
w .= w - lr * g ./ sqrt(G + eps)

# adadelta (http://arxiv.org/abs/1212.5701)
G .= rho * G + (1-rho) * g .^ 2
update = sqrt(delta + eps) .* g ./ sqrt(G + eps)
w = w - lr * update
delta = rho * delta + (1-rho) * update .^ 2

# adam (http://arxiv.org/abs/1412.6980)
v = beta1 * v + (1 - beta1) * g
G = beta2 * G + (1 - beta2) * g .^ 2
vhat = v ./ (1 - beta1 ^ t)
Ghat = G ./ (1 - beta2 ^ t)
w = w - (lr / (sqrt(Ghat) + eps)) * vhat</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/update.jl#L15-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.converge" href="#Knet.Train20.converge"><code>Knet.Train20.converge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">converge(itr; alpha=0.1)</code></pre><p>Return an iterator which acts exactly like <code>itr</code>, but quits when values from <code>itr</code> stop decreasing. <code>itr</code> should produce numeric values.</p><p>It can be used to train a model with the data cycled:</p><pre><code class="language-none">progress!(converge(minimize(model,cycle(data))))</code></pre><p><code>alpha</code> controls the exponential average of values to detect convergence. Here is how convergence is decided:</p><pre><code class="language-none">p = x - avgx
avgx = c.alpha * x + (1-c.alpha) * avgx
avgp = c.alpha * p + (1-c.alpha) * avgp
avgp &gt; 0.0 &amp;&amp; return nothing</code></pre><p><code>converge!(...)</code> is equivalent to <code>(for x in converge(...) end)</code>, i.e.  iterates over the object created by <code>converge(...)</code> and returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/train.jl#L38-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.minibatch" href="#Knet.Train20.minibatch"><code>Knet.Train20.minibatch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minibatch(x, [y], batchsize; shuffle, partial, xtype, ytype, xsize, ysize)</code></pre><p>Return an iterator of minibatches [(xi,yi)...] given data tensors x, y and batchsize.  </p><p>The last dimension of x and y give the number of instances and should be equal. <code>y</code> is optional, if omitted a sequence of <code>xi</code> will be generated rather than <code>(xi,yi)</code> tuples.  Use <code>repeat(d,n)</code> for multiple epochs, <code>Iterators.take(d,n)</code> for a partial epoch, and <code>Iterators.cycle(d)</code> to cycle through the data forever (this can be used with <code>converge</code>). If you need the iterator to continue from its last position when stopped early (e.g. by a break in a for loop), use <code>Iterators.Stateful(d)</code> (by default the iterator would restart from the beginning).</p><p>Keyword arguments:</p><ul><li><code>shuffle=false</code>: Shuffle the instances every epoch.</li><li><code>partial=false</code>: If true include the last partial minibatch &lt; batchsize.</li><li><code>xtype=typeof(x)</code>: Convert xi in minibatches to this type.</li><li><code>ytype=typeof(y)</code>: Convert yi in minibatches to this type.</li><li><code>xsize=size(x)</code>: Convert xi in minibatches to this shape (with last dimension adjusted for batchsize).</li><li><code>ysize=size(y)</code>: Convert yi in minibatches to this shape (with last dimension adjusted for batchsize).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/data.jl#L11-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.progress" href="#Knet.Train20.progress"><code>Knet.Train20.progress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">progress(msg, itr; steps, seconds, io)
progress(itr; o...) do p; [body of the msg function]; end
progress(itr; o...)
progress!(...)</code></pre><p>Return a <code>Progress</code> iterator which acts exactly like <code>itr</code>, but prints a progressbar:</p><pre><code class="language-none">┣█████████████████▎  ┫ [86.83%, 903/1040, 01:36/01:50, 9.42i/s] 3.87835</code></pre><p>Here <code>86.83%</code> is the percentage completed, <code>903</code> is the number of iterations completed, <code>1040</code> is the total number of iterations. <code>01:36</code> is elapsed time, <code>01:50</code> is the estimated total time, <code>9.42i/s</code> is the average number of iterations completed per second. If the speed is less than 1, the average number of seconds per iteration (s/i) is reported instead.  The bar, percent, total iterations, and estimated total time are omitted for iterators whose size is unknown.</p><p>The <code>3.87835</code> at the end is the output of the <code>msg</code> function applied to the Progress iterator. The message can be customized by the first two forms above, if not specified (the third form) nothing gets printed at the end of the line. The message function can use the following fields of its <code>p::Progress</code> argument: <code>p.currval</code> is the current iterator value and <code>p.curriter</code> is the current iteration count.</p><p>The progress bar is updated and <code>msg</code> is called with the Progress iterator every <code>steps</code> iterations or every <code>seconds</code> seconds in addition to the first and the last iteration. If neither <code>steps</code> nor <code>seconds</code> is specified the default is to update every second. The keyword argument <code>io</code> determines where the progress bar is printed, the default is <code>stderr</code>.</p><p>The last form, <code>progress!(...)</code>, is equivalent to <code>(for x in progress(...) end)</code>, i.e. iterates over the object created by <code>progress(...)</code> and returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/progress.jl#L9-L40">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Knet.training</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Hyperparameter-optimization"><a class="docs-heading-anchor" href="#Hyperparameter-optimization">Hyperparameter optimization</a><a id="Hyperparameter-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Hyperparameter-optimization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.goldensection" href="#Knet.Train20.goldensection"><code>Knet.Train20.goldensection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">goldensection(f,n;kwargs) =&gt; (fmin,xmin)</code></pre><p>Find the minimum of <code>f</code> using concurrent golden section search in <code>n</code> dimensions. See <code>Knet.goldensection_demo()</code> for an example.</p><p><code>f</code> is a function from a <code>Vector{Float64}</code> of length <code>n</code> to a <code>Number</code>.  It can return <code>NaN</code> for out of range inputs.  Goldensection will always start with a zero vector as the initial input to <code>f</code>, and the initial step size will be 1 in each dimension.  The user should define <code>f</code> to scale and shift this input range into a vector meaningful for their application. For positive inputs like learning rate or hidden size, you can use a transformation such as <code>x0*exp(x)</code> where <code>x</code> is a value <code>goldensection</code> passes to <code>f</code> and <code>x0</code> is your initial guess for this value. This will effectively start the search at <code>x0</code>, then move with multiplicative steps.</p><p>I designed this algorithm combining ideas from <a href="http://apps.nrbook.com/empanel/index.html?pg=492">Golden Section Search</a> and <a href="https://en.wikipedia.org/wiki/Hill_climbing">Hill Climbing Search</a>. It essentially runs golden section search concurrently in each dimension, picking the next step based on estimated gain.</p><p><strong>Keyword arguments</strong></p><ul><li><code>dxmin=0.1</code>: smallest step size.</li><li><code>accel=φ</code>: acceleration rate. Golden ratio <code>φ=1.618...</code> is best.</li><li><code>verbose=false</code>: use <code>true</code> to print individual steps.</li><li><code>history=[]</code>: cache of <code>[(x,f(x)),...]</code> function evaluations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/hyperopt.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.hyperband" href="#Knet.Train20.hyperband"><code>Knet.Train20.hyperband</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hyperband(getconfig, getloss, maxresource=27, reduction=3)</code></pre><p>Hyperparameter optimization using the hyperband algorithm from (<a href="https://arxiv.org/abs/1603.06560">Lisha et al. 2016</a>).  You can try a simple MNIST example using <code>Knet.hyperband_demo()</code>. </p><p><strong>Arguments</strong></p><ul><li><code>getconfig()</code> returns random configurations with a user defined type and distribution.</li><li><code>getloss(c,n)</code> returns loss for configuration <code>c</code> and number of resources (e.g. epochs) <code>n</code>.</li><li><code>maxresource</code> is the maximum number of resources any one configuration should be given.</li><li><code>reduction</code> is an algorithm parameter (see paper), 3 is a good value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/hyperopt.jl#L111-L125">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.bmm" href="#Knet.Ops20.bmm"><code>Knet.Ops20.bmm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bmm(A, B ; transA=false, transB=false)</code></pre><p>Perform a batch matrix-matrix product of matrices stored in <code>A</code> and <code>B</code>. size(A,2) == size(B,1) and size(A)[3:end] and size(B)[3:end] must match.  If A is a (m,n,b...) tensor, B is a (n,k,b...) tensor, and the output is a (m,k,b...)  tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/bmm.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoGrad.cat1d" href="#AutoGrad.cat1d"><code>AutoGrad.cat1d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cat1d(args...)</code></pre><p>Return <code>vcat(vec.(args)...)</code> but possibly more efficiently. Can be used to concatenate the contents of arrays with different shapes and sizes.</p></div></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Knet.cpucopy</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Knet.dir" href="#Knet.dir"><code>Knet.dir</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Construct a path relative to Knet root, e.g. Knet.dir(&quot;examples&quot;) =&gt; &quot;~/.julia/dev/Knet/examples&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/Knet.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.dropout" href="#Knet.Ops20.dropout"><code>Knet.Ops20.dropout</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropout(x, p; drop, seed)</code></pre><p>Given an array <code>x</code> and probability <code>0&lt;=p&lt;=1</code> return an array <code>y</code> in which each element is 0 with probability <code>p</code> or <code>x[i]/(1-p)</code> with probability <code>1-p</code>. Just return <code>x</code> if <code>p==0</code>, or <code>drop=false</code>. By default <code>drop=true</code> in a <code>@diff</code> context, <code>drop=false</code> otherwise.  Specify a non-zero <code>seed::Number</code> to set the random number seed for reproducible results. See <a href="http://www.jmlr.org/papers/v15/srivastava14a.html">(Srivastava et al. 2014)</a> for a reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/dropout.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.KnetArrays.gc" href="#Knet.KnetArrays.gc"><code>Knet.KnetArrays.gc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Knet.gc(dev=CUDA.device().handle)</code></pre><p>cudaFree all pointers allocated on device <code>dev</code> that were previously allocated and garbage collected. Normally Knet holds on to all garbage collected pointers for reuse. Try this if you run out of GPU memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/knetarrays/kptr.jl#L197-L203">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Knet.gpu</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Knet.gpucopy</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Knet.invx</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Knet.Ops20.mat" href="#Knet.Ops20.mat"><code>Knet.Ops20.mat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mat(x; dims = ndims(x) - 1)</code></pre><p>Reshape <code>x</code> into a two-dimensional matrix by joining the first dims dimensions, i.e.  <code>reshape(x, prod(size(x,i) for i in 1:dims), :)</code></p><p><code>dims=ndims(x)-1</code> (default) is typically used when turning the output of a 4-D convolution result into a 2-D input for a fully connected layer.</p><p><code>dims=1</code> is typically used when turning the 3-D output of an RNN layer into a 2-D input for a fully connected layer.</p><p><code>dims=0</code> will turn the input into a row vector, <code>dims=ndims(x)</code> will turn it into a column vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/ops20/conv.jl#L206-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.KnetArrays.seed!" href="#Knet.KnetArrays.seed!"><code>Knet.KnetArrays.seed!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Call both CUDA.seed! (if available) and Random.seed!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/knetarrays/random.jl#L14">source</a></section></article><h2 id="AutoGrad-(advanced)"><a class="docs-heading-anchor" href="#AutoGrad-(advanced)">AutoGrad (advanced)</a><a id="AutoGrad-(advanced)-1"></a><a class="docs-heading-anchor-permalink" href="#AutoGrad-(advanced)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AutoGrad.@gcheck" href="#AutoGrad.@gcheck"><code>AutoGrad.@gcheck</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">gcheck(f, x...; kw, o...)
@gcheck f(x...; kw...) (opt1=val1,opt2=val2,...)</code></pre><p>Numerically check the gradient of <code>f(x...; kw...)</code> and return a boolean result.</p><p>Example call: <code>gcheck(nll,model,x,y)</code> or <code>@gcheck nll(model,x,y)</code>. The parameters should be marked as <code>Param</code> arrays in <code>f</code>, <code>x</code>, and/or <code>kw</code>.  Only 10 random entries in each large numeric array are checked by default.  If the output of <code>f</code> is not a number, we check the gradient of <code>sum(f(x...; kw...))</code>. Keyword arguments:</p><ul><li><code>kw=()</code>: keyword arguments to be passed to <code>f</code>, i.e. <code>f(x...; kw...)</code></li><li><code>nsample=10</code>: number of random entries from each param to check</li><li><code>atol=0.01,rtol=0.05</code>: tolerance parameters.  See <code>isapprox</code> for their meaning.</li><li><code>delta=0.0001</code>: step size for numerical gradient calculation.</li><li><code>verbose=1</code>: 0 prints nothing, 1 shows failing tests, 2 shows all tests.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoGrad.@primitive" href="#AutoGrad.@primitive"><code>AutoGrad.@primitive</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@primitive  fx g1 g2...</code></pre><p>Define a new primitive operation for AutoGrad and (optionally) specify its gradients. Non-differentiable functions such as <code>sign</code>, and non-numeric functions such as <code>size</code> should be defined using the @zerograd macro instead.</p><p><strong>Examples</strong></p><pre><code class="language-none">@primitive sin(x::Number)
@primitive hypot(x1,x2),dy,y

@primitive sin(x::Number),dy  (dy.*cos(x))
@primitive hypot(x1,x2),dy,y  (dy.*x1./y)  (dy.*x2./y)</code></pre><p>The first example shows that <code>fx</code> is a typed method declaration.  Julia supports multiple dispatch, i.e. a single function can have multiple methods with different arg types. AutoGrad takes advantage of this and supports multiple dispatch for primitives and gradients.</p><p>The second example specifies variable names for the output gradient <code>dy</code> and the output <code>y</code> after the method declaration which can be used in gradient expressions.  Untyped, ellipsis and keyword arguments are ok as in <code>f(a::Int,b,c...;d=1)</code>.  Parametric methods such as <code>f(x::T) where {T&lt;:Number}</code> cannot be used.</p><p>The method declaration can optionally be followed by gradient expressions.  The third and fourth examples show how gradients can be specified.  Note that the parameters, the return variable and the output gradient of the original function can be used in the gradient expressions.</p><p><strong>Under the hood</strong></p><p>The @primitive macro turns the first example into:</p><pre><code class="language-none">sin(x::Value{T}) where {T&lt;:Number} = forw(sin, x)</code></pre><p>This will cause calls to <code>sin</code> with a boxed argument (<code>Value{T&lt;:Number}</code>) to be recorded. The recorded operations are used by AutoGrad to construct a dynamic computational graph. With multiple arguments things are a bit more complicated.  Here is what happens with the second example:</p><pre><code class="language-none">hypot(x1::Value{S}, x2::Value{T}) where {S,T} = forw(hypot, x1, x2)
hypot(x1::S, x2::Value{T})        where {S,T} = forw(hypot, x1, x2)
hypot(x1::Value{S}, x2::T)        where {S,T} = forw(hypot, x1, x2)</code></pre><p>We want the forw method to be called if any one of the arguments is a boxed <code>Value</code>.  There is no easy way to specify this in Julia, so the macro generates all 2^N-1 boxed/unboxed argument combinations.</p><p>In AutoGrad, gradients are defined using gradient methods that have the following pattern:</p><pre><code class="language-none">back(f,Arg{i},dy,y,x...) =&gt; dx[i]</code></pre><p>For the third example here is the generated gradient method:</p><pre><code class="language-none">back(::typeof(sin), ::Type{Arg{1}}, dy, y, x::Value{T}) where {T&lt;:Number} = dy .* cos(x)</code></pre><p>For the last example a different gradient method is generated for each argument:</p><pre><code class="language-none">back(::typeof(hypot), ::Type{Arg{1}}, dy, y, x1::Value{S}, x2::Value{T}) where {S,T} = (dy .* x1) ./ y
back(::typeof(hypot), ::Type{Arg{2}}, dy, y, x1::Value{S}, x2::Value{T}) where {S,T} = (dy .* x2) ./ y</code></pre><p>In fact @primitive generates four more definitions for the other boxed/unboxed argument combinations.</p><p><strong>Broadcasting</strong></p><p>Broadcasting is handled by extra <code>forw</code> and <code>back</code> methods. <code>@primitive</code> defines the following  so that broadcasting of a primitive function with a boxed value triggers <code>forw</code> and <code>back</code>.</p><pre><code class="language-none">broadcasted(::typeof(sin), x::Value{T}) where {T&lt;:Number} = forw(broadcasted,sin,x)
back(::typeof(broadcasted), ::Type{Arg{2}}, dy, y, ::typeof(sin), x::Value{T}) where {T&lt;:Number} = dy .* cos(x)</code></pre><p>If you do not want the broadcasting methods, you can use the <code>@primitive1</code> macro. If you only want the broadcasting methods use <code>@primitive2</code>. As a motivating example, here is how <code>*</code> is defined for non-scalars:</p><pre><code class="language-none">@primitive1 *(x1,x2),dy  (dy*x2&#39;)  (x1&#39;*dy)
@primitive2 *(x1,x2),dy  unbroadcast(x1,dy.*x2)  unbroadcast(x2,x1.*dy)</code></pre><p>Regular <code>*</code> is matrix multiplication, broadcasted <code>*</code> is elementwise multiplication and the two have different gradients as defined above. <code>unbroadcast(a,b)</code> reduces <code>b</code> to the same shape as <code>a</code> by performing the necessary summations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoGrad.@zerograd" href="#AutoGrad.@zerograd"><code>AutoGrad.@zerograd</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@zerograd f(args...; kwargs...)</code></pre><p>Define <code>f</code> as an AutoGrad primitive operation with zero gradient.</p><p><strong>Example:</strong></p><pre><code class="language-none">@zerograd  floor(x::Float32)</code></pre><p><code>@zerograd</code> allows <code>f</code> to handle boxed <code>Value</code> inputs by unboxing them like a <code>@primitive</code>, but unlike <code>@primitive</code> it does not record its actions or return a boxed <code>Value</code> result. Some functions, like <code>sign()</code>, have zero gradient.  Others, like <code>length()</code> have discrete or constant outputs.  These need to handle <code>Value</code> inputs, but do not need to record anything and can return regular values.  Their output can be treated like a constant in the program. Use the <code>@zerograd</code> macro for those.  Use the <code>@zerograd1</code> variant if you don&#39;t want to define the broadcasting version and <code>@zerograd2</code> if you only want to define the broadcasting version. Note that <code>kwargs</code> are NOT unboxed.</p></div></section></article><h2 id="Per-parameter-optimization-(advanced)"><a class="docs-heading-anchor" href="#Per-parameter-optimization-(advanced)">Per-parameter optimization (advanced)</a><a id="Per-parameter-optimization-(advanced)-1"></a><a class="docs-heading-anchor-permalink" href="#Per-parameter-optimization-(advanced)" title="Permalink"></a></h2><p>The model optimization methods apply the same algorithm with the same configuration to every parameter. If you need finer grained control, you can set the optimization algorithm and configuration of an individual <code>Param</code> by setting its <code>opt</code> field to one of the optimization objects like <code>Adam</code> listed below. The <code>opt</code> field is used as an argument to <code>update!</code> and controls the type of update performed on that parameter. Model optimization methods like <code>sgd</code> will not override the <code>opt</code> field if it is already set, e.g. <code>sgd(model,data)</code> will perform an <code>Adam</code> update for a parameter whose <code>opt</code> field is an <code>Adam</code> object. This also means you can stop and start the training without losing optimization state, the first call will set the <code>opt</code> fields and the subsequent calls will not override them.</p><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.update!" href="#Knet.Train20.update!"><code>Knet.Train20.update!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update!(weights::Param, gradients)
update!(weights, gradients; lr=0.1, gclip=0)
update!(weights, gradients, optimizers)</code></pre><p>Update the <code>weights</code> using their <code>gradients</code> and the optimization algorithms specified using (1) the <code>opt</code> field of a <code>Param</code>, (2) keyword arguments, (3) the third argument.</p><p><code>weights</code> can be an individual <code>Param</code>, numeric array, or a collection of arrays/Params represented by an iterator or dictionary. <code>gradients</code> should be a matching individual array or collection. In the first form, the optimizer should be specified in <code>weights.opt</code>. In the second form the optimizer defaults to <a href="#Knet.Train20.SGD"><code>SGD</code></a> with learning rate <code>lr</code> and gradient clip <code>gclip</code>. In the third form <code>optimizers</code> should be a matching individual optimizer or collection of optimizers.  The <code>weights</code> and possibly <code>gradients</code> and <code>optimizers</code> are modified in-place.</p><p>Individual optimization parameters can be one of the following types. The keyword arguments for each constructor and their default values are listed as well.</p><ul><li><a href="#Knet.Train20.SGD"><code>SGD</code></a><code>(;lr=0.1, gclip=0)</code></li><li><a href="#Knet.Train20.Momentum"><code>Momentum</code></a><code>(;lr=0.05, gamma=0.95, gclip=0)</code></li><li><a href="#Knet.Train20.Nesterov"><code>Nesterov</code></a><code>(;lr=0.05, gamma=0.95, gclip=0)</code></li><li><a href="#Knet.Train20.Adagrad"><code>Adagrad</code></a><code>(;lr=0.05, eps=1e-6, gclip=0)</code></li><li><a href="#Knet.Train20.Rmsprop"><code>Rmsprop</code></a><code>(;lr=0.01, rho=0.9, eps=1e-6, gclip=0)</code></li><li><a href="#Knet.Train20.Adadelta"><code>Adadelta</code></a><code>(;lr=1.0, rho=0.9, eps=1e-6, gclip=0)</code></li><li><a href="#Knet.Train20.Adam"><code>Adam</code></a><code>(;lr=0.001, beta1=0.9, beta2=0.999, eps=1e-8, gclip=0)</code></li></ul><p><strong>Example:</strong></p><pre><code class="language-none">w = Param(rand(d), Adam())  # a Param with a specified optimizer
g = lossgradient0(w)        # gradient g has the same shape as w
update!(w, g)               # update w in-place with Adam()

w = rand(d)                 # an individual weight array
g = lossgradient1(w)        # gradient g has the same shape as w
update!(w, g)               # update w in-place with SGD()
update!(w, g; lr=0.1)       # update w in-place with SGD(lr=0.1)
update!(w, g, SGD(lr=0.1))  # update w in-place with SGD(lr=0.1)

w = (rand(d1), rand(d2))    # a tuple of weight arrays
g = lossgradient2(w)        # g will also be a tuple
p = (Adam(), SGD())         # p has optimizers for each w[i]
update!(w, g, p)            # update each w[i] in-place with g[i],p[i]

w = Any[rand(d1), rand(d2)] # any iterator can be used
g = lossgradient3(w)        # g will be similar to w
p = Any[Adam(), SGD()]      # p should be an iterator of same length
update!(w, g, p)            # update each w[i] in-place with g[i],p[i]

w = Dict(:a =&gt; rand(d1), :b =&gt; rand(d2)) # dictionaries can be used
g = lossgradient4(w)
p = Dict(:a =&gt; Adam(), :b =&gt; SGD())
update!(w, g, p)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/update.jl#L415-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.SGD" href="#Knet.Train20.SGD"><code>Knet.Train20.SGD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SGD(;lr=0.1,gclip=0)
update!(w,g,p::SGD)
update!(w,g;lr=0.1)</code></pre><p>Container for parameters of the Stochastic gradient descent (SGD) optimization algorithm used by <a href="#Knet.Train20.update!"><code>update!</code></a>.</p><p>SGD is an optimization technique to minimize an objective function by updating its weights in the opposite direction of their gradient. The learning rate (lr) determines the size of the step.  SGD updates the weights with the following formula:</p><pre><code class="language-none">w = w - lr * g</code></pre><p>where <code>w</code> is a weight array, <code>g</code> is the gradient of the loss function w.r.t <code>w</code> and <code>lr</code> is the learning rate.</p><p>If <code>norm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>SGD is used by default if no algorithm is specified in the two argument version of <code>update!</code>[@ref].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/update.jl#L101-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.Momentum" href="#Knet.Train20.Momentum"><code>Knet.Train20.Momentum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Momentum(;lr=0.05, gclip=0, gamma=0.95)
update!(w,g,p::Momentum)</code></pre><p>Container for parameters of the Momentum optimization algorithm used by <a href="#Knet.Train20.update!"><code>update!</code></a>.</p><p>The Momentum method tries to accelerate SGD by adding a velocity term to the update.  This also decreases the oscillation between successive steps. It updates the weights with the following formulas:</p><pre><code class="language-none">velocity = gamma * velocity + lr * g
w = w - velocity</code></pre><p>where <code>w</code> is a weight array, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>gamma</code> is the momentum parameter, <code>velocity</code> is an array with the same size and type of <code>w</code> and holds the accelerated gradients.</p><p>If <code>norm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="http://doi.org/10.1016/S0893-6080(98)00116-6">Qian, N. (1999)</a>. On the momentum term in gradient descent learning algorithms.  Neural Networks : The Official Journal of the International Neural Network Society, 12(1), 145–151.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/update.jl#L143-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.Nesterov" href="#Knet.Train20.Nesterov"><code>Knet.Train20.Nesterov</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Nesterov(; lr=0.05, gclip=0, gamma=0.95)
update!(w,g,p::Momentum)</code></pre><p>Container for parameters of Nesterov&#39;s momentum optimization algorithm used by <a href="#Knet.Train20.update!"><code>update!</code></a>.</p><p>It is similar to standard <a href="#Knet.Train20.Momentum"><code>Momentum</code></a> but with a slightly different update rule:</p><pre><code class="language-none">velocity = gamma * velocity_old - lr * g
w = w_old - velocity_old + (1+gamma) * velocity</code></pre><p>where <code>w</code> is a weight array, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>gamma</code> is the momentum parameter, <code>velocity</code> is an array with the same size and type of <code>w</code> and holds the accelerated gradients.</p><p>If <code>norm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip == 0</code> no scaling takes place.</p><p>Reference Implementation : <a href="https://arxiv.org/pdf/1212.0901.pdf">Yoshua Bengio, Nicolas Boulanger-Lewandowski and Razvan P ascanu</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/update.jl#L186-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.Adagrad" href="#Knet.Train20.Adagrad"><code>Knet.Train20.Adagrad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Adagrad(;lr=0.05, gclip=0, eps=1e-6)
update!(w,g,p::Adagrad)</code></pre><p>Container for parameters of the Adagrad optimization algorithm used by <a href="#Knet.Train20.update!"><code>update!</code></a>.</p><p>Adagrad is one of the methods that adapts the learning rate to each of the weights.  It stores the sum of the squares of the gradients to scale the learning rate.  The learning rate is adapted for each weight by the value of current gradient divided by the accumulated gradients. Hence, the learning rate is greater for the parameters where the accumulated gradients are small and the learning rate is small if the accumulated gradients are large. It updates the weights with the following formulas:</p><pre><code class="language-none">G = G + g .^ 2
w = w - g .* lr ./ sqrt(G + eps)</code></pre><p>where <code>w</code> is the weight, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>G</code> is an array with the same size and type of <code>w</code> and holds the sum of the squares of the gradients. <code>eps</code> is a small constant to prevent a zero value in the denominator.</p><p>If <code>norm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="http://jmlr.org/papers/v12/duchi11a.html">Duchi, J., Hazan, E., &amp; Singer, Y. (2011)</a>. Adaptive Subgradient Methods for Online Learning and Stochastic Optimization. Journal of Machine Learning Research, 12, 2121–2159.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/update.jl#L223-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.Rmsprop" href="#Knet.Train20.Rmsprop"><code>Knet.Train20.Rmsprop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rmsprop(;lr=0.01, gclip=0, rho=0.9, eps=1e-6)
update!(w,g,p::Rmsprop)</code></pre><p>Container for parameters of the Rmsprop optimization algorithm used by <a href="#Knet.Train20.update!"><code>update!</code></a>.</p><p>Rmsprop scales the learning rates by dividing the root mean squared of the gradients. It updates the weights with the following formula:</p><pre><code class="language-none">G = (1-rho) * g .^ 2 + rho * G
w = w - lr * g ./ sqrt(G + eps)</code></pre><p>where <code>w</code> is the weight, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>G</code> is an array with the same size and type of <code>w</code> and holds the sum of the squares of the gradients. <code>eps</code> is a small constant to prevent a zero value in the denominator.  <code>rho</code> is the momentum parameter and <code>delta</code> is an array with the same size and type of <code>w</code> and holds the sum of the squared updates.</p><p>If <code>norm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="https://dirtysalt.github.io/images/nn-class-lec6.pdf">Tijmen Tieleman and Geoffrey Hinton (2012)</a>. &quot;Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude.&quot;  COURSERA: Neural Networks for Machine Learning 4.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/update.jl#L270-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.Adadelta" href="#Knet.Train20.Adadelta"><code>Knet.Train20.Adadelta</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Adadelta(;lr=1.0, gclip=0, rho=0.9, eps=1e-6)
update!(w,g,p::Adadelta)</code></pre><p>Container for parameters of the Adadelta optimization algorithm used by <a href="#Knet.Train20.update!"><code>update!</code></a>.</p><p>Adadelta is an extension of Adagrad that tries to prevent the decrease of the learning rates to zero as training progresses. It scales the learning rate based on the accumulated gradients like Adagrad and holds the acceleration term like Momentum. It updates the weights with the following formulas:</p><pre><code class="language-none">G = (1-rho) * g .^ 2 + rho * G
update = g .* sqrt(delta + eps) ./ sqrt(G + eps)
w = w - lr * update
delta = rho * delta + (1-rho) * update .^ 2</code></pre><p>where <code>w</code> is the weight, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>G</code> is an array with the same size and type of <code>w</code> and holds the sum of the squares of the gradients. <code>eps</code> is a small constant to prevent a zero value in the denominator.  <code>rho</code> is the momentum parameter and <code>delta</code> is an array with the same size and type of <code>w</code> and holds the sum of the squared updates.</p><p>If <code>norm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="http://arxiv.org/abs/1212.5701">Zeiler, M. D. (2012)</a>. ADADELTA: An Adaptive Learning Rate Method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/update.jl#L314-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Knet.Train20.Adam" href="#Knet.Train20.Adam"><code>Knet.Train20.Adam</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Adam(;lr=0.001, gclip=0, beta1=0.9, beta2=0.999, eps=1e-8)
update!(w,g,p::Adam)</code></pre><p>Container for parameters of the Adam optimization algorithm used by <a href="#Knet.Train20.update!"><code>update!</code></a>.</p><p>Adam is one of the methods that compute the adaptive learning rate. It stores accumulated gradients (first moment) and the sum of the squared of gradients (second).  It scales the first and second moment as a function of time. Here is the update formulas:</p><pre><code class="language-none">m = beta1 * m + (1 - beta1) * g
v = beta2 * v + (1 - beta2) * g .* g
mhat = m ./ (1 - beta1 ^ t)
vhat = v ./ (1 - beta2 ^ t)
w = w - (lr / (sqrt(vhat) + eps)) * mhat</code></pre><p>where <code>w</code> is the weight, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>m</code> is an array with the same size and type of <code>w</code> and holds the accumulated gradients. <code>v</code> is an array with the same size and type of <code>w</code> and holds the sum of the squares of the gradients. <code>eps</code> is a small constant to prevent a zero denominator. <code>beta1</code> and <code>beta2</code> are the parameters to calculate bias corrected first and second moments. <code>t</code> is the update count.</p><p>If <code>norm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="https://arxiv.org/abs/1412.6980">Kingma, D. P., &amp; Ba, J. L. (2015)</a>. Adam: a Method for Stochastic Optimization. International Conference on Learning Representations, 1–13.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/denizyuret/Knet.jl/blob/1492e2b4c22126e0e08211eb269e1acfd763c009/src/train20/update.jl#L363-L397">source</a></section></article><h2 id="Function-Index"><a class="docs-heading-anchor" href="#Function-Index">Function Index</a><a id="Function-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Index" title="Permalink"></a></h2><ul><li><a href="#Knet.AutoGrad"><code>Knet.AutoGrad</code></a></li><li><a href="#Knet.KnetArrays.KnetArray"><code>Knet.KnetArrays.KnetArray</code></a></li><li><a href="#Knet.Ops20.RNN"><code>Knet.Ops20.RNN</code></a></li><li><a href="#Knet.Train20.Adadelta"><code>Knet.Train20.Adadelta</code></a></li><li><a href="#Knet.Train20.Adagrad"><code>Knet.Train20.Adagrad</code></a></li><li><a href="#Knet.Train20.Adam"><code>Knet.Train20.Adam</code></a></li><li><a href="#Knet.Train20.Momentum"><code>Knet.Train20.Momentum</code></a></li><li><a href="#Knet.Train20.Nesterov"><code>Knet.Train20.Nesterov</code></a></li><li><a href="#Knet.Train20.Rmsprop"><code>Knet.Train20.Rmsprop</code></a></li><li><a href="#Knet.Train20.SGD"><code>Knet.Train20.SGD</code></a></li><li><a href="#AutoGrad.cat1d"><code>AutoGrad.cat1d</code></a></li><li><a href="#Knet.KnetArrays.gc"><code>Knet.KnetArrays.gc</code></a></li><li><a href="#Knet.KnetArrays.seed!"><code>Knet.KnetArrays.seed!</code></a></li><li><a href="#Knet.Ops20.accuracy"><code>Knet.Ops20.accuracy</code></a></li><li><a href="#Knet.Ops20.batchnorm"><code>Knet.Ops20.batchnorm</code></a></li><li><a href="#Knet.Ops20.bce"><code>Knet.Ops20.bce</code></a></li><li><a href="#Knet.Ops20.bmm"><code>Knet.Ops20.bmm</code></a></li><li><a href="#Knet.Ops20.bnmoments"><code>Knet.Ops20.bnmoments</code></a></li><li><a href="#Knet.Ops20.bnparams"><code>Knet.Ops20.bnparams</code></a></li><li><a href="#Knet.Ops20.conv4"><code>Knet.Ops20.conv4</code></a></li><li><a href="#Knet.Ops20.deconv4"><code>Knet.Ops20.deconv4</code></a></li><li><a href="#Knet.Ops20.dropout"><code>Knet.Ops20.dropout</code></a></li><li><a href="#Knet.Ops20.elu"><code>Knet.Ops20.elu</code></a></li><li><a href="#Knet.Ops20.logistic"><code>Knet.Ops20.logistic</code></a></li><li><a href="#Knet.Ops20.logp"><code>Knet.Ops20.logp</code></a></li><li><a href="#Knet.Ops20.logsoftmax"><code>Knet.Ops20.logsoftmax</code></a></li><li><a href="#Knet.Ops20.logsumexp"><code>Knet.Ops20.logsumexp</code></a></li><li><a href="#Knet.Ops20.mat"><code>Knet.Ops20.mat</code></a></li><li><a href="#Knet.Ops20.nll"><code>Knet.Ops20.nll</code></a></li><li><a href="#Knet.Ops20.pool"><code>Knet.Ops20.pool</code></a></li><li><a href="#Knet.Ops20.relu"><code>Knet.Ops20.relu</code></a></li><li><a href="#Knet.Ops20.rnnparam"><code>Knet.Ops20.rnnparam</code></a></li><li><a href="#Knet.Ops20.rnnparams"><code>Knet.Ops20.rnnparams</code></a></li><li><a href="#Knet.Ops20.selu"><code>Knet.Ops20.selu</code></a></li><li><a href="#Knet.Ops20.sigm"><code>Knet.Ops20.sigm</code></a></li><li><a href="#Knet.Ops20.softmax"><code>Knet.Ops20.softmax</code></a></li><li><a href="#Knet.Ops20.unpool"><code>Knet.Ops20.unpool</code></a></li><li><a href="#Knet.Ops20.zeroone"><code>Knet.Ops20.zeroone</code></a></li><li><a href="#Knet.Train20.bilinear"><code>Knet.Train20.bilinear</code></a></li><li><a href="#Knet.Train20.converge"><code>Knet.Train20.converge</code></a></li><li><a href="#Knet.Train20.gaussian"><code>Knet.Train20.gaussian</code></a></li><li><a href="#Knet.Train20.goldensection"><code>Knet.Train20.goldensection</code></a></li><li><a href="#Knet.Train20.hyperband"><code>Knet.Train20.hyperband</code></a></li><li><a href="#Knet.Train20.minibatch"><code>Knet.Train20.minibatch</code></a></li><li><a href="#Knet.Train20.minimize"><code>Knet.Train20.minimize</code></a></li><li><a href="#Knet.Train20.param"><code>Knet.Train20.param</code></a></li><li><a href="#Knet.Train20.progress"><code>Knet.Train20.progress</code></a></li><li><a href="#Knet.Train20.update!"><code>Knet.Train20.update!</code></a></li><li><a href="#Knet.Train20.xavier"><code>Knet.Train20.xavier</code></a></li><li><a href="#Knet.Train20.xavier_normal"><code>Knet.Train20.xavier_normal</code></a></li><li><a href="#Knet.Train20.xavier_uniform"><code>Knet.Train20.xavier_uniform</code></a></li><li><a href="#Knet.dir"><code>Knet.dir</code></a></li><li><a href="#AutoGrad.@gcheck"><code>AutoGrad.@gcheck</code></a></li><li><a href="#AutoGrad.@primitive"><code>AutoGrad.@primitive</code></a></li><li><a href="#AutoGrad.@zerograd"><code>AutoGrad.@zerograd</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Introduction to Knet</a><a class="docs-footer-nextpage" href="../backprop/">Backpropagation and SGD »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 17 March 2021 08:00">Wednesday 17 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
