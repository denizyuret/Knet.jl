<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Knet.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>Knet.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="install.html">Setting up Knet</a></li><li><a class="toctext" href="tutorial.html">Introduction to Knet</a></li><li><a class="toctext" href="examples.html">Examples</a></li><li class="current"><a class="toctext" href="reference.html">Reference</a><ul class="internal"><li><a class="toctext" href="#AutoGrad-1">AutoGrad</a></li><li><a class="toctext" href="#KnetArray-1">KnetArray</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li><li><a class="toctext" href="#Convolution-and-Pooling-1">Convolution and Pooling</a></li><li><a class="toctext" href="#Optimization-methods-1">Optimization methods</a></li><li><a class="toctext" href="#Initialization-1">Initialization</a></li><li><a class="toctext" href="#AutoGrad-(advanced)-1">AutoGrad (advanced)</a></li><li><a class="toctext" href="#Function-Index-1">Function Index</a></li></ul></li></ul></li><li><span class="toctext">Textbook</span><ul><li><a class="toctext" href="backprop.html">Backpropagation</a></li><li><a class="toctext" href="softmax.html">Softmax Classification</a></li><li><a class="toctext" href="mlp.html">Multilayer Perceptrons</a></li><li><a class="toctext" href="cnn.html">Convolutional Neural Networks</a></li><li><a class="toctext" href="rnn.html">Recurrent Neural Networks</a></li><li><a class="toctext" href="rl.html">Reinforcement Learning</a></li><li><a class="toctext" href="opt.html">Optimization</a></li><li><a class="toctext" href="gen.html">Generalization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="reference.html">Reference</a></li></ul><a class="edit-page" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><p><strong>Contents</strong></p><ul><li><a href="reference.html#Reference-1">Reference</a></li><ul><li><a href="reference.html#AutoGrad-1">AutoGrad</a></li><li><a href="reference.html#KnetArray-1">KnetArray</a></li><li><a href="reference.html#Utilities-1">Utilities</a></li><li><a href="reference.html#Convolution-and-Pooling-1">Convolution and Pooling</a></li><li><a href="reference.html#Optimization-methods-1">Optimization methods</a></li><li><a href="reference.html#Initialization-1">Initialization</a></li><li><a href="reference.html#AutoGrad-(advanced)-1">AutoGrad (advanced)</a></li><li><a href="reference.html#Function-Index-1">Function Index</a></li></ul></ul><h2><a class="nav-anchor" id="AutoGrad-1" href="#AutoGrad-1">AutoGrad</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AutoGrad.grad" href="#AutoGrad.grad"><code>AutoGrad.grad</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">grad(fun, argnum=1)</code></pre><p>Take a function <code>fun(X...)-&gt;Y</code> and return another function <code>gfun(X...)-&gt;dXi</code> which computes its gradient with respect to positional argument number <code>argnum</code>. The function <code>fun</code> should be scalar-valued. The returned function <code>gfun</code> takes the same arguments as <code>fun</code>, but returns the gradient instead. The gradient has the same type and size as the target argument which can be a Number, Array, Tuple, or Dict.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/AutoGrad.jl/tree/e0530fe89378cf3f137f00d6bc576d5ef3122f75/src/core.jl#L29-L41">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AutoGrad.gradloss" href="#AutoGrad.gradloss"><code>AutoGrad.gradloss</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gradloss(fun, argnum=1)</code></pre><p>Another version of <code>grad</code> where the generated function returns a (gradient,value) pair.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/AutoGrad.jl/tree/e0530fe89378cf3f137f00d6bc576d5ef3122f75/src/core.jl#L50-L57">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AutoGrad.gradcheck" href="#AutoGrad.gradcheck"><code>AutoGrad.gradcheck</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gradcheck(f, w, x...; kwargs...)</code></pre><p>Numerically check the gradient of <code>f(w,x...;o...)</code> with respect to its first argument <code>w</code> and return a boolean result.</p><p>The argument <code>w</code> can be a Number, Array, Tuple or Dict which in turn can contain other Arrays etc.  Only the largest 10 entries in each numerical gradient array are checked by default.  If the output of f is not a number, gradcheck constructs and checks a scalar function by taking its dot product with a random vector.</p><p><strong>Keywords</strong></p><ul><li><p><code>gcheck=10</code>: number of largest entries from each numeric array in gradient <code>dw=(grad(f))(w,x...;o...)</code> compared to their numerical estimates.</p></li><li><p><code>verbose=false</code>: print detailed messages if true.</p></li><li><p><code>kwargs=[]</code>: keyword arguments to be passed to <code>f</code>.</p></li><li><p><code>delta=atol=rtol=cbrt(eps(w))</code>: tolerance parameters.  See <code>isapprox</code> for their meaning.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/AutoGrad.jl/tree/e0530fe89378cf3f137f00d6bc576d5ef3122f75/src/gradcheck.jl#L1-L27">source</a><br/></section><h2><a class="nav-anchor" id="KnetArray-1" href="#KnetArray-1">KnetArray</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.KnetArray" href="#Knet.KnetArray"><code>Knet.KnetArray</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">KnetArray{T}(dims)
KnetArray(a::AbstractArray)
Array(k::KnetArray)</code></pre><p>Container for GPU arrays that supports most of the AbstractArray interface.  The constructor allocates a KnetArray in the currently active device, as specified by <code>gpu()</code>.  KnetArrays and Arrays can be converted to each other as shown above, which involves copying to and from the GPU memory.  Only Float32/64 KnetArrays are fully supported.</p><p>Important differences from the alternative CudaArray are: (1) a custom memory manager that minimizes the number of calls to the slow cudaMalloc by reusing already allocated but garbage collected GPU pointers.  (2) a custom getindex that handles ranges such as <code>a[5:10]</code> as views with shared memory instead of copies.  (3) custom CUDA kernels that implement elementwise, broadcasting, and reduction operations.</p><p><strong>Supported functions:</strong></p><ul><li><p>Array operations: ==, !=, cat, convert, copy, copy!, deepcopy, display, eachindex, eltype, endof, fill!, first, getindex, hcat, isapprox, isempty, length, linearindexing, ndims, ones, pointer, rand!, reshape, setindex!, similar, size, stride, strides, summary, vcat, vec, zeros.  (Only Integer, Colon, and UnitRange indices supported for get/setindex.  CartesianIndex, StepRange, Array, and Bool indices not supported.  cat(i,x,y) supported for i=1,2.)</p></li><li><p>Math operators: (-), abs, abs2, acos, acosh, asin, asinh, atan, atanh, cbrt, ceil, cos, cosh, cospi, erf, erfc, erfcinv, erfcx, erfinv, exp, exp10, exp2, expm1, floor, log, log10, log1p, log2, round, sign, sin, sinh, sinpi, sqrt, tan, tanh, trunc</p></li><li><p>Broadcasting operators: (.*), (.+), (.-), (./), (.&lt;), (.&lt;=), (.!=), (.==), (.&gt;), (.&gt;=), (.^), max, min.  (Only Array-Scalar and Array-Vector broadcasting are supported. Boolean operators generate outputs with same type as inputs; no support for KnetArray{Bool}.)</p></li><li><p>Reduction operators: countnz, maximum, minimum, prod, sum, sumabs, sumabs2, vecnorm.  (Only Array-&gt;Scalar and Array-&gt;Vector reductions are supported)</p></li><li><p>Linear algebra: (*), axpy!, permutedims (only 2D and 3D), transpose</p></li><li><p>Knet extras: relu, sigm, invx, logp, logsumexp, conv4, pool, deconv4, unpool, mat, update! (Only 4D/5D, Float32/64 KnetArrays support conv4, pool, deconv4, unpool)</p></li></ul><p><strong>Memory management</strong></p><p>Knet models do not overwrite arrays which need to be preserved for gradient calculation.  This leads to a lot of allocation and regular GPU memory allocation is prohibitively slow. Fortunately most models use identically sized arrays over and over again, so we can minimize the number of actual allocations by reusing preallocated but garbage collected pointers.</p><p>When Julia gc reclaims a KnetArray, a special finalizer keeps its pointer in a table instead of releasing the memory.  If an array with the same size in bytes is later requested, the same pointer is reused. The exact algorithm for allocation is:</p><ol><li><p>Try to find a previously allocated and garbage collected pointer in the current device. (0.5 μs)</p></li><li><p>If not available, try to allocate a new array using cudaMalloc. (10 μs)</p></li><li><p>If not successful, try running gc() and see if we get a pointer of the right size. (75 ms, but this should be amortized over all reusable pointers that become available due to the gc)</p></li><li><p>Finally if all else fails, clean up all saved pointers in the current device using cudaFree and try allocation one last time. (25-70 ms, however this causes the elimination of all reusable pointers)</p></li></ol></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/karray.jl#L1-L80">source</a><br/></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.dir" href="#Knet.dir"><code>Knet.dir</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Knet.dir(path...)</code></pre><p>Construct a path relative to Knet root.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; Knet.dir(&quot;examples&quot;,&quot;mnist.jl&quot;)
&quot;/home/dyuret/.julia/v0.5/Knet/examples/mnist.jl&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/Knet.jl#L22-L32">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.gpu" href="#Knet.gpu"><code>Knet.gpu</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>gpu()</code> returns the id of the active GPU device or -1 if none are active.</p><p><code>gpu(true)</code> resets all GPU devices and activates the one with the most available memory.</p><p><code>gpu(false)</code> resets and deactivates all GPU devices.</p><p><code>gpu(d::Int)</code> activates the GPU device <code>d</code> if <code>0 &lt;= d &lt; gpuCount()</code>, otherwise deactivates devices.</p><p><code>gpu(true/false)</code> resets all devices.  If there are any allocated KnetArrays their pointers will be left dangling.  Thus <code>gpu(true/false)</code> should only be used during startup.  If you want to suspend GPU use temporarily, use <code>gpu(-1)</code>.</p><p><code>gpu(d::Int)</code> does not reset the devices.  You can select a previous device and find allocated memory preserved.  However trying to operate on arrays of an inactive device will result in error.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/gpu.jl#L24-L46">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.logp" href="#Knet.logp"><code>Knet.logp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logp(x,[dims])</code></pre><p>Treat entries in <code>x</code> as as unnormalized log probabilities and return normalized log probabilities.</p><p><code>dims</code> is an optional argument, if not specified the normalization is over the whole <code>x</code>, otherwise the normalization is performed over the given dimensions.  In particular, if <code>x</code> is a matrix, <code>dims=1</code> normalizes columns of <code>x</code> and <code>dims=2</code> normalizes rows of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/unary.jl#L139-L151">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.logsumexp" href="#Knet.logsumexp"><code>Knet.logsumexp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">logsumexp(x,[dims])</code></pre><p>Compute <code>log(sum(exp(x),dims))</code> in a numerically stable manner.</p><p><code>dims</code> is an optional argument, if not specified the summation is over the whole <code>x</code>, otherwise the summation is performed over the given dimensions.  In particular if <code>x</code> is a matrix, <code>dims=1</code> sums columns of <code>x</code> and <code>dims=2</code> sums rows of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/reduction.jl#L88-L99">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.invx" href="#Knet.invx"><code>Knet.invx</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>invx(x) = (1./x)</code></p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/unary.jl#L129">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.relu" href="#Knet.relu"><code>Knet.relu</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>relu(x) = max(0,x)</code></p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/unary.jl#L130">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.sigm" href="#Knet.sigm"><code>Knet.sigm</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>sigm(x) = (1./(1+exp(-x)))</code></p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/unary.jl#L131">source</a><br/></section><h2><a class="nav-anchor" id="Convolution-and-Pooling-1" href="#Convolution-and-Pooling-1">Convolution and Pooling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.conv4" href="#Knet.conv4"><code>Knet.conv4</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">conv4(w, x; kwargs...)</code></pre><p>Execute convolutions or cross-correlations using filters specified with <code>w</code> over tensor <code>x</code>.</p><p>Currently KnetArray{Float32/64,4/5} and Array{Float32/64,4} are supported as <code>w</code> and <code>x</code>.  If <code>w</code> has dimensions <code>(W1,W2,...,I,O)</code> and <code>x</code> has dimensions <code>(X1,X2,...,I,N)</code>, the result <code>y</code> will have dimensions <code>(Y1,Y2,...,O,N)</code> where</p><pre><code class="language-none">Yi=1+floor((Xi+2*padding[i]-Wi)/stride[i])</code></pre><p>Here <code>I</code> is the number of input channels, <code>O</code> is the number of output channels, <code>N</code> is the number of instances, and <code>Wi,Xi,Yi</code> are spatial dimensions.  <code>padding</code> and <code>stride</code> are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.</p><p><strong>Keywords</strong></p><ul><li><p><code>padding=0</code>: the number of extra zeros implicitly concatenated at the start and at the end of each dimension.</p></li><li><p><code>stride=1</code>: the number of elements to slide to reach the next filtering window.</p></li><li><p><code>upscale=1</code>: upscale factor for each dimension.</p></li><li><p><code>mode=0</code>: 0 for convolution and 1 for cross-correlation.</p></li><li><p><code>alpha=1</code>: can be used to scale the result.</p></li><li><p><code>algo=0</code>: specifies which convolution algorithm shoud be used to compute the results. See the CUDNN User Guide for details.</p></li><li><p><code>workSpace=C_NULL</code>: data pointer to GPU memory to a workspace needed to able to execute the specified algorithm.</p></li><li><p><code>workSpaceSizeInBytes=0</code>: the size in bytes of the provided workSpace. Default=0.</p></li><li><p><code>handle</code>: handle to a previously created cuDNN context. Defaults to a Knet allocated handle.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/conv.jl#L1-L34">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.pool" href="#Knet.pool"><code>Knet.pool</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pool(x; kwargs...)</code></pre><p>Compute pooling of input values (i.e., the maximum or average of several adjacent values) to produce an output with smaller height and/or width.  </p><p>Currently 4 or 5 dimensional KnetArrays with <code>Float32</code> or <code>Float64</code> entries are supported.  If <code>x</code> has dimensions <code>(X1,X2,...,I,N)</code>, the result <code>y</code> will have dimensions <code>(Y1,Y2,...,I,N)</code> where</p><pre><code class="language-none">Yi=1+floor((Xi+2*padding[i]-window[i])/stride[i])</code></pre><p>Here <code>I</code> is the number of input channels, <code>N</code> is the number of instances, and <code>Xi,Yi</code> are spatial dimensions.  <code>window</code>, <code>padding</code> and <code>stride</code> are keyword arguments that can be specified as a single number (in which case they apply to all dimensions), or an array/tuple with entries for each spatial dimension.</p><p><strong>Keywords:</strong></p><ul><li><p><code>window=2</code>: the pooling window size for each dimension.</p></li><li><p><code>padding=0</code>: the number of extra zeros implicitly concatenated at the start and at the end of each dimension.</p></li><li><p><code>stride=window</code>: the number of elements to slide to reach the next pooling window.</p></li><li><p><code>mode=0</code>: 0 for max, 1 for average including padded values, 2 for average excluding padded values.</p></li><li><p><code>maxpoolingNanOpt=0</code>: Nan numbers are not propagated if 0, they are propagated if 1.</p></li><li><p><code>alpha=1</code>: can be used to scale the result.</p></li><li><p><code>handle</code>: Handle to a previously created cuDNN context. Defaults to a Knet allocated handle.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/conv.jl#L94-L124">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.mat" href="#Knet.mat"><code>Knet.mat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mat(x)</code></pre><p>Reshape x into a two-dimensional matrix.</p><p>This is typically used when turning the output of a 4-D convolution result into a 2-D input for a fully connected layer.  For 1-D inputs returns <code>reshape(x, (length(x),1))</code>.  For inputs with more than two dimensions of size <code>(X1,X2,...,XD)</code>, returns</p><pre><code class="language-none">reshape(x, (X1*X2*...*X[D-1],XD))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/linalg.jl#L105-L118">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.deconv4" href="#Knet.deconv4"><code>Knet.deconv4</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Deconvolution; <code>reverse</code> of convolution.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/conv.jl#L171-L175">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.unpool" href="#Knet.unpool"><code>Knet.unpool</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Unpooling; <code>reverse</code> of pooling.</p><pre><code class="language-none">x == pool(unpool(x;o...); o...)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/conv.jl#L149-L155">source</a><br/></section><h2><a class="nav-anchor" id="Optimization-methods-1" href="#Optimization-methods-1">Optimization methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.update!" href="#Knet.update!"><code>Knet.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">update!(weights, gradients, params)
update!(weights, gradients; lr=0.001, gclip=0)</code></pre><p>Update the <code>weights</code> using their <code>gradients</code> and the optimization algorithm parameters specified by <code>params</code>.  The 2-arg version defaults to the <a href="reference.html#Knet.Sgd"><code>Sgd</code></a> algorithm with learning rate <code>lr</code> and gradient clip <code>gclip</code>.  <code>gclip==0</code> indicates no clipping. The <code>weights</code> and possibly <code>gradients</code> and <code>params</code> are modified in-place.</p><p><code>weights</code> can be an individual numeric array or a collection of arrays represented by an iterator or dictionary.  In the individual case, <code>gradients</code> should be a similar numeric array of <code>size(weights)</code> and <code>params</code> should be a single object.  In the collection case, each individual weight array should have a corresponding params object. This way different weight arrays can have their own optimization state, different learning rates, or even different optimization algorithms running in parallel.  In the iterator case, <code>gradients</code> and <code>params</code> should be iterators of the same length as <code>weights</code> with corresponding elements.  In the dictionary case, <code>gradients</code> and <code>params</code> should be dictionaries with the same keys as <code>weights</code>.</p><p>Individual optimization parameters can be one of the following types. The keyword arguments for each type&#39;s constructor and their default values are listed as well.</p><ul><li><p><a href="reference.html#Knet.Sgd"><code>Sgd</code></a><code>(;lr=0.001, gclip=0)</code></p></li><li><p><a href="reference.html#Knet.Momentum"><code>Momentum</code></a><code>(;lr=0.001, gclip=0, gamma=0.9)</code></p></li><li><p><a href="reference.html#Knet.Rmsprop"><code>Rmsprop</code></a><code>(;lr=0.001, gclip=0, rho=0.9, eps=1e-6)</code></p></li><li><p><a href="reference.html#Knet.Adagrad"><code>Adagrad</code></a><code>(;lr=0.1, gclip=0, eps=1e-6)</code></p></li><li><p><a href="reference.html#Knet.Adadelta"><code>Adadelta</code></a><code>(;lr=0.01, gclip=0, rho=0.9, eps=1e-6)</code></p></li><li><p><a href="reference.html#Knet.Adam"><code>Adam</code></a><code>(;lr=0.001, gclip=0, beta1=0.9, beta2=0.999, eps=1e-8)</code></p></li></ul><p><strong>Example:</strong></p><pre><code class="language-none">w = rand(d)                 # an individual weight array
g = lossgradient(w)         # gradient g has the same shape as w
update!(w, g)               # update w in-place with Sgd()
update!(w, g; lr=0.1)       # update w in-place with Sgd(lr=0.1)
update!(w, g, Sgd(lr=0.1))  # update w in-place with Sgd(lr=0.1)

w = (rand(d1), rand(d2))    # a tuple of weight arrays
g = lossgradient2(w)        # g will also be a tuple
p = (Adam(), Sgd())         # p has params for each w[i]
update!(w, g, p)            # update each w[i] in-place with g[i],p[i]

w = Any[rand(d1), rand(d2)] # any iterator can be used
g = lossgradient3(w)        # g will be similar to w
p = Any[Adam(), Sgd()]      # p should be an iterator of same length
update!(w, g, p)            # update each w[i] in-place with g[i],p[i]

w = Dict(:a =&gt; rand(d1), :b =&gt; rand(d2)) # dictionaries can be used
g = lossgradient4(w)
p = Dict(:a =&gt; Adam(), :b =&gt; Sgd())
update!(w, g, p)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/update.jl#L261-L318">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.Sgd" href="#Knet.Sgd"><code>Knet.Sgd</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Sgd(;lr=0.001,gclip=0)
update!(w,g,p::Sgd)
update!(w,g;lr=0.001)</code></pre><p>Container for parameters of the Stochastic gradient descent (SGD) optimization algorithm used by <a href="reference.html#Knet.update!"><code>update!</code></a>.</p><p>SGD is an optimization technique to minimize an objective function by updating its weights in the opposite direction of their gradient. The learning rate (lr) determines the size of the step.  SGD updates the weights with the following formula:</p><pre><code class="language-none">w = w - lr * g</code></pre><p>where <code>w</code> is a weight array, <code>g</code> is the gradient of the loss function w.r.t <code>w</code> and <code>lr</code> is the learning rate.</p><p>If <code>vecnorm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>SGD is used by default if no algorithm is specified in the two argument version of <code>update!</code>[@ref].</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/update.jl#L1-L26">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.Momentum" href="#Knet.Momentum"><code>Knet.Momentum</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Momentum(;lr=0.001, gclip=0, gamma=0.9)
update(w,g,p::Momentum)</code></pre><p>Container for parameters of the Momentum optimization algorithm used by <a href="reference.html#Knet.update!"><code>update!</code></a>.</p><p>The Momentum method tries to accelerate SGD by adding a velocity term to the update.  This also decreases the oscillation between successive steps. It updates the weights with the following formulas:</p><pre><code class="language-none">velocity = gamma * velocity + lr * g
w = w - velocity</code></pre><p>where <code>w</code> is a weight array, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>gamma</code> is the momentum parameter, <code>velocity</code> is an array with the same size and type of <code>w</code> and holds the accelerated gradients.</p><p>If <code>vecnorm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="http://doi.org/10.1016/S0893-6080(98)00116-6">Qian, N. (1999)</a>. On the momentum term in gradient descent learning algorithms.  Neural Networks : The Official Journal of the International Neural Network Society, 12(1), 145–151.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/update.jl#L37-L66">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.Adagrad" href="#Knet.Adagrad"><code>Knet.Adagrad</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Adagrad(;lr=0.1, gclip=0, eps=1e-6)
update(w,g,p::Adagrad)</code></pre><p>Container for parameters of the Adagrad optimization algorithm used by <a href="reference.html#Knet.update!"><code>update!</code></a>.</p><p>Adagrad is one of the methods that adapts the learning rate to each of the weights.  It stores the sum of the squares of the gradients to scale the learning rate.  The learning rate is adapted for each weight by the value of current gradient divided by the accumulated gradients. Hence, the learning rate is greater for the parameters where the accumulated gradients are small and the learning rate is small if the accumulated gradients are large. It updates the weights with the following formulas:</p><pre><code class="language-none">G = G + g .^ 2
w = w - g .* lr ./ sqrt(G + eps)</code></pre><p>where <code>w</code> is the weight, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>G</code> is an array with the same size and type of <code>w</code> and holds the sum of the squares of the gradients. <code>eps</code> is a small constant to prevent a zero value in the denominator.</p><p>If <code>vecnorm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="http://jmlr.org/papers/v12/duchi11a.html">Duchi, J., Hazan, E., &amp; Singer, Y. (2011)</a>. Adaptive Subgradient Methods for Online Learning and Stochastic Optimization. Journal of Machine Learning Research, 12, 2121–2159.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/update.jl#L77-L111">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.Adadelta" href="#Knet.Adadelta"><code>Knet.Adadelta</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Adadelta(;lr=0.01, gclip=0, rho=0.9, eps=1e-6)
update(w,g,p::Adadelta)</code></pre><p>Container for parameters of the Adadelta optimization algorithm used by <a href="reference.html#Knet.update!"><code>update!</code></a>.</p><p>Adadelta is an extension of Adagrad that tries to prevent the decrease of the learning rates to zero as training progresses. It scales the learning rate based on the accumulated gradients like Adagrad and holds the acceleration term like Momentum. It updates the weights with the following formulas:</p><pre><code class="language-none">G = (1-rho) * g .^ 2 + rho * G
update = g .* sqrt(delta + eps) ./ sqrt(G + eps)
w = w - lr * update
delta = rho * delta + (1-rho) * update .^ 2</code></pre><p>where <code>w</code> is the weight, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>G</code> is an array with the same size and type of <code>w</code> and holds the sum of the squares of the gradients. <code>eps</code> is a small constant to prevent a zero value in the denominator.  <code>rho</code> is the momentum parameter and <code>delta</code> is an array with the same size and type of <code>w</code> and holds the sum of the squared updates.</p><p>If <code>vecnorm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="http://arxiv.org/abs/1212.5701">Zeiler, M. D. (2012)</a>. ADADELTA: An Adaptive Learning Rate Method.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/update.jl#L122-L156">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.Rmsprop" href="#Knet.Rmsprop"><code>Knet.Rmsprop</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Rmsprop(;lr=0.001, gclip=0, rho=0.9, eps=1e-6)
update(w,g,p::Rmsprop)</code></pre><p>Container for parameters of the Rmsprop optimization algorithm used by <a href="reference.html#Knet.update!"><code>update!</code></a>.</p><p>Rmsprop scales the learning rates by dividing the root mean squared of the gradients. It updates the weights with the following formula:</p><pre><code class="language-none">G = (1-rho) * g .^ 2 + rho * G
w = w - lr * g ./ sqrt(G + eps)</code></pre><p>where <code>w</code> is the weight, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>G</code> is an array with the same size and type of <code>w</code> and holds the sum of the squares of the gradients. <code>eps</code> is a small constant to prevent a zero value in the denominator.  <code>rho</code> is the momentum parameter and <code>delta</code> is an array with the same size and type of <code>w</code> and holds the sum of the squared updates.</p><p>If <code>vecnorm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="https://dirtysalt.github.io/images/nn-class-lec6.pdf">Tijmen Tieleman and Geoffrey Hinton (2012)</a>. &quot;Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude.&quot;  COURSERA: Neural Networks for Machine Learning 4.2.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/update.jl#L169-L199">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.Adam" href="#Knet.Adam"><code>Knet.Adam</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Adam(;lr=0.001, gclip=0, beta1=0.9, beta2=0.999, eps=1e-8)
update(w,g,p::Adam)</code></pre><p>Container for parameters of the Adam optimization algorithm used by <a href="reference.html#Knet.update!"><code>update!</code></a>.</p><p>Adam is one of the methods that compute the adaptive learning rate. It stores accumulated gradients (first moment) and the sum of the squared of gradients (second).  It scales the first and second moment as a function of time. Here is the update formulas:</p><pre><code class="language-none">m = beta1 * m + (1 - beta1) * g
v = beta2 * v + (1 - beta2) * g .* g
mhat = m ./ (1 - beta1 ^ t)
vhat = v ./ (1 - beta2 ^ t)
w = w - (lr / (sqrt(vhat) + eps)) * mhat</code></pre><p>where <code>w</code> is the weight, <code>g</code> is the gradient of the objective function w.r.t <code>w</code>, <code>lr</code> is the learning rate, <code>m</code> is an array with the same size and type of <code>w</code> and holds the accumulated gradients. <code>v</code> is an array with the same size and type of <code>w</code> and holds the sum of the squares of the gradients. <code>eps</code> is a small constant to prevent a zero denominator. <code>beta1</code> and <code>beta2</code> are the parameters to calculate bias corrected first and second moments. <code>t</code> is the update count.</p><p>If <code>vecnorm(g) &gt; gclip &gt; 0</code>, <code>g</code> is scaled so that its norm is equal to <code>gclip</code>.  If <code>gclip==0</code> no scaling takes place.</p><p>Reference: <a href="https://arxiv.org/abs/1412.6980">Kingma, D. P., &amp; Ba, J. L. (2015)</a>. Adam: a Method for Stochastic Optimization. International Conference on Learning Representations, 1–13.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/update.jl#L211-L246">source</a><br/></section><h2><a class="nav-anchor" id="Initialization-1" href="#Initialization-1">Initialization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.gaussian" href="#Knet.gaussian"><code>Knet.gaussian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gaussian(a...; mean=0.0, std=0.01)</code></pre><p>Return a Gaussian array with a given mean and standard deviation.  The <code>a</code> arguments are passed to <code>randn</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/distributions.jl#L1-L8">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.xavier" href="#Knet.xavier"><code>Knet.xavier</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">xavier(a...)</code></pre><p>Xavier initialization.  The <code>a</code> arguments are passed to <code>rand</code>.  See (<a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf">Glorot and Bengio 2010</a>) for a description. <a href="http://caffe.berkeleyvision.org/doxygen/classcaffe_1_1XavierFiller.html#details">Caffe</a> implements this slightly differently. <a href="http://lasagne.readthedocs.org/en/latest/modules/init.html#lasagne.init.GlorotUniform">Lasagne</a> calls it <code>GlorotUniform</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/distributions.jl#L13-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Knet.bilinear" href="#Knet.bilinear"><code>Knet.bilinear</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Bilinear interpolation filter weights; used for initializing deconvolution layers.</p><p>Adapted from https://github.com/shelhamer/fcn.berkeleyvision.org/blob/master/surgery.py#L33</p><p>Arguments:</p><p><code>T</code> : Data Type</p><p><code>fw</code>: Width upscale factor</p><p><code>fh</code>: Height upscale factor</p><p><code>IN</code>: Number of input filters</p><p><code>ON</code>: Number of output filters</p><p>Example usage:</p><p>w = bilinear(Float32,2,2,128,128)</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/Knet.jl/tree/62b5a91482c94d67ee17d9ff8bc17417ad7cf305/src/distributions.jl#L42-L65">source</a><br/></section><h2><a class="nav-anchor" id="AutoGrad-(advanced)-1" href="#AutoGrad-(advanced)-1">AutoGrad (advanced)</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AutoGrad.@primitive" href="#AutoGrad.@primitive"><code>AutoGrad.@primitive</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@primitive fx g1 g2...</code></pre><p>Define a new primitive operation for AutoGrad and (optionally) specify its gradients.  Non-differentiable functions such as <code>sign</code>, and non-numeric functions such as <code>size</code> should be defined using the @zerograd macro instead.</p><p><strong>Examples</strong></p><pre><code class="language-none">@primitive sin(x::Number)
@primitive hypot(x1::Array,x2::Array),dy,y

@primitive sin(x::Number),dy  (dy*cos(x))
@primitive hypot(x1::Array,x2::Array),dy,y  (dy.*x1./y)  (dy.*x2./y)</code></pre><p>The first example shows that <code>fx</code> is a typed method declaration. Julia supports multiple dispatch, i.e. a single function can have multiple methods with different arg types.  AutoGrad takes advantage of this and supports multiple dispatch for primitives and gradients.</p><p>The second example specifies variable names for the output gradient <code>dy</code> and the output <code>y</code> after the method declaration which can be used in gradient expressions.  Untyped, ellipsis and keyword arguments are ok as in <code>f(a::Int,b,c...;d=1)</code>.  Parametric methods such as <code>f{T&lt;:Number}(x::T)</code> cannot be used.</p><p>The method declaration can optionally be followed by gradient expressions.  The third and fourth examples show how gradients can be specified.  Note that the parameters, the return variable and the output gradient of the original function can be used in the gradient expressions.</p><p><strong>Under the hood</strong></p><p>The @primitive macro turns the first example into:</p><pre><code class="language-none">local sin_r = recorder(sin)
sin{T&lt;:Number}(x::Rec{T}) = sin_r(x)</code></pre><p>This will cause calls to <code>sin</code> with a boxed argument (<code>Rec{T&lt;:Number}</code>) to be recorded.  The recorded operations are used by <code>grad</code> to construct a dynamic computational graph.  With multiple arguments things are a bit more complicated.  Here is what happens with the second example:</p><pre><code class="language-none">local hypot_r = recorder(hypot)
hypot{T&lt;:Array,S&lt;:Array}(x1::Rec{T},x2::Rec{S})=hypot_r(x1,x2)
hypot{T&lt;:Array,S&lt;:Array}(x1::Rec{T},x2::S)=hypot_r(x1,x2)
hypot{T&lt;:Array,S&lt;:Array}(x1::T,x2::Rec{S})=hypot_r(x1,x2)</code></pre><p>We want the recorder version to be called if any one of the arguments is a boxed <code>Rec</code>.  There is no easy way to specify this in Julia, so the macro generates all 2^N-1 boxed/unboxed argument combinations.</p><p>In AutoGrad, gradients are defined using gradient methods that have the following signature:</p><pre><code class="language-none">f(Grad{i},dy,y,x...) =&gt; dx[i]</code></pre><p>For the third example here is the generated gradient method:</p><pre><code class="language-none">sin{T&lt;:Number}(::Type{Grad{1}}, dy, y, x::Rec{T})=(dy*cos(x))</code></pre><p>For the last example a different gradient method is generated for each argument:</p><pre><code class="language-none">hypot{T&lt;:Array,S&lt;:Array}(::Type{Grad{1}},dy,y,x1::Rec{T},x2::Rec{S})=(dy.*x1./y)
hypot{T&lt;:Array,S&lt;:Array}(::Type{Grad{2}},dy,y,x1::Rec{T},x2::Rec{S})=(dy.*x2./y)</code></pre><p>In fact @primitive generates four more definitions for the other boxed/unboxed argument combinations.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/AutoGrad.jl/tree/e0530fe89378cf3f137f00d6bc576d5ef3122f75/src/util.jl#L12-L86">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AutoGrad.@zerograd" href="#AutoGrad.@zerograd"><code>AutoGrad.@zerograd</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@zerograd f(args...; kwargs...)</code></pre><p>Define <code>f</code> as an AutoGrad primitive operation with zero gradient.</p><p><strong>Example:</strong></p><pre><code class="language-none">@zerograd floor(x::Float32)</code></pre><p><code>@zerograd</code> allows <code>f</code> to handle boxed <code>Rec</code> inputs by unboxing them like a <code>@primitive</code>, but unlike <code>@primitive</code> it does not record its actions or return a boxed <code>Rec</code> result.  Some functions, like <code>sign()</code>, have zero gradient.  Others, like <code>length()</code> have discrete or constant outputs.  These need to handle <code>Rec</code> inputs, but do not need to record anything and can return regular values.  Their output can be treated like a constant in the program.  Use the <code>@zerograd</code> macro for those.  Note that <code>kwargs</code> are NOT unboxed.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/AutoGrad.jl/tree/e0530fe89378cf3f137f00d6bc576d5ef3122f75/src/util.jl#L117-L136">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AutoGrad.getval" href="#AutoGrad.getval"><code>AutoGrad.getval</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getval(x)</code></pre><p>Unbox <code>x</code> if it is a boxed value (<code>Rec</code>), otherwise return <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/denizyuret/AutoGrad.jl/tree/e0530fe89378cf3f137f00d6bc576d5ef3122f75/src/core.jl#L158-L164">source</a><br/></section><h2><a class="nav-anchor" id="Function-Index-1" href="#Function-Index-1">Function Index</a></h2><ul><li><a href="reference.html#Knet.Adadelta"><code>Knet.Adadelta</code></a></li><li><a href="reference.html#Knet.Adagrad"><code>Knet.Adagrad</code></a></li><li><a href="reference.html#Knet.Adam"><code>Knet.Adam</code></a></li><li><a href="reference.html#Knet.KnetArray"><code>Knet.KnetArray</code></a></li><li><a href="reference.html#Knet.Momentum"><code>Knet.Momentum</code></a></li><li><a href="reference.html#Knet.Rmsprop"><code>Knet.Rmsprop</code></a></li><li><a href="reference.html#Knet.Sgd"><code>Knet.Sgd</code></a></li><li><a href="reference.html#AutoGrad.getval"><code>AutoGrad.getval</code></a></li><li><a href="reference.html#AutoGrad.grad"><code>AutoGrad.grad</code></a></li><li><a href="reference.html#AutoGrad.gradcheck"><code>AutoGrad.gradcheck</code></a></li><li><a href="reference.html#AutoGrad.gradloss"><code>AutoGrad.gradloss</code></a></li><li><a href="reference.html#Knet.bilinear"><code>Knet.bilinear</code></a></li><li><a href="reference.html#Knet.conv4"><code>Knet.conv4</code></a></li><li><a href="reference.html#Knet.deconv4"><code>Knet.deconv4</code></a></li><li><a href="reference.html#Knet.dir"><code>Knet.dir</code></a></li><li><a href="reference.html#Knet.gaussian"><code>Knet.gaussian</code></a></li><li><a href="reference.html#Knet.gpu"><code>Knet.gpu</code></a></li><li><a href="reference.html#Knet.invx"><code>Knet.invx</code></a></li><li><a href="reference.html#Knet.logp"><code>Knet.logp</code></a></li><li><a href="reference.html#Knet.logsumexp"><code>Knet.logsumexp</code></a></li><li><a href="reference.html#Knet.mat"><code>Knet.mat</code></a></li><li><a href="reference.html#Knet.pool"><code>Knet.pool</code></a></li><li><a href="reference.html#Knet.relu"><code>Knet.relu</code></a></li><li><a href="reference.html#Knet.sigm"><code>Knet.sigm</code></a></li><li><a href="reference.html#Knet.unpool"><code>Knet.unpool</code></a></li><li><a href="reference.html#Knet.update!"><code>Knet.update!</code></a></li><li><a href="reference.html#Knet.xavier"><code>Knet.xavier</code></a></li><li><a href="reference.html#AutoGrad.@primitive"><code>AutoGrad.@primitive</code></a></li><li><a href="reference.html#AutoGrad.@zerograd"><code>AutoGrad.@zerograd</code></a></li></ul><footer><hr/><a class="previous" href="examples.html"><span class="direction">Previous</span><span class="title">Examples</span></a><a class="next" href="backprop.html"><span class="direction">Next</span><span class="title">Backpropagation</span></a></footer></article></body></html>
