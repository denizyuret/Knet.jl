<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Backpropagation · Knet.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>Knet.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="install.html">Setting up Knet</a></li><li><a class="toctext" href="tutorial.html">Introduction to Knet</a></li><li><a class="toctext" href="examples.html">Examples</a></li><li><a class="toctext" href="reference.html">Reference</a></li></ul></li><li><span class="toctext">Textbook</span><ul><li class="current"><a class="toctext" href="backprop.html">Backpropagation</a><ul class="internal"><li><a class="toctext" href="#Partial-derivatives-1">Partial derivatives</a></li><li><a class="toctext" href="#Chain-rule-1">Chain rule</a></li><li><a class="toctext" href="#Multiple-dimensions-1">Multiple dimensions</a></li><li><a class="toctext" href="#Multiple-instances-1">Multiple instances</a></li><li><a class="toctext" href="#Stochastic-Gradient-Descent-1">Stochastic Gradient Descent</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="softmax.html">Softmax Classification</a></li><li><a class="toctext" href="mlp.html">Multilayer Perceptrons</a></li><li><a class="toctext" href="cnn.html">Convolutional Neural Networks</a></li><li><a class="toctext" href="rnn.html">Recurrent Neural Networks</a></li><li><a class="toctext" href="rl.html">Reinforcement Learning</a></li><li><a class="toctext" href="opt.html">Optimization</a></li><li><a class="toctext" href="gen.html">Generalization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Textbook</li><li><a href="backprop.html">Backpropagation</a></li></ul><a class="edit-page" href="https://github.com/denizyuret/Knet.jl/tree/4d8fa3bbb6749a82718b37a7e62370f416342b30/docs/src/backprop.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Backpropagation-1" href="#Backpropagation-1">Backpropagation</a></h1><div class="admonition note"><div class="admonition-title">Concepts</div><div class="admonition-text"><p>supervised learning, training data, regression, squared error, linear regression, stochastic gradient descent</p></div></div><p>Arthur Samuel, the author of the first self-learning checkers program, defined machine learning as a &quot;field of study that gives computers the ability to learn without being explicitly programmed&quot;. This leaves the definition of learning a bit circular. Tom M. Mitchell provided a more formal definition: &quot;A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P if its performance at tasks in T, as measured by P, improves with experience E,&quot; where the task, the experience, and the performance measure are to be specified based on the problem.</p><p>We will start with <strong>supervised learning</strong>, where the task is to predict the output of an unknown system given its input, and the experience consists of a set of example input-output pairs, also known as the <strong>training data</strong>. When the outputs are numeric such problems are called <strong>regression</strong>. In <strong>linear regression</strong> we use a linear function as our model:</p><div>\[\hat{y} = W x + b\]</div><p>Here <span>$x$</span> is the model input, <span>$\hat{y}$</span> is the model output, <span>$W$</span> is a matrix of weights, and <span>$b$</span> is a vector of biases. By adjusting the parameters of this model, i.e. the weights and the biases, we can make it compute any linear function of <span>$x$</span>.</p><p>&quot;All models are wrong, but some models are useful.&quot; George Box famously said. We do not necessarily know that the system whose output we are trying to predict is governed by a linear relationship. All we know is a finite number of input-output examples:</p><div>\[\mathcal{D}=\{(x_1,y_1),\ldots,(x_N,y_N)\}\]</div><p>It is just that we have to start model building somewhere and the set of all linear functions is a good place to start for now.</p><p>A commonly used performance measure in regression problems is the <strong>squared error</strong>, i.e. the average squared difference between the actual output values and the ones predicted by the model. So our goal is to find model parameters that minimize the squared error:</p><div>\[\arg\min_{W,b} \frac{1}{N} \sum_{n=1}^N \| \hat{y}_n - y_n \|^2\]</div><p>Where <span>$\hat{y}_n = W x_n + b$</span> denotes the output predicted by the model for the <span>$n$</span> th example.</p><p>There are several methods to find the solution to the problem of minimizing squared error. Here we will present the <strong>stochastic gradient descent</strong> (SGD) method because it generalizes well to more complex models. In SGD, we take the training examples one at a time (or in small groups called minibatches), compute the gradient of the error with respect to the parameters, and move the parameters a small step in the direction that will decrease the error. First some notes on the math.</p><h2><a class="nav-anchor" id="Partial-derivatives-1" href="#Partial-derivatives-1">Partial derivatives</a></h2><p>When we have a function with several inputs and one output, we can look at how the function value changes in response to a small change in one of its inputs holding the rest fixed. This is called a partial derivative. Let us consider the squared error for the <span>$n$</span> th input as an example:</p><div>\[J = \| W x_n + b - y_n \|^2\]</div><p>So the partial derivative <span>$\partial J / \partial w_{ij}$</span> would tell us how many units <span>$J$</span> would move if we moved <span>$w_{ij}$</span> in <span>$W$</span> one unit (at least for small enough units). Here is a more graphical representation:</p><blockquote><p><img src="images/linregforw.jpg" alt="image"/></p></blockquote><p>In this figure, it is easier to see that the machinery that generates <span>$J$</span> has many &quot;inputs&quot;. In particular we can talk about how <span>$J$</span> is effected by changing parameters <span>$W$</span> and <span>$b$</span>, as well as changing the input <span>$x$</span>, the model output <span>$\hat{y}$</span>, the desired output <span>$y$</span>, or intermediate values like <span>$z$</span> or <span>$r$</span>. So partial derivatives like <span>$\partial J / \partial x_i$</span> or <span>$\partial J / \partial \hat{y}_j$</span> are fair game and tell us how <span>$J$</span> would react in response to small changes in those quantities.</p><h2><a class="nav-anchor" id="Chain-rule-1" href="#Chain-rule-1">Chain rule</a></h2><p>The chain rule allows us to calculate partial derivatives in terms of other partial derivatives, simplifying the overall computation. We will go over it in some detail as it forms the basis of the backpropagation algorithm. For now let us assume that each of the variables in the above example are scalars. We will start by looking at the effect of <span>$r$</span> on <span>$J$</span> and move backward from there. Basic calculus tells us that:</p><div>\[J = r^2 \\
{\partial J}/{\partial r} = 2r\]</div><p>Thus, if <span>$r=5$</span> and we decrease <span>$r$</span> by a small <span>$\epsilon$</span>, the squared error <span>$J$</span> will go down by <span>$10\epsilon$</span>. Now let&#39;s move back a step and look at <span>$\hat{y}$</span>:</p><div>\[r = \hat{y} - y \\
{\partial r}/{\partial \hat{y}} = 1\]</div><p>So how much effect will a small <span>$\epsilon$</span> decrease in <span>$\hat{y}$</span> have on <span>$J$</span> when <span>$r=5$</span>? Well, when <span>$\hat{y}$</span> goes down by <span>$\epsilon$</span>, so will <span>$r$</span>, which means <span>$J$</span> will go down by <span>$10\epsilon$</span> again. The chain rule expresses this idea:</p><div>\[\frac{\partial J}{\partial\hat{y}} = 
\frac{\partial J}{\partial r}
\frac{\partial r}{\partial\hat{y}}
= 2r\]</div><p>Going back further, we have:</p><div>\[\hat{y} = z + b \\
{\partial \hat{y}}/{\partial b} = 1 \\
{\partial \hat{y}}/{\partial z} = 1 \\\]</div><p>Which means <span>$b$</span> and <span>$z$</span> have the same effect on <span>$J$</span> as <span>$\hat{y}$</span> and <span>$r$</span>, i.e. decreasing them by <span>$\epsilon$</span> will decrease <span>$J$</span> by <span>$2r\epsilon$</span> as well. Finally:</p><div>\[z = w x \\
{\partial z}/{\partial x} = w \\
{\partial z}/{\partial w} = x\]</div><p>This allows us to compute the effect of <span>$w$</span> on <span>$J$</span> in several steps: moving <span>$w$</span> by <span>$\epsilon$</span> will move <span>$z$</span> by <span>$x\epsilon$</span>, <span>$\hat{y}$</span> and <span>$r$</span> will move exactly the same amount because their partials with <span>$z$</span> are 1, and finally since <span>$r$</span> moves by <span>$x\epsilon$</span>, <span>$J$</span> will move by <span>$2rx\epsilon$</span>.</p><div>\[\frac{\partial J}{\partial w} =
\frac{\partial J}{\partial r}
\frac{\partial r}{\partial \hat{y}}
\frac{\partial \hat{y}}{\partial z}
\frac{\partial z}{\partial w}
= 2rx\]</div><p>We can represent this process of computing partial derivatives as follows:</p><blockquote><p><img src="images/linregback.jpg" alt="image"/></p></blockquote><p>Note that we have the same number of boxes and operations, but all the arrows are reversed. Let us call this the backward pass, and the original computation in the previous picture the forward pass. Each box in this backward-pass picture represents the partial derivative for the corresponding box in the previous forward-pass picture. Most importantly, each computation is local: each operation takes the partial derivative of its output, and multiplies it with a factor that only depends on the original input/output values to compute the partial derivative of its input(s). In fact we can implement the forward and backward passes for the linear regression model using the following local operations:</p><blockquote><p><img src="images/sqnorm.jpg" alt="image"/></p></blockquote><blockquote><p><img src="images/sub.jpg" alt="image"/></p></blockquote><blockquote><p><img src="images/add.jpg" alt="image"/></p></blockquote><blockquote><p><img src="images/mul.jpg" alt="image"/></p></blockquote><h2><a class="nav-anchor" id="Multiple-dimensions-1" href="#Multiple-dimensions-1">Multiple dimensions</a></h2><p>Let&#39;s look at the case where the input and output are not scalars but vectors. In particular assume that <span>$x \in \mathbb{R}^D$</span> and <span>$y \in \mathbb{R}^C$</span>. This makes <span>$W \in \mathbb{R}^{C\times D}$</span> a matrix and <span>$z,b,\hat{y},r$</span> vectors in <span>$\mathbb{R}^C$</span>. During the forward pass, <span>$z=Wx$</span> operation is now a matrix-vector product, the additions and subtractions are elementwise operations. The squared error <span>$J=\|r\|^2=\sum r_i^2$</span> is still a scalar. For the backward pass we ask how much each element of these vectors or matrices effect <span>$J$</span>. Starting with <span>$r$</span>:</p><div>\[J = \sum r_i^2 \\
{\partial J}/{\partial r_i} = 2r_i\]</div><p>We see that when <span>$r$</span> is a vector, the partial derivative of each component is equal to twice that component. If we put these partial derivatives together in a vector, we obtain a <strong>gradient</strong> vector:</p><div>\[\nabla_r J
\equiv \langle \frac{\partial J}{\partial r_1}, \cdots, \frac{\partial J}{\partial r_C} \rangle
= \langle 2 r_1, \ldots, 2 r_C \rangle 
= 2\vec{r}\]</div><p>The addition, subtraction, and square norm operations work the same way as before except they act on each element. Moving back through the elementwise operations we see that:</p><div>\[\nabla_r J = \nabla_\hat{y} J = \nabla_b J = \nabla_z J = 2\vec{r}\]</div><p>For the operation <span>$z=Wx$</span>, a little algebra will show you that:</p><div>\[\nabla_W J = \nabla_z J \cdot x^T \\
\nabla_x J = W^T \cdot \nabla_z J\]</div><p>Note that the gradient of a variable has the same shape as the variable itself. In particular <span>$\nabla_W J$</span> is a <span>$C\times D$</span> matrix. Here is the graphical representation for matrix multiplication:</p><blockquote><p><img src="images/dot.jpg" alt="image"/></p></blockquote><h2><a class="nav-anchor" id="Multiple-instances-1" href="#Multiple-instances-1">Multiple instances</a></h2><p>We will typically process data multiple instances at a time for efficiency. Thus, the input <span>$x$</span> will be a <span>$D\times N$</span> matrix, and the output <span>$y$</span> will be a <span>$C\times N$</span> matrix, the <span>$N$</span> columns representing <span>$N$</span> different instances. Please verify to yourself that the forward and backward operations as described above handle this case without much change: the elementwise operations act on the elements of the matrices just like vectors, and the matrix multiplication and its gradient remains the same. Here is a picture of the forward and backward passes:</p><blockquote><p><img src="images/batchforwback.jpg" alt="image"/></p></blockquote><p>The only complication is at the addition of the bias vector. In the batch setting, we are adding <span>$b\in\mathbb{R}^{C\times 1}$</span> to <span>$z\in\mathbb{R}^{C\times N}$</span>. This will be a broadcasting operation, i.e. the vector <span>$b$</span> will be added to each column of the matrix <span>$z$</span> to get <span>$\hat{y}$</span>. In the backward pass, we&#39;ll need to add the columns of <span>$\nabla_\hat{y} J$</span> to get the gradient <span>$\nabla_b J$</span>.</p><h2><a class="nav-anchor" id="Stochastic-Gradient-Descent-1" href="#Stochastic-Gradient-Descent-1">Stochastic Gradient Descent</a></h2><p>The gradients calculated by backprop, <span>$\nabla_w J$</span> and <span>$\nabla_b J$</span>, tell us how much small changes in corresponding entries in <span>$w$</span> and <span>$b$</span> will effect the error (for the last instance, or minibatch). Small steps in the gradient direction will increase the error, steps in the opposite direction will decrease the error.</p><p>In fact, we can show that the gradient is the direction of steepest ascent. Consider a unit vector <span>$v$</span> pointing in some arbitrary direction. The rate of change in this direction is given by the projection of <span>$v$</span> onto the gradient, i.e. their dot product <span>$\nabla J \cdot v$</span>. What direction maximizes this dot product? Recall that:</p><div>\[\nabla J \cdot v = | \nabla J |\,\, | v | \cos(\theta)\]</div><p>where <span>$\theta$</span> is the angle between <span>$v$</span> and the gradient vector. <span>$\cos(\theta)$</span> is maximized when the two vectors point in the same direction. So if you are going to move a fixed (small) size step, the gradient direction gives you the biggest bang for the buck.</p><p>This suggests the following update rule:</p><div>\[w \leftarrow w - \nabla_w J\]</div><p>This is the basic idea behind Stochastic Gradient Descent (SGD): Go over the training set instance by instance (or minibatch by minibatch). Run the backpropagation algorithm to calculate the error gradients. Update the weights and biases in the opposite direction of these gradients. Rinse and repeat...</p><p>Over the years, people have noted many subtle problems with this approach and suggested improvements:</p><p><strong>Step size:</strong> If the step sizes are too small, the SGD algorithm will take too long to converge. If they are too big it will overshoot the optimum and start to oscillate. So we scale the gradients with an adjustable parameter called the learning rate <span>$\eta$</span>:</p><div>\[w \leftarrow w - \eta \nabla_w J\]</div><p><strong>Step direction:</strong> More importantly, it turns out the gradient (or its opposite) is often NOT the direction you want to go in order to minimize error. Let us illustrate with a simple picture:</p><blockquote><p><img src="images/longnarrowvalley.png" alt="image"/></p></blockquote><p>The figure on the left shows what would happen if you stood on one side of the long narrow valley and took the direction of steepest descent: this would point to the other side of the valley and you would end up moving back and forth between the two sides, instead of taking the gentle incline down as in the figure on the right. The direction across the valley has a high gradient but also a high curvature (second derivative) which means the descent will be sharp but short lived. On the other hand the direction following the bottom of the valley has a smaller gradient and low curvature, the descent will be slow but it will continue for a longer distance. <a href="https://en.wikipedia.org/wiki/Newton%27s_method_in_optimization">Newton&#39;s method</a> adjusts the direction taking into account the second derivative:</p><blockquote><p><img src="images/330px-Newton_optimization_vs_grad_descent.svg.png" alt="image"/></p></blockquote><p>In this figure, the two axes are w1 and w2, two parameters of our network, and the contour plot represents the error with a minimum at x. If we start at x0, the Newton direction (in red) points almost towards the minimum, whereas the gradient (in green), perpendicular to the contours, points to the right.</p><p>Unfortunately Newton&#39;s direction is expensive to compute. However, it is also probably unnecessary for several reasons: (1) Newton gives us the ideal direction for second degree objective functions, which our objective function almost certainly is not, (2) The error function whose gradient backprop calculated is the error for the last minibatch/instance only, which at best is a very noisy approximation of the real error function, thus we shouldn&#39;t spend too much effort trying to get the direction exactly right.</p><p>So people have come up with various approximate methods to improve the step direction. Instead of multiplying each component of the gradient with the same learning rate, these methods scale them separately using their running average (momentum, Nesterov), or RMS (Adagrad, Rmsprop). Some even cap the gradients at an arbitrary upper limit (gradient clipping) to prevent unstabilities.</p><p>You may wonder whether these methods still give us directions that consistently increase/decrease the objective function. If we do not insist on the <em>maximum</em> increase, any direction whose components have the same signs as the gradient vector is guaranteed to increase the function (for short enough steps). The reason is again given by the dot product <span>$\nabla J \cdot v$</span>. As long as these two vectors carry the same signs in the same components, the dot product, i.e. the rate of change along <span>$v$</span>, is guaranteed to be positive.</p><p><strong>Minimize what?</strong> The final problem with gradient descent, other than not telling us the ideal step size or direction, is that it is not even minimizing the right objective! We want small error on never before seen test data, not just on the training data. The truth is, a sufficiently large model with a good optimization algorithm can get arbitrarily low error on any finite training data (e.g. by just memorizing the answers). And it can typically do so in many different ways (typically many different local minima for training error in weight space exist). Some of those ways will generalize well to unseen data, some won&#39;t. And unseen data is (by definition) not seen, so how will we ever know which weight settings will do well on it?</p><p>There are at least three ways people deal with this problem: (1) Bayes tells us that we should use all possible models and weigh their answers by how well they do on training data (see Radford Neal&#39;s fbm), (2) New methods like dropout that add distortions and noise to inputs, activations, or weights during training seem to help generalization, (3) Pressuring the optimization to stay in one corner of the weight space (e.g. L1, L2, maxnorm regularization) helps generalization.</p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><ul><li><p><a href="http://ufldl.stanford.edu/tutorial/supervised/LinearRegression">UFLDL Tutorial, Linear Regression</a></p></li></ul><footer><hr/><a class="previous" href="reference.html"><span class="direction">Previous</span><span class="title">Reference</span></a><a class="next" href="softmax.html"><span class="direction">Next</span><span class="title">Softmax Classification</span></a></footer></article></body></html>
