<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Backpropagation and SGD · Knet.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Knet.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../install/">Setting up Knet</a></li><li><a class="tocitem" href="../tutorial/">Introduction to Knet</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul></li><li><span class="tocitem">Textbook</span><ul><li class="is-active"><a class="tocitem" href>Backpropagation and SGD</a><ul class="internal"><li><a class="tocitem" href="#Supervised-learning"><span>Supervised learning</span></a></li><li><a class="tocitem" href="#Partial-derivatives"><span>Partial derivatives</span></a></li><li><a class="tocitem" href="#Chain-rule-and-backpropagation"><span>Chain rule and backpropagation</span></a></li><li><a class="tocitem" href="#Multiple-dimensions"><span>Multiple dimensions</span></a></li><li><a class="tocitem" href="#Multiple-instances"><span>Multiple instances</span></a></li><li><a class="tocitem" href="#Stochastic-Gradient-Descent"><span>Stochastic Gradient Descent</span></a></li><li><a class="tocitem" href="#Housing-Example"><span>Housing Example</span></a></li><li><a class="tocitem" href="#Problems-with-SGD"><span>Problems with SGD</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li><li><a class="tocitem" href="#Notes"><span>Notes</span></a></li></ul></li><li><a class="tocitem" href="../softmax/">Softmax Classification</a></li><li><a class="tocitem" href="../mlp/">Multilayer Perceptrons</a></li><li><a class="tocitem" href="../cnn/">Convolutional Neural Networks</a></li><li><a class="tocitem" href="../rnn/">Recurrent Neural Networks</a></li><li><a class="tocitem" href="../rl/">Reinforcement Learning</a></li><li><a class="tocitem" href="../opt/">Optimization</a></li><li><a class="tocitem" href="../gen/">Generalization</a></li><li><a class="tocitem" href="../nce/">Noise Contrastive Estimation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Textbook</a></li><li class="is-active"><a href>Backpropagation and SGD</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Backpropagation and SGD</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/denizyuret/Knet.jl/blob/master/docs/src/backprop.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Backpropagation-and-SGD"><a class="docs-heading-anchor" href="#Backpropagation-and-SGD">Backpropagation and SGD</a><a id="Backpropagation-and-SGD-1"></a><a class="docs-heading-anchor-permalink" href="#Backpropagation-and-SGD" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Prerequisites</header><div class="admonition-body"><p>basic Julia, linear algebra, calculus</p></div></div><div class="admonition is-info"><header class="admonition-header">Concepts</header><div class="admonition-body"><p>supervised learning, training data, loss function, prediction function, squared error, gradient, backpropagation, stochastic gradient descent </p></div></div><h2 id="Supervised-learning"><a class="docs-heading-anchor" href="#Supervised-learning">Supervised learning</a><a id="Supervised-learning-1"></a><a class="docs-heading-anchor-permalink" href="#Supervised-learning" title="Permalink"></a></h2><p>Arthur Samuel, the author of the first self-learning checkers program, defined machine learning as a &quot;field of study that gives computers the ability to learn without being explicitly programmed&quot;. This leaves the definition of learning a bit circular. Tom M. Mitchell provided a more formal definition: &quot;A computer program is said to learn from <strong>experience</strong> E with respect to some class of <strong>tasks</strong> T and <strong>performance measure</strong> P if its performance at tasks in T, as measured by P, improves with experience E,&quot; where the task, the experience, and the performance measure are to be specified based on the problem.</p><p>We will start with <strong>supervised learning</strong>, where the <em>task</em> is to predict the output of an unknown process given its input, the <em>experience</em> consists of <strong>training data</strong>, a set of example input-output pairs, and the <em>performance measure</em> is given by a <strong>loss function</strong> which tells us how far the predictions are from actual outputs.  </p><p>We model the unknown process using a <strong>prediction function</strong>, a parametric function that predicts the output of the process given its input.  Here is an example:</p><div>\[\hat{y} = W x + b\]</div><p>Here <span>$x$</span> is the model input, <span>$\hat{y}$</span> is the model output, <span>$W$</span> is a matrix of weights, and <span>$b$</span> is a vector of biases. By adjusting the parameters of this model, i.e. the weights and the biases, we can make it compute any linear function of <span>$x$</span>.</p><p><em>&quot;All models are wrong, but some models are useful.&quot;</em> George Box famously said. We do not necessarily know that the system whose output we are trying to predict is governed by a linear relationship. All we know is a finite number of input-output examples in the training data:</p><div>\[\mathcal{D}=\{(x_1,y_1),\ldots,(x_N,y_N)\}\]</div><p>It is just that we have to start model building somewhere and the set of all linear functions is a good place to start for now.</p><p>A commonly used <em>loss function</em> in problems with numeric outputs is the <strong>squared error</strong>, i.e. the average squared difference between the actual output values and the ones predicted by the model. So our goal is to find model parameters that minimize the squared error:</p><div>\[\arg\min_{W,b} \frac{1}{N} \sum_{n=1}^N \| \hat{y}_n - y_n \|^2\]</div><p>Where <span>$\hat{y}_n = W x_n + b$</span> denotes the output predicted by the model for the <span>$n$</span> th example.</p><p>There are several methods to find the solution to the problem of minimizing squared error. Here we will present the <strong>stochastic gradient descent</strong> (SGD) method because it generalizes well to more complex models. In SGD, we take the training examples (individually or in groups), compute the gradient of the error for the current example(s) with respect to the parameters using the <strong>backpropagation</strong> algorithm, and move the parameters a small step in the direction that will decrease the error. First some notes on the math.</p><h2 id="Partial-derivatives"><a class="docs-heading-anchor" href="#Partial-derivatives">Partial derivatives</a><a id="Partial-derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Partial-derivatives" title="Permalink"></a></h2><p>When we have a function with a scalar output, we can look at how its value changes in response to a small change in one of its inputs or parameters, holding the rest fixed. This is called a partial derivative. Let us consider the squared error for the <span>$n$</span> th input as an example:</p><div>\[J = \| W x_n + b - y_n \|^2\]</div><p>So the partial derivative <span>$\partial J / \partial w_{ij}$</span> would tell us how many units <span>$J$</span> would move if we moved <span>$w_{ij}$</span> in <span>$W$</span> one unit (at least for small enough units). Here is a more graphical representation:</p><blockquote><p><img src="../images/linregforw.jpg" alt="image"/></p></blockquote><p>In this figure, it is easier to see that the machinery that generates <span>$J$</span> has many &quot;inputs&quot;. In particular we can talk about how <span>$J$</span> is effected by changing parameters <span>$W$</span> and <span>$b$</span>, as well as changing the input <span>$x$</span>, the model output <span>$\hat{y}$</span>, the desired output <span>$y$</span>, or intermediate values like <span>$z$</span> or <span>$r$</span>. So partial derivatives like <span>$\partial J / \partial x_i$</span> or <span>$\partial J / \partial \hat{y}_j$</span> are fair game and tell us how <span>$J$</span> would react in response to small changes in those quantities.</p><h2 id="Chain-rule-and-backpropagation"><a class="docs-heading-anchor" href="#Chain-rule-and-backpropagation">Chain rule and backpropagation</a><a id="Chain-rule-and-backpropagation-1"></a><a class="docs-heading-anchor-permalink" href="#Chain-rule-and-backpropagation" title="Permalink"></a></h2><p>The chain rule allows us to calculate partial derivatives in terms of other partial derivatives, simplifying the overall computation. We will go over it in some detail as it forms the basis of the backpropagation algorithm. For now let us assume that each of the variables in the above example are scalars. We will start by looking at the effect of <span>$r$</span> on <span>$J$</span> and move backward from there. Basic calculus tells us that:</p><div>\[\begin{aligned}
J &amp;= r^2 \\
{\partial J}/{\partial r} &amp;= 2r
\end{aligned}\]</div><p>Thus, if <span>$r=5$</span> and we decrease <span>$r$</span> by a small <span>$\epsilon$</span>, the squared error <span>$J$</span> will go down by <span>$10\epsilon$</span>. Now let&#39;s move back a step and look at <span>$\hat{y}$</span>:</p><div>\[\begin{aligned}
r &amp;= \hat{y} - y \\
{\partial r}/{\partial \hat{y}} &amp;= 1
\end{aligned}\]</div><p>So how much effect will a small <span>$\epsilon$</span> decrease in <span>$\hat{y}$</span> have on <span>$J$</span> when <span>$r=5$</span>? Well, when <span>$\hat{y}$</span> goes down by <span>$\epsilon$</span>, so will <span>$r$</span>, which means <span>$J$</span> will go down by <span>$10\epsilon$</span> again. The chain rule expresses this idea:</p><div>\[\frac{\partial J}{\partial\hat{y}} = 
\frac{\partial J}{\partial r}
\frac{\partial r}{\partial\hat{y}}
= 2r\]</div><p>Going back further, we have:</p><div>\[\begin{aligned}
\hat{y} &amp;= z + b \\
{\partial \hat{y}}/{\partial b} &amp;= 1 \\
{\partial \hat{y}}/{\partial z} &amp;= 1
\end{aligned}\]</div><p>Which means <span>$b$</span> and <span>$z$</span> have the same effect on <span>$J$</span> as <span>$\hat{y}$</span> and <span>$r$</span>, i.e. decreasing them by <span>$\epsilon$</span> will decrease <span>$J$</span> by <span>$2r\epsilon$</span> as well. Finally:</p><div>\[\begin{aligned}
z &amp;= w x \\
{\partial z}/{\partial x} &amp;= w \\
{\partial z}/{\partial w} &amp;= x
\end{aligned}\]</div><p>This allows us to compute the effect of <span>$w$</span> on <span>$J$</span> in several steps: moving <span>$w$</span> by <span>$\epsilon$</span> will move <span>$z$</span> by <span>$x\epsilon$</span>, <span>$\hat{y}$</span> and <span>$r$</span> will move exactly the same amount because their partials with <span>$z$</span> are 1, and finally since <span>$r$</span> moves by <span>$x\epsilon$</span>, <span>$J$</span> will move by <span>$2rx\epsilon$</span>.</p><div>\[\frac{\partial J}{\partial w} =
\frac{\partial J}{\partial r}
\frac{\partial r}{\partial \hat{y}}
\frac{\partial \hat{y}}{\partial z}
\frac{\partial z}{\partial w}
= 2rx\]</div><p>We can represent this process of computing partial derivatives as follows:</p><blockquote><p><img src="../images/linregback.jpg" alt="image"/></p></blockquote><p>Note that we have the same number of boxes and operations, but all the arrows are reversed. Let us call this the backward pass, and the original computation in the previous picture the forward pass. Each box in this backward-pass picture represents the partial derivative for the corresponding box in the previous forward-pass picture. Most importantly, each computation is local: each operation takes the partial derivative of its output, and multiplies it with a factor that only depends on the original input/output values to compute the partial derivative of its input(s). In fact we can implement the forward and backward passes for the linear regression model using the following local operations:</p><blockquote><p><img src="../images/sqnorm.jpg" alt="image"/></p></blockquote><blockquote><p><img src="../images/sub.jpg" alt="image"/></p></blockquote><blockquote><p><img src="../images/add.jpg" alt="image"/></p></blockquote><blockquote><p><img src="../images/mul.jpg" alt="image"/></p></blockquote><p>This is basically the backpropagation algorithm in a nutshell, i.e.  backpropagation can be viewed as the application of Leibniz&#39; chain rule from 1660s to machine learning in 1980s.</p><h2 id="Multiple-dimensions"><a class="docs-heading-anchor" href="#Multiple-dimensions">Multiple dimensions</a><a id="Multiple-dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-dimensions" title="Permalink"></a></h2><p>Let&#39;s look at the case where the input and output are not scalars but vectors. In particular assume that <span>$x \in \mathbb{R}^D$</span> and <span>$y \in \mathbb{R}^C$</span>. This makes <span>$W \in \mathbb{R}^{C\times D}$</span> a matrix and <span>$z,b,\hat{y},r$</span> vectors in <span>$\mathbb{R}^C$</span>. During the forward pass, <span>$z=Wx$</span> operation is now a matrix-vector product, the additions and subtractions are elementwise operations. The squared error <span>$J=\|r\|^2=\sum r_i^2$</span> is still a scalar. For the backward pass we ask how much each element of these vectors or matrices effect <span>$J$</span>. Starting with <span>$r$</span>:</p><div>\[\begin{aligned}
J &amp;= \sum r_i^2 \\
{\partial J}/{\partial r_i} &amp;= 2r_i
\end{aligned}\]</div><p>We see that when <span>$r$</span> is a vector, the partial derivative of each component is equal to twice that component. If we put these partial derivatives together in a vector, we obtain a <strong>gradient</strong> vector:</p><div>\[\nabla_r J
\equiv \langle \frac{\partial J}{\partial r_1}, \cdots, \frac{\partial J}{\partial r_C} \rangle
= \langle 2 r_1, \ldots, 2 r_C \rangle 
= 2\vec{r}\]</div><p>The addition, subtraction, and square norm operations work the same way as before except they act on each element. Moving back through the elementwise operations we see that:</p><div>\[\nabla_r J = \nabla_{\hat{y}} J = \nabla_b J = \nabla_z J = 2\vec{r}\]</div><p>For the operation <span>$z=Wx$</span>, a little algebra will show you that:</p><div>\[\begin{aligned}
\nabla_W J &amp;= \nabla_z J \cdot x^T \\
\nabla_x J &amp;= W^T \cdot \nabla_z J
\end{aligned}\]</div><p>Note that the gradient of a variable has the same shape as the variable itself. In particular <span>$\nabla_W J$</span> is a <span>$C\times D$</span> matrix. Here is the graphical representation for matrix multiplication:</p><blockquote><p><img src="../images/dot.jpg" alt="image"/></p></blockquote><h2 id="Multiple-instances"><a class="docs-heading-anchor" href="#Multiple-instances">Multiple instances</a><a id="Multiple-instances-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-instances" title="Permalink"></a></h2><p>We will typically process data multiple instances at a time for efficiency. Thus, the input <span>$x$</span> will be a <span>$D\times N$</span> matrix, and the output <span>$y$</span> will be a <span>$C\times N$</span> matrix, the <span>$N$</span> columns representing <span>$N$</span> different instances. Please verify to yourself that the forward and backward operations as described above handle this case without much change: the elementwise operations act on the elements of the matrices just like vectors, and the matrix multiplication and its gradient remains the same. Here is a picture of the forward and backward passes:</p><blockquote><p><img src="../images/batchforwback.jpg" alt="image"/></p></blockquote><p>The only complication is at the addition of the bias vector. In the batch setting, we are adding <span>$b\in\mathbb{R}^{C\times 1}$</span> to <span>$z\in\mathbb{R}^{C\times N}$</span>. This will be a broadcasting operation, i.e. the vector <span>$b$</span> will be added to each column of the matrix <span>$z$</span> to get <span>$\hat{y}$</span>. In the backward pass, we&#39;ll need to add the columns of <span>$\nabla_{\hat{y}} J$</span> to get the gradient <span>$\nabla_b J$</span>.</p><h2 id="Stochastic-Gradient-Descent"><a class="docs-heading-anchor" href="#Stochastic-Gradient-Descent">Stochastic Gradient Descent</a><a id="Stochastic-Gradient-Descent-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Gradient-Descent" title="Permalink"></a></h2><p>The gradients calculated by backprop, <span>$\nabla_w J$</span> and <span>$\nabla_b J$</span>, tell us how much small changes in corresponding entries in <span>$w$</span> and <span>$b$</span> will effect the error (for the current example(s)). Small steps in the gradient direction will increase the error, steps in the opposite direction will decrease the error.</p><p>In fact, we can show that the gradient is the direction of steepest ascent. Consider a unit vector <span>$v$</span> pointing in some arbitrary direction.  The rate of change in this direction, <span>$\nabla_v J$</span> (<a href="http://mathworld.wolfram.com/DirectionalDerivative.html">directional derivative</a>), is given by the projection of <span>$v$</span> onto the gradient, <span>$\nabla J$</span>, i.e. their dot product <span>$\nabla J \cdot v$</span>:</p><div>\[\nabla_v J = \frac{\partial J}{\partial x_1} v_1 + \frac{\partial J}{\partial x_2} v_2 + \cdots = \nabla J \cdot v\]</div><p>What direction maximizes this dot product? Recall that:</p><div>\[\nabla J \cdot v = | \nabla J |\,\, | v | \cos(\theta)\]</div><p>where <span>$\theta$</span> is the angle between <span>$v$</span> and the gradient vector.  <span>$\cos(\theta)$</span> is maximized when the two vectors point in the same direction. So if you are going to move a fixed (small) size step, the gradient direction gives you the biggest bang for the buck.</p><p>This suggests the following update rule:</p><div>\[w \leftarrow w - \nabla_w J\]</div><p>This is the basic idea behind Stochastic Gradient Descent (SGD): Go over the training set instance by instance (or minibatch by minibatch). Run the backpropagation algorithm to calculate the error gradients. Update the weights and biases in the opposite direction of these gradients.  Rinse and repeat...</p><h2 id="Housing-Example"><a class="docs-heading-anchor" href="#Housing-Example">Housing Example</a><a id="Housing-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Housing-Example" title="Permalink"></a></h2><p>We will use the <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/housing">Boston Housing</a> dataset from the UCI Machine Learning Repository to train a linear regression model using backprop and SGD. The dataset has housing related information for 506 neighborhoods in Boston from 1978. Each neighborhood has 14 attributes, the goal is to use the first 13, such as average number of rooms per house, or distance to employment centers, to predict the 14’th attribute: median dollar value of the houses.</p><p>First, we download and convert the data into Julia arrays. The Knet package provides some utilities for this:</p><pre><code class="language-julia">using Knet
include(Knet.dir(&quot;data&quot;,&quot;housing.jl&quot;))
x,y = housing()  # x is (13,506); y is (1,506)</code></pre><p>Second, we implement our loss calculation in Julia. Personally I think <a href="https://docs.julialang.org/en/v0.7.0/manual/methods/#Function-like-objects-1">callable objects</a> are the most natural way to represent parametric functions. But you can use any coding style you wish as long as you can calculate a scalar loss from parameters and data.</p><pre><code class="language-julia">struct Linear; w; b; end                  # new type that can be used as a function
(f::Linear)(x) = f.w * x .+ f.b           # prediction function if one argument
(f::Linear)(x,y) = mean(abs2, f(x) - y)   # loss function if two arguments</code></pre><p>Now we can initialize a model, make some predictions, and calculate loss:</p><pre><code class="language-julia-repl">julia&gt; model = Linear(zeros(1,13), zeros(1))
Linear([0.0 0.0 … 0.0 0.0], [0.0])

julia&gt; pred = model(x)          # predictions for 506 instances
1×506 Array{Float64,2}:
 0.0   0.0   0.0   …  0.0   0.0   0.0

julia&gt; y                        # not too close to real outputs
1×506 Array{Float64,2}:
 24.0  21.6  34.7  …  23.9  22.0  11.9

julia&gt; loss = model(x,y)        # average loss for 506 instances
592.1469169960474</code></pre><p>The loss gradients with respect to the model parameters can be computed manually as described above:</p><pre><code class="language-julia-repl">julia&gt; r = (model(x) - y) / length(y)
1×506 Array{Float64,2}:
 -0.0474308  -0.0426877  -0.0685771  …  -0.0472332  -0.0434783  -0.0235178

julia&gt; ∇w = 2r * x&#39;
1×13 Array{Float64,2}:
 7.12844  -6.617  8.88016  -3.2174  …  8.60132  9.32187  -6.12163  13.5419

julia&gt; ∇b = sum(2r)
-45.06561264822134</code></pre><p>For larger models manual gradient calculation becomes impractical.  The Knet package can calculate gradients automatically for us: (1) mark the parameters with the <code>Param</code> type, (2) apply the <code>@diff</code> macro to the loss calculation, (3) the <code>grad</code> function calculates the gradients:</p><pre><code class="language-julia-repl">julia&gt; model = Linear(Param(zeros(1,13)), Param(zeros(1)))
Linear(P(Array{Float64,2}(1,13)), P(Array{Float64,1}(1)))

julia&gt; loss = @diff model(x,y)
T(592.1469169960474)

julia&gt; grad(loss, model.w)
1×13 Array{Float64,2}:
 7.12844  -6.617  8.88016  -3.2174  …  8.60132  9.32187  -6.12163  13.5419

julia&gt; grad(loss, model.b)
1-element Array{Float64,1}:
 -45.06561264822134</code></pre><p>We can use the gradients to train our model:</p><pre><code class="language-julia">function sgdupdate(model, x, y)
    loss = @diff model(x, y)
    for p in params(model)
        p .-= 0.1 * grad(loss, p)
    end
    return value(loss)
end</code></pre><p>Here is a plot of the loss value vs the number of updates:</p><pre><code class="language-julia-repl">julia&gt; using Plots
julia&gt; plot([sgdupdate(model,x,y) for i in 1:20])</code></pre><p><img src="../images/housing-linreg.png" alt="image"/></p><p>The new predictions are a lot closer to the actual outputs:</p><pre><code class="language-julia-repl">julia&gt; [ model(x); y ]
2×506 Array{Float64,2}:
 30.4126  24.8121  30.7946  29.2931  …  27.6193  26.1515  21.9643
 24.0     21.6     34.7     33.4        23.9     22.0     11.9   </code></pre><h2 id="Problems-with-SGD"><a class="docs-heading-anchor" href="#Problems-with-SGD">Problems with SGD</a><a id="Problems-with-SGD-1"></a><a class="docs-heading-anchor-permalink" href="#Problems-with-SGD" title="Permalink"></a></h2><p>Over the years, people have noted many subtle problems with the SGD algorithm and suggested improvements:</p><p><strong>Step size:</strong> If the step sizes are too small, the SGD algorithm will take too long to converge. If they are too big it will overshoot the optimum and start to oscillate. So we scale the gradients with an adjustable parameter called the learning rate <span>$\eta$</span>:</p><p><span>$w \leftarrow w - \eta \nabla_w J$</span></p><p><strong>Step direction:</strong> More importantly, it turns out the gradient (or its opposite) is often NOT the direction you want to go in order to minimize error. Let us illustrate with a simple picture:</p><blockquote><p><img src="../images/longnarrowvalley.png" alt="image"/></p></blockquote><p>The figure on the left shows what would happen if you stood on one side of the long narrow valley and took the direction of steepest descent: this would point to the other side of the valley and you would end up moving back and forth between the two sides, instead of taking the gentle incline down as in the figure on the right. The direction across the valley has a high gradient but also a high curvature (second derivative) which means the descent will be sharp but short lived. On the other hand the direction following the bottom of the valley has a smaller gradient and low curvature, the descent will be slow but it will continue for a longer distance. <a href="https://en.wikipedia.org/wiki/Newton%27s_method_in_optimization">Newton&#39;s method</a> adjusts the direction taking into account the second derivative:</p><blockquote><p><img src="../images/330px-Newton_optimization_vs_grad_descent.svg.png" alt="image"/></p></blockquote><p>In this figure, the two axes are w1 and w2, two parameters of our network, and the contour plot represents the error with a minimum at x.  If we start at x0, the Newton direction (in red) points almost towards the minimum, whereas the gradient (in green), perpendicular to the contours, points to the right.</p><p>Unfortunately Newton&#39;s direction is expensive to compute. However, it is also probably unnecessary for several reasons: (1) Newton gives us the ideal direction for second degree objective functions, which our objective function almost certainly is not, (2) The error function whose gradient backprop calculated is the error for the last minibatch/instance only, which at best is a very noisy approximation of the real error function, thus we shouldn&#39;t spend too much effort trying to get the direction exactly right.</p><p>So people have come up with various approximate methods to improve the step direction. Instead of multiplying each component of the gradient with the same learning rate, these methods scale them separately using their running average (momentum, Nesterov), or RMS (Adagrad, Rmsprop).  Some even cap the gradients at an arbitrary upper limit (gradient clipping) to prevent instabilities.</p><p>You may wonder whether these methods still give us directions that consistently increase/decrease the objective function. If we do not insist on the <em>maximum</em> increase, any direction whose components have the same signs as the gradient vector is guaranteed to increase the function (for short enough steps). The reason is again given by the dot product <span>$\nabla J \cdot v$</span>. As long as these two vectors carry the same signs in the same components, the dot product, i.e. the rate of change along <span>$v$</span>, is guaranteed to be positive.</p><p><strong>Minimize what?</strong> The final problem with gradient descent, other than not telling us the ideal step size or direction, is that it is not even minimizing the right objective! We want small error on never before seen test data, not just on the training data. The truth is, a sufficiently large model with a good optimization algorithm can get arbitrarily low error (down to the noise limit) on any finite training data (e.g. by just memorizing the answers). And it can typically do so in many different ways (typically many different local minima for training error in weight space exist). Some of those ways will generalize well to unseen data, some won&#39;t. And unseen data is (by definition) not seen, so how will we ever know which weight settings will do well on it?</p><p>There are at least three ways people deal with this problem: (1) Bayes tells us that we should use all possible models and weigh their answers by how well they do on training data (see Radford Neal&#39;s fbm), (2) New methods like dropout that add distortions and noise to inputs, activations, or weights during training seem to help generalization, (3) Pressuring the optimization to stay in one corner of the weight space (e.g. L1, L2, maxnorm regularization) helps generalization.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li><a href="http://ufldl.stanford.edu/tutorial/supervised/LinearRegression">UFLDL Tutorial, Linear Regression</a></li><li><a href="http://cs231n.github.io/optimization-1">cs231n Optimization Notes</a></li><li><a href="http://cs229.stanford.edu/section/cs229-cvxopt.pdf">cs229 Convex optimization overview</a>, <a href="http://cs229.stanford.edu/section/cs229-cvxopt2.pdf">Part 2</a></li><li><a href="http://cs229.stanford.edu/section/cs229-linalg.pdf">cs229 Linear algebra review and reference</a></li><li><a href="http://cs229.stanford.edu/section/cs229-prob.pdf">cs229 Review of probability theory</a></li></ul><h2 id="Notes"><a class="docs-heading-anchor" href="#Notes">Notes</a><a id="Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Notes" title="Permalink"></a></h2><ul><li><p>Supervised learning is also known as <strong>regression</strong> if the outputs are numeric and <strong>classification</strong> if they are discrete. </p></li><li><p><strong>Linear regression</strong> is a regression model with a linear prediction function.  Linear regression with a scalar input and output is called <strong>simple linear regression</strong>, if the input is a vector we have <strong>multiple linear regression</strong>, and if the output is a vector we have <strong>multivariate linear regression</strong>.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference/">« Reference</a><a class="docs-footer-nextpage" href="../softmax/">Softmax Classification »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 16 October 2020 10:25">Friday 16 October 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
